#+TITLE: Sistemas Operativos — Introducción
#+AUTHOR: Gunnar Wolf
#+EMAIL: gwolf@gwolf.org
#+LANGUAGE: es
#+INFOJS_OPT: tdepth:1 sdepth:1 ftoc:nil ltoc:nil

* ¿Qué es un sistema operativo?

El /sistema operativo/ es el principal programa que corre en toda
computadora de propósito general.

Hay sistemas operativos de todo tipo, desde muy simples hasta
terriblemente complejos, y entre más casos de uso hay para el cómputo
en la vida diaria, más variedad habrá en ellos.

No nos referiremos al sistema operativo como lo ve el usuario final, o
como lo vende la mercadotecnia — El ambiente gráfico, los programas
que se ejecutan en éste, la diferencia en el uso son sólo –y si mucho–
/consecuencias/ del diseño de un sistema operativo. Más aún, con el
mismo sistema operativo –como pueden constatarlo comparando dos
distribuciones de Linux, o incluso la forma de trabajo de dos usuarios
en la misma computadora– es posible tener /entornos operativos/
completamente disímiles.

La importancia de este curso radica no sólo en comprender los
mecanismos que emplean los sistemas operativos para cumplir sus tareas
sino en que comprendan estos mecanismos para evitar los errores más
comunes al programar, que pueden resultar desde un rendimiento
deficiente hasta pérdida de información.

Como desarrolladores, comprender el funcionamiento básico de los
sistemas operativos y las principales alternativas que nos ofrecen en
muchos de puntos, o saber diseñar algoritmos y procesos que se ajusten
mejor al sistema operativo en que vayamos a correrlo, puede resultar
en una diferencia cualitativa decisiva en nuestros productos.

* Funciones y objetivos de los sistemas operativos

El sistema operativo es el único programa que interactúa directamente
con el hardware de la computadora. Sus funciones primarias son:

- Abstracción :: Los programas no deben tener que preocuparse de los
                 detalles del acceso a hardware, o de la configuración
                 particular de una computadora. Un sistema operativo
                 se encarga de proporcionar una serie de abstracciones
                 para que los programadores puedan enfocarse en
                 resolver las necesidades particulares de sus
                 usuarios. Un ejemplo de la abstracción sería el que
                 la información esté organizada en /archivos/ y
                 /directorios/ (en uno o muchos /dispositivos de
                 almacenamiento/).

- Manejo de recursos :: Una sistema de cómputo puede tener a su
     disposición una gran cantidad de /recursos/ (memoria, espacio de
     almacenamiento, tiempo de procesamiento, etc.), y los diferentes
     /procesos/ que corran en él /compiten/ por ellos. Al gestionar
     toda la asignación de recursos, el sistema operativo puede
     implementar políticas que los asignen de forma efectiva y acorde
     a las necesidades establecidas para dicho sistema.

- Aislamiento :: Cada proceso y cada usuario no tendrán que
                 preocuparse por otros que estén usando el mismo
                 sistema — Idealmente, su /experiencia/ será la misma
                 que si el sistema estuviera exclusivamente dedicado a
                 su atención (aunque fuera un sistema menos
                 poderoso).

		 Para implementar correctamente las funciones de
		 aislamiento hace falta que el sistema operativo
		 cuente con ayuda del hardware.

* Evolución de los sistemas operativos

** Proceso por lotes (/batch processing/)

Los antecedentes a lo que hoy comprendemos como sistema operativo
podemos encontralros en la primer automatización de proceso de
diferentes programas que encontramos en los primeros centros de
cómputo: Cuando en los 1950 aparecieron los dispositivos
perforadores/lectores de tarjetas de papel, el tiempo que una
computadora estaba improductiva esperando a que estuviera lista una
/tarea/ (como se designaba a una ejecución de cada determinado
programa) para ejecutarse disminuyó fuertemente: Los programadores
entregaban sus /tambaches/ o lotes de tarjetas perforadas (en inglés,
batches) a los operadores, quienes las alimentaban a los dispositivos
lectores, que lo cargaban en memoria en un tiempo razonable, iniciaban
y monitoreaban la ejecución, y producían los resultados.

En esta primer época en que las computadoras se especializaban en
tareas de cálculo intensivo y los dispositivos que interactuatan con
medios externos eran prácticamente desconocidos, el rol del sistema
/monitor/ o /de control/ era básicamente asistir al operador en la
carga de los programas y las bibliotecas requeridas, la notificación
de resultados, y la contabilidad de recursos empleados para su cobro.

Los sistemas monitor se fueron sofisticando al implementar
protecciones que evitaran la corrupción de /otros trabajos/ (por
ejemplo, lanzar erróneamente la instrucción /leer siguiente tarjeta/
causaría que el siguiente trabajo encolado perdiera sus primeros
caracteres, corrompiéndolo e impidiendo su ejecución), o que entraran
en un ciclo infinito, estableciendo /alarmas/ (/timers/) que
interrumpirían la ejecución de un proceso si éste duraba más allá del
tiempo estipulado. Estos monitores implicaban la modificación del
hardware para contemplar dichas características de seguridad — Y ahí
podemos ya hablar de la característica básica de gestión de recursos
que identifica a los sistemas operativos.

Cabe añadir que el tiempo de carga y puesta a punto de una tarea
seguía representando una parte importante del tiempo que la
computadora dedicaba al proceso: Un lector de cintas rápido procesaba
del órden de cientos de caracteres por minuto, y a pesar de la
lentitud relativa de las computadoras de los 1950s ante los estándares
de hoy (las mediríamos por miles de instrucciones por segundo, KHz, en
vez de miles de millones como lo hacemos hoy, GHz), esperar cinco o
diez minutos con el sistema completamente detenido por la carga de un
programa moderado resulta a todas luces un desperdicio.

** Sistemas en lotes con dispositivos de carga (/spool/)

Una mejoría natural a este último punto fue la invención del /spool/:
Un mecanismo de entrada/salida que permitía que una computadora de
propósito específico, mucho más económica y limitada, leyera las
tarjetas y las fuera convirtiendo a cinta magnética, un medio mucho
más rápido, teniéndola lista para que la computadora central la
cargara cuando terminara con el trabajo anterior. Del mismo modo, la
computadora central guardaría sus resultados en cinta para que equipos
especializados la leyeran e imprimieran para el usuario solicitante.

La palabra /spool/ (/bobina/) se tomó como /acrónimo inverso/ hacia
/Simultaneous Peripherial Operations On-Line/, /Operación simultánea
de periféricos en línea/.

** Sistemas multiprogramados

A lo largo de su ejecución, un programa normalmente pasa por etapas
con muy distintas características: Al estar en un ciclo fuertemente
dedicado al cálculo numérico, el sistema opera /limitado por el CPU/
(/CPU-bound/), mientras que al leer o escribir resultados a medios
externos (incluso a través de /spools/) el límite es impuesto por los
dispositivos, esto es, opera /limitado por entrada-salida/ (/I-O
bound/). La /programación multitareas/ o los /sistemas
multiprogramados/ buscaban maximizar más aún el tiempo de uso efectivo
del procesador ejecutando varios procesos al mismo tiempo.

El hardware requerido cambió fuertemente. Si bien se esperaba que cada
usuario fuera responsable con el uso de recursos, se hizo necesario
que apareciera la infraestructura de protección de recursos: Un
proceso no debe sobreescribir el espacio de memoria de otro (ni el
código ni los datos), mucho menos el espacio del monitor. Esta
protección la encontramos en la /Unidad de Manejo de Memoria/ (MMU),
presente en todas las computadoras de uso genérico desde los 1990.

Ciertos dispositivos requieren bloqueo para ofrecer acceso
exclusivo/único — Cintas e impresoras, por ejemplo, son de acceso
estrictamente secuencial, y si dos usuarios intentaran usarlas al
mismo tiempo, el resultado para ambos se corrompería. Para estos
dispositivos, el sistema debe implementar otros /spools/ y mecanismos
de bloqueo.

** Sistemas de tiempo compartido

El modo de interactuar con las computadoras cambió fuertemente al
aparecer, durante los 1960s, al extenderse la multitarea para
convertirse en sistemas /interactivos/ y /multiusuarios/, en buena
medida diferenciados de los anteriores por la aparición de las
/terminales/ (primero teletipos seriales, posteriormente equipos con
una pantalla completa como las conocemos hasta hoy).

En primer término, la tarea de programación y depuración del código se
simplificó fuertemente al poder el programador hacer directamente
cambios y someter el programa a ejecución de inmediato. En segundo
término, la computadora /nunca más estaría simplemente esperando a
estar lista/: Mientras un programador editaba o compilaba su programa,
la computadora seguiría calculando lo que otros procesos requirieran.

Además, fueron naciendo de forma natural y paulatina las abstracciones
que conocemos hoy en día, como el concepto de /archivos/ y
/directorios/, y el código necesario para emplearlos iba siendo
enviado a través de las /bibliotecas de sistema/ y, cada vez más (por
su centralidad) hacia el núcleo mismo del –ahora sí– sistema
operativo.

Más alla del cambio del dispositivo de acceso, un cambio importante
entre los sistemas multiprogramados y de tiempo compartido es la
velocidad del cambio entre una tarea y otra es mucho más rápido: Si
bien en un sistema multiprogramado un /cambio de contexto/ podía
producirse sólo cuando la tarea cambiara de uno a otro modos de
ejecución y el resultado no se vería fuertemente afectado, en un
sistema interactivo, para dar la /ilusión/ de uso directo de la
computadora, el hardware emitiría al sistema operativo
/interrupciones/ (señales) que le indicaran múltiples veces /por
segundo/ para que cambie el /proceso/ activo (como ahora se le
denomina a una instancia de un programa en ejecución).

Diferentes tipos de proceso pueden tener distinto nivel de importancia
— Ya sea porque son más importantes para el funcionamiento de la
computadora misma (procesos de sistema), porque tienen mayor carga de
interactividad (por la experiencia del usuario) o por diversas
categorías de usuarios (sistemas con contabilidad por tipo de
atención). Esto requiere la implementación de diversas /prioridades/
para cada uno de estos.

** Computadoras personales

Si bien la discusión hasta este momento asume una computadora central
con operadores dedicados y múltiples usuarios, en la década de los
1970 comenzaron a aparecer las /computadoras personales/, sistemas en
un inicio verdaderamente reducidos en prestaciones y a un nivel de
precios que los ponían al alcance, primero, de los aficionados
entusiastas y, posteriormente, de cualquiera.

#+begin_center
[[./img/altair.jpg]]

La /microcomputadora Altair 8800/, primer computadora personal con
distribución masiva, a la venta a partir de 1975
#+end_center

Las primeras computadoras personales tampoco eran distribuídas con
sistemas operativos o lenguajes de programación; la interfaz primaria
para programarlas era a través de /switches/, y para recibir sus
resultados, de bancos de LEDs. Claro está, esto requería conocimientos
especializados, y las computadoras personales eran aún vistas sólo
como juguetes caros.

La verdadera revolución apareció cuando‚ poco tiempo más tarde,
comenzaron a venderse computadoras personales con salida de video
(típicamente a través de una televisión) y entrada a través de un
teclado. Estas computadoras popularizaron el lenguaje de programación
BASIC, diseñado para usuarios novatos en los 1960, y para permitir a
los usuarios gestionar sus recursos (unidades de cinta, pantalla
posicionable, unidades de disco, impresoras, modem, etc.) llevaban un
software mínimo de sistema — Nuevamente, un proto-sistema operativo.

#+begin_center
[[./img/commodore_pet.jpg]]

La /Commodore Pet 2001/, en el mercado desde 1977, una de las primeras
con intérprete de BASIC
#+end_center



# Los primeros sistemas operativos no contaban con la ayuda en hardware
# de diversos componentes indispensables para presentar ciertas
# características de abstracción, como la /unidad de administración de
# memoria/ (MMU) o un esquema de /anillos/ o niveles de protección.

# Esto significó que tenían que realizar su tarea con la cooperación
# explícita de los autores de todos los programas — Y que un programa
# /mal comportado/ podía corromper la operación completa del equipo.

# En esta primer etapa sí había sistemas operativos multiprocesos
# (incluso en las computadoras personales — Por ejemplo, AmigaOS, ATARI
# TOS hacia mediados de los 1980s), sin embargo, su estabilidad da mucho
# que desear.

* Estructuras de los sistemas operativos
** Sistemas operativos monolíticos

** Sistemas operativos /microkernel/

Discusión interesante y reciente (diciembre 2012): [[http://tech.slashdot.org/story/12/12/02/1526240/multi-server-microkernel-os-genode-1211-can-build-itself?utm_source=rss1.0mainlinkanon&utm_medium=feed][Multi-server
microkernel OS Genode 12.11 can build itself]]. Ver también: [[http://genode.org/documentation/general-overview/index][Genode –
General overview]]

** Sistemas con concepciones híbridas

- Linux con drivers implementados en espacio de usuario (FUSE)
- Paravirtualización


* Otros recursos

- [[http://cs.gordon.edu/courses/cs322/lectures/history.html][CS322: A Brief History of Computer Operating Systems]]
