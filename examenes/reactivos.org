#+TITLE: Reactivos para exámenes y ejercicios
#+AUTHOR: Sistemas Operativos · Gunnar Wolf
#+OPTIONS: num:t toc:nil
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage[margin=2cm]{geometry}
#+LATEX_HEADER: \usepackage[spanish]{babel}
#+LANGUAGE: es

* Introducción a los sistemas operativos
1. Se denomina así al modelo de cómputo en que se realizan procesos en
   paralelo entre procesadores que no comparten un espacio común de
   memoria
   - R: distribuido

2. La "era de oro" de las arquitecturas de 8 bits se caracterizó por...
   (Seleccione al menos una respuesta.)
   1. La popularización de diversos dispositivos de entrada y salida
   2. Venían de serie con unidades de disco de 5.25"
   3. Tuvo muchas arquitecturas incompatibles entre sí
   4. Las computadoras personales actuales son básicamente evolución de las arquitecturas de 8 bits
   5. Estaban enfocadas al mercado de las pequeñas y medianas empresas
   6. Popularizaron la programación en BASIC

3. ¿En qué se diferencía la multitarea preventiva de la cooperativa?
   Para todas las opciones, lee: "A diferencia de la multitarea
   cooperativa, la preventiva..."
   (Seleccione al menos una respuesta.)
   1. Es inmune a que un cálculo demasiado largo o un ciclo infinito dejen a la computadora efectivamente congelada
   2. Es la más utilizada hoy en día
   3. Ocurre sólo cuando el proceso hace una llamada al sistema
   4. Se emplea principalmente en sistemas multiusuario
   5. Requiere apoyo de hardware

4. Llamamos almacenamiento primario a...
   (Seleccione una respuesta.)
   1. Las unidades de almacenamiento no volátil de largo plazo (discos, memoria Flash, USB, etc.)
   2. La capa de memoria que corre a mayor velocidad y está más cerca del procesador
   3. Los registros, espacio de memoria de extremadamente alta velocidad ubicados dentro del mismo procesador
   4. La memoria RAM del sistema

5. La Ley de Moore postula que para que sigamos ganando velocidad de
   cómputo una vez que la carrera de los GHz nos llevó al punto en que
   la eficiencia térmica evita que podamos seguir subiendo el reloj de
   las computadoras de uso general, es necesario diseñar chips con más
   núcleos y adoptar el multiprocesamiento.  (Verdadero/Falso)

6. Las computadoras nacieron en el mercado de los aficionados o
   hobbyistas a mediados de la década de 1970. Las primeras
   aparecieron poco después de que el hardware necesario para
   construir teclados y monitores a costos menores a US$1,000
   (Verdadero/Falso)

7. Los primeros microprocesadores contaban con únicamente un registro
   de propósito general, que operaba a grandes rasgos como una pila
   (stack). ¿Cómo se llamaba a este único registro?
   - R: acumulador

8. El cómputo es un campo en constante evolución. Hoy en día tenemos
   el problema de la diferencia de velocidad entre la memoria y el
   procesador, que nos obliga a emplear memorias intermedias
   (caché). Las tendencias indican que el problema se va reduciendo, y
   en unos años la memoria podrá ser accesada prácticamente a la misma
   velocidad que el reloj del CPU.
   (Verdadero/Falso)

9. Un sistema operativo ofrece una serie de recursos o características
   principales, tanto a sus usuarios como a sus programadores.
   (Relaciona cada concepto con su descripción.)
   - Conceptos:
     - Aislamiento
     - Administración de recursos
     - Abstracción
     - No es una característica que ofrezca el sistema operativo
   - Descripciones:
     - Implementar políticas que repartan la atención del sistema de
       forma efectiva y acorde a las necesidades establecidas entre
       los diferentes procesos o usuarios.
     - Cada proceso y cada usuario no tendrán que preocuparse por
       otros que estén usando el mismo sistema — Idealmente, su
       experiencia será la misma que si el sistema estuviera
       exclusivamente dedicado a su atención. Requiere que el sistema
       operativo cuente con ayuda del hardware.
     - Presentar una interfaz consistente al usuario (puede ser
       gráfica o textual), eliminando las diferencias que provendrían
       de manejar distintos tipos de hardware
     - Los programadores no deben tener que preocuparse de los
       detalles del acceso a hardware, o de la confiuración particular
       de una computadora. El programador debe poder enfocarse en
       resolver los problemas o necesidades particulares de sus
       usuarios.

10. ¿Cuál es el máximo de información (en bytes) que puede transferir
    a memoria en un segundo (iniciando la transferencia en ese
    momento) un disco con un tiempo de acceso de 15ms y una tasa de
    transferencia de 80MB/s?

11. Los sistemas de tiempo compartido trajeron una verdadera
    revolución en la forma de uso de los recursos de
    cómputo. Relaciona los conceptos para indicar qué característica
    va relacionada con qué cambio
    - Conceptos:
      - Terminales (teletipos, teclado+CRT)
      - Sistemas de archivos (archivos, directorios)
      - Bibliotecas de sistema
      - Colas de priorización
    - Descripciones:
      - Algunos procesos tienen mayor carga de interactividad, otros
        son fundamentales para el funcionamiento del sistema, y otros
        son de usuarios muy importantes. ¿Cómo lo resolvemos?
      - Colecciones de código disponibles para ser ligadas desde los
        diferentes programas para ofrecer funcionalidad básica
      - Uso interactivo, mayor facilidad de programación y depuración
      - Abstracciones necesarias para soportar el modelo de uso
        multiusuario
12. ¿Cuáles son las principales características de los distintos
    modelos de multiprocesamiento?
    - Conceptos:
      - Cómputo en la nube
      - NUMA
      - Web Services
      - SMP
      - Cluster o cúmulo
      - Grid o malla
    - Descripciones:
      - Modelo de distribución del cómputo en que se pueden proveer
        (como un servicio) recursos de cómputo para necesidades
        específicas sobre demanda, bajo tres modalidades principales
      - Cada procesador tiene afinidad por ciertos bancos de memoria,
        aunque puede también direccionar a los que le quedan más
        lejos.
      - Computadoras independientes, con características idénticas o
        muy similares de hardware, conectadas a través de una red
        local (LAN)
      - Computadoras independientes, posiblemente con características
        de hardware muy distintas entre sí, conectadas típicamente por
        redes de área amplia (WAN) como Internet
      - Mecanismo de llamada a procedimientos remotos (RPC) que está
        basado en el protocolo HTTP y algún lenguaje de marcado
        estructurado como XML, JSON o YAML
      - Todos los procesadores tienen el mismo acceso a la memoria y
        los dispositivos del sistema

13. Las primeras computadoras de proceso en lotes (batch processing)
    no contaban aún con hardware de protección, cualquiera de sus
    usuarios podía ejecutar cualquier instrucción (Verdadero/Falso)

14. De la siguiente lista de eventos, marca aquellos que corresponden
    a interrupciones (y no a aquellos que corresponden a excepciones)
    1. El usuario accionó alguna tecla en el teclado
    2. Se produjo un acceso ilegal a memoria fuera del segmento
       (segmentation fault)
    3. El proceso en ejecución lanzó una llamada al sistema
    4. Llegó un paquete a la interfaz de red
    5. Se produjo una división sobre cero
    6. El proceso en ejecución estuvo activo ya demasiado tiempo, es
       hora de un cambio de contexto
    7. Los datos solicitados al controlador de disco duro ya están
       disponibles

15. Si el procesador de un sistema corre a 1GHz, la latencia de la
    memoria es de 130ns, y el bus de memoria puede sostener un ancho
    de banda de 3000 MB/s, asumiendo que no hay ningún otro proceso en
    ejecución que entorpezca el proceso, ¿cuántos ciclos de reloj
    tiene que esperar el procesador al solicitar una palabra (64
    bits)?

16. Algunos dispositivos requieren de bloqueo para garantizar a un
    programa su acceso exclusivo. ¿Cuáles de los siguientes entrarían
    en ese supuesto? (Seleccione al menos una respuesta.)
    1. Teclado
    2. Unidad de cinta
    3. Discos
    4. Impresora

17. ¿Es cierto que los sistemas microkernel presentan interfaces más
    claras que los monolíticos? (Verdadero/Falso)

18. Un programa típicamente pasa por varias etapas en su ejecución,
    algunas de las cuales están limitadas por el procesador, mientras
    que las otras están limitadas por la entrada/salida. Los
    componentes del sistema que están ocupados en cada caso son
    distintos.

    ¿Qué tipo de sistemas nacieron para responder a esta necesidad?

19. ¿Qué factores principales hicieron que se diera el primer paso
    hacia el desarrollo de los sistemas operativos con el nacimiento
    de los sistemas de proceso en lote (batch processing)? (Seleccione al menos una respuesta.)
    1. Ofrecer una vista abstracta de los recursos de la computadora
    2. La dificultad de programar
    3. Seguridad personal de los programadores (ante descargas
       eléctricas)
    4. Permitir que el procesador trabajara en más de un proceso a la
       vez
    5. Depuración más fácil
    6. El tiempo que demoraba la programación del sistema

20. En 1984, esta computadora tomó las ideas desarrolladas en Xerox
    PARC en los 1970 y se convirtió en el primer equipo exitoso a
    escala comercial en ofrecer la metáfora WIMP (Windows, Icons,
    Menus, Pointer) en una interfaz usuario nativamente gráfica (GUI -
    Graphical User Interface)

21. Los sistemas Unix llegaron a las computadoras personales desde
    principios de los 1980, pero sólo se popularizaron hasta ya
    entrados los 1990. Completa las afirmaciones con la respuesta que
    les corresponda.
    - Conceptos:
      - GCC, GNU y HURD
      - sparc (Sun), Alpha (Digital), Silicon Graphics (SGI)
      - 386/BSD, Linux, NetBSD
      - A/UX (Apple), Xenix (Microsoft), SCO (Santa Cruz Operation)
    - Descripciones:
      - Algunos sistemas Unix en el escritorio en la década de 1980
        fueron:
      - Ya en los 1990 surgieron varios sistemas Unix libres
        completamente viables para su uso. Aunque uno tuvo resbalones
        legales para iniciar, técnicamente era un Unix completo, y hoy
        se pueden utilizar varios de sus descendientes. Algunos de
        estos son
      - Con la llegada de las computadoras personales suficientemente
        potentes y capaces, el mercado de las llamadas "estaciones de
        trabajo" se fue achicando hasta prácticamente
        desaparecer. Algunas de las compañías y arquitecturas que
        desaparecieron fueron:
      - A mediados de los 1980 nació la Fundación de Software Libre
        (FSF), e inició la implementación de un compilador de C, un
        entorno usuario Unix, con un núcleo microkernel (este último
        nunca alcanzó la madurez). El compilador, el proyecto del
        sistema Unix y el microkernel se llamaban respectivamente:

* Administración de procesos
** Conceptos de procesos e hilos
 1. ¿Qué diferencia hay entre un programa y un proceso?

 2. Un proceso puede estar en uno de los siguientes cinco
    estados. Describe brevemente cada a uno de ellos.
    - Nuevo:
    - Listo:
    - Bloqueado:
    - En ejecución:
    - Terminado:

 3. Dentro del /bloque de control del proceso/ (PCB) encontramos toda
    la información que, junto con su imagen en memoria, define e
    identifica a un proceso en particular. Describe qué información
    contienen:
    - Registros del CPU:
    - Información de contabilidad:
    - Contador del programa:

 4. Describe los tres principales patrones de trabajo para la
    /paralelización de la ejecución/ en varios hilos:
    - Jefe / trabajador:
    - Equipo de trabajo:
    - Línea de ensamblado:

** Sincronización
  1. Define brevemente los siguientes conceptos:
     - Concurrencia:
     - Operación atómica:
     - Condición de carrera:
     - Sección crítica:
     - Espera activa:

  2. Describe el funcionamiento (incluyendo las operaciones soportadas) de los /semáforos/

  3. Existen estrategias basadas en hardware para manejar la
     sincronización. Describe brevemente en lo que consisten las
     siguientes técnicas, y por qué no se encuentran en uso
     generalizado.

     2. Inhabilitación de interrupciones

     3. Memoria transaccional

  4. Vimos varios patrones de sincronización que emplean a los semáforos
     como mecanismo de comunicación. De ellos,

     1. ¿Cuándo se emplea un mutex? Muestra su implementación básica
       	entre dos hilos/procesos basada en semáforos.

     2. Explica cuál es la lógica y la utilidad del patrón /apagador/

     3. Menciona otros tres patrones

  5. Presenta en pseudocódigo la resolución del problema
     productores-consumidores. Menciona en qué puntos tuviste que
     emplear estructuras de sincronización, cuál estructura/patrón
     elegiste, y por qué.

     El planteamiento base es:
     - Un grupo de procesos va /produciendo/ ciertas estructuras
     - Otro grupo va /consumiéndolas/
     - Emplean un buffer de acceso compartido para comunicarse dichas
       estructuras
     - ¿Cómo pueden asegurar que no corromperán el buffer al haber
       accesos simultáneos?
     - ¿Cómo puedes evitar una /espera activa/ por parte del consumidor
       para encontrar cuándo hay elementos por procesar?

  6. ¿Cuál es la principal problemática ilustrado por el problema de la
     /cena de los filósofos/? Describe una de las estrategias que se
     presentaron para su resolución.

** Bloqueos mutuos y políticas
1. En clase vimos dos situaciones bastante similares de /bloqueos
   mutuos/ que se presentan en la vida real, fuera del ámbito del
   cómputo. Describe uno de estos ejemplos (o algún otro ejemplo que
   puedas citar que constituya un bloqueo mutuo), explicando por qué
   lo caracterizamos como objeto mutuo. /Tip/: Recuerda las cuatro
   /condiciones de Coffman/. Puedes describir por qué se cumple cada
   una de ellas (aunque sea "jalando" su definición al alejarla el
   entorno de los sistemas operativos).

2. Presenta, en prosa y a través de un esquema, la situación /clásica
   mínima/ de bloqueo mutuo. Detalla el órden de instrucciones que
   tienen que presentarse para que se dé el bloqueo.

3. Vimos tres categorías de estrategias ante los bloqueos
   mutuos. Describe en qué consisten, y cuáles son sus principales
   ventajas o desventajas:

   - Prevención:

   - Evasión:

   - Detección y recuperación:

4. En el caso de políticas preventivas, ¿cómo se comportaría la
   situación /clásica mínima/ de bloqueo mutuo que describiste en el
   inciso 2 si el sistema implementa una política de:

   - Serialización

   - Asignación jerárquica (inventa y detalla la jerarquía que emplearás)

5. ¿Cuál es la lógica básica de operación del algoritmo del banquero?

6. En un sistema con 2 unidades de cinta y 3 impresoras, y partiendo
   de la siguiente situación, con el algoritmo del banquero:
   |         |  Impresoras |    Reclamo |  U. Cinta |  Reclamo |
   | Proceso | Asignadadas | Impresoras | Asignadas | U. Cinta |
   |---------+-------------+------------+-----------+----------|
   | A       |           1 |          3 |         0 |        1 |
   | B       |           1 |          2 |         0 |        2 |
   | C       |           1 |          1 |         1 |        2 |
   - ¿Estamos en un /estado seguro/?
   - ¿Qué solicitudes nos llevarían a otro /estado seguro/?
   - ¿Qué solicitudes nos llevarían a un /estado inseguro/?
   - Presenta una /secuencia segura/ de finalización.

7. Cuando un algoritmo de detección y recuperación detecta un bloqueo,
   /casi siempre/ va a terminar la ejecución de un proceso.
   - Dame dos criterios según los cuales podría elegir a cuál
     finalizar.
   - ¿Qué otra estrategia podría emplear, además de la de finalizar a
     los procesos involucrados? ¿Por qué es tan poco frecuente emplearla?

* Planificación de procesos

** Tipos de proceso
1. Describe los siguientes conceptos empleados para la medición
   relacionada con el planificador a corto plazo:
   - Tick:
   - Quantum:
   - Tiempo de respuesta ($T$):
   - Tiempo en espera ($E$):
   - Proporción de penalización ($P$):
   - Proporción de respuesta ($R$):
   - Valor de saturación ($\rho$):

2. En un sistema interactivo, los procesos típicamente están en
   ejecución un largo periodo de tiempo (entre minutos y días), sin
   embargo, en nuestros ejemplos manejamos casi siempre a los procesos
   interactivos como /procesos cortos/. ¿Por qué? ¿Cuál sería un
   ejemplo de /proceso largo/?

** Algoritmos de planificación
1. Asumiendo los siguientes procesos:
   | Proceso | Llegada | $t$ |
   |---------+---------+-----|
   | A       | 0       | 7   |
   | B       | 2       | 15  |
   | C       | 3       | 2   |
   | D       | 4       | 6   |
   | E       | 6       | 8   |
   | F       | 6       | 3   |
   Presenta la representación gráfica de cómo el despachador les
   asignaría el CPU, y la tabla de análisis, bajo:
   - Ronda con $q=1$
   - Ronda con $q=3$
   - Proceso más corto a continuación
   - Retroalimentación multinivel con $q=1$, $n=1$ y $Q=nq$


2. ¿Qué algoritmos de los estudiadios son más susceptibles a la
   inanición que se presenta cuando $\rho > 1$? ¿Cuáles menos?
   Menciona por lo menos dos y dos.

3. Describe dos de los esquemas híbridos de planificación presentados.

4. En su libro /Sistemas operativos: diseño e implementación/, Andrew
   Tannenbaum sugiere otro esquema de planificación: El de la
   /lotería/.

   En este esquema, cada proceso tiene un cierto número de /boletos/,
   y sl siguiente /quantum/ es asignado a través de la selección
   aleatoria de uno de los boletos disponibles. Un proceso de mayor
   prioridad tendrá más boletos, uno de menor prioridad tendrá
   menos.

   - ¿Cómo se compararía este método con los otros revisados en clase?
   - ¿Para qué tipo de carga es más apto? ¿Y menos apto?
   - ¿Qué tan susceptible resulta a producir inanición?
   - ¿Qué tan /justa/ sería su ejecución?
   - ¿Cómo lo emplearías si tuvieras procesos con necesidades de
     tiempo real?
   - ¿Se te ocurre algún punto adicional no mencionado en el
     planteamiento para que resulte mejor?

** Planificación de multiprocesadores
1. Tanto la afinidad a procesador como el balanceo de cargas son
   elementos importantes y deseables en todo planificador que se
   ejecute en un entorno multiprocesador. Sin embargo, afinidad y
   balanceo de cargas trabajan uno en contra del otro. ¿Por qué?
   ¿Cuándo debe predominar cada uno?

2. ¿Cuál sería el impacto de no contar con /afinidad dura/ en un
   sistema NUMA? (recuerda: Non-Uniform Memory Access, Acceso
   No-Uniforme a Memoria)

3. Si nuestro planificador maneja una sóla cola de procesos para todos
   los procesadores, ¿Cómo se ve afectado el balanceo de cargas? ¿La
   afinidad?

** Tiempo real

1. ¿Por qué un sistema operativo /de propósito general/ no puede
   ofrecer garantías /de tiempo real duro/ en una computadora
   /estándar/?
* Administración de memoria

1. Diagrama el acomodo del espacio en memoria de un proceso. ¿Qué
   diferencias principales y qué similitudes tienen la /sección de
   datos/ con el /espacio de libres/? ¿Y el /espacio de libres/ con el
   /stack/?

2. ¿Qué es la /fragmentación interna/? ¿Y la /fragmentación externa/?
   ¿En qué se parecen? ¿En qué se distinguen?

3. Tienes un sistema con 4MB de memoria, basado en particiones de
   memoria de tamaño variable. El sistema tiene cinco /agujeros/
   disponibles:

   1. 216KB a partir de los 192KB
   2. 1168KB a partir de los 704KB
   3. 384KB a partir de los 2640KB
   4. 96KB a partir de los 3280KB
   5. 208KB a partir de los 3888KB

   Indica cómo responderá a las siguientes solicitudes (ocurridas en
   el órden que te las presento) bajo los esquemas de primer ajuste,
   mejor ajuste y peor ajuste: 190KB, 64KB, 320KB, 720KB.

4. Un proceso en un sistema con arquitectura de memoria basada en la
   /segmentación/ tiene la siguiente tabla de segmentos:

    | Segmento | Inicio | Tamaño | Permisos |
    |----------+--------+--------+----------|
    |        0 |    240 |    600 | RX       |
    |        1 |   2300 |     16 | R        |
    |        2 |     90 |    100 | RW       |
    |        3 |   1320 |    950 | RW       |
    |        4 |      - |     96 | RX       |

   Para cada una de las siguientes solicitudes, indica qué dirección
   física correspondería, y –de ser el caso– qué excepción se
   generará.

   1. Lectura, 0-430
   2. Escritura, 0-150
   3. Lectura, 1,15
   4. Escritura, 2-130
   5. Ejecución, 4-25

5. La paginación fue concebida cuando las arquitecturas más comunes
   tenían espacios de direccionamiento de 16 bits. Este espacio de
   direccionamiento puede dividirse, por ejemplo, en 128 páginas de
   512 bytes cada una (7 bits indicando la página, 9 bits indicando el
   desplazamiento). Sin embargo, al pasar a los 32 bits, el espacio
   requerido crece considerablemente: Con el tamaño más habitual de
   páginas (4KB, 12 bits), requerimos de 1048576 entradas (20 bits) en
   la tabla de páginas — Y la tabla de páginas ocupa 5MB de memoria
   por proceso. Y al pasar a 64 bits, esta sobrecarga administrativa
   es muchísimo más grande aún.

   Describe un mecanismo que permita reducir el tamaño de la tabla de
   páginas.

6. El buffer de traducción adelantada (TLB) de un sistema en
   particular presenta una efectividad del 95%. Obtener un valor del
   TLB nos toma 10ns. La memoria principal tarda 120ns en recuperar un
   valor. ¿Cuál es el tiempo promedio para completar una operación a
   memoria?

7. Con la siguiente cadena de referencia, y empleando cuatro marcos de
   memoria física, desarrolla la asignación bajo los esquemas FIFO,
   OPT y LRU:
   #+BEGIN_QUOTE
   1, 3, 2, 1, 5, 3, 4, 1, 5, 2, 6, 7, 5, 7, 2, 5, 3, 5, 3, 1
   #+END_QUOTE
   Asumiendo que cada fallo de página toma 8 milisegundos en ser
   atendido, ¿cuál es la diferencia en rendimiento?
   # 1   4   5
   #  3   1   2
   #   2   6   3
   #    5   7   1
   #
   # 1      7 1
   #  3   2
   #   2 4 6 3
   #    5
   #
   # 1   7 1
   #  3   6 4 2
   #   5
   #    2    3

8. Un equipo está presentando rendimiento muy deficiente. Ante un
   análisis de utilización a lo largo de un día, encontramos que el
   promedio de uso de CPU está al 20% y el uso de la interfaz al disco
   duro que aloja a la memoria virtual al 95%. ¿En qué condición
   estamos?

   Elige de la siguiente lista las dos respuestas que /mayor impacto/
   tendrían para mejorar el rendimiento del sistema. Fundamenta con
   una breve explicación por qué elegiste a esas dos. En todos los
   casos, asume que la velocidad o capacidad nueva no variará en más
   de 30% sobre de la actual.

   1. Reemplazar al CPU por uno más rápido
   2. Instalar un disco más grande para la memoria virtual
   3. Aumentar el grado de multiprogramación
   4. Reducir el grado de multiprogramación
   5. Instalar más memoria principal
   6. Instalar un disco duro más rápido

9. Describe en qué consiste un ataque de /desbordamiento de pila/
   (/stack overflow/), y un mecanismo de protección del sistema para
   contrarrestarlos.

* Sistemas de archivos

1. Describe dos mecanismos por medio de los cuales el sistema de
   archivos puede identificar de qué tipo es determinado archivo.

2. Hay diferentes modos en que un programa puede accesar a la
   información contenida en un archivo; los principales modos que
   vimos en clase son /secuencial/, /aleatorio/ y /relativo a
   índice/. Indica qué casos de uso resuelve mejor cada uno de estos
   modos de acceso.

3. ¿Qué tipo de optimización podría llevar a cabo el sistema operativo
   si requiriera que todo programa declarara al momento de abrir un
   archivo si va a utilizarlo de forma mayormente secuencial o
   aleatoria?

4. De las siguientes afirmaciones, indica cuáles se refieren a /ligas
   duras/ (D), cuáles a /ligas simbólicas/ (S), y cuáles a /enlaces
   directos/ (E). Hay una sóla respuesta correcta para cada
   afirmación.
   1. Son dos (o más) entradas en el directorio apuntando al mismo
      i-nodo
   2. Es un archivo normal e independiente en el sistema de archivos,
      que podría ser abierto directamente por los programas
   3. Pueden apuntar a directorios, incluso creando ciclos
   4. Su tipo de archivo en el directorio está indicado por la
      extensión =.LNK=
   5. El sistema operativo /resuelve directamente/ todas las
      operaciones /como si fueran/ al archivo referido
   6. No pueden referirse a archivos en sistemas de archivos distintos
      del propio
   7. Pueden existir en un sistema de archivos tipo FAT
   8. Si un usuario elimina cualquiera de las referencias a un archivo
      empleando este esquema, el archivo sigue existiendo en las demás

5. Cuando hablamos acerca de los sistemas de archivos remotos o en
   red, ¿a qué nos referimos con la /semántica de manejo de errores/?
   Presenta un ejemplo de cómo se refleja una distinta semántica entre
   un sistema de archivos local y uno en red.

6. Estás diseñando un sistema de archivos basado en /asignación
   indexada/. Cada /cluster/ mide 4096 bytes, y el apuntador a un
   bloque requiere 32 bits (4 bytes). Dados los metadatos que vas a
   almacenar en el i-nodo del archivo, dentro del i-nodo principal
   puedes guardar 24 apuntadores directos, y estás considerando
   indirección sencilla y doble.

   ¿Cuál es el tamaño máximo de archivo que podrá manejar este sistema
   de archivos?

7. El sistema de archivos /ReiserFS/ está basado en la /asignación
   indexada/, pero introduce un nuevo concepto que no vimos en clase:
   Las /colitas/. Los archivos muy pequeños, de hasta 4KB, pueden ser
   almacenados /directamente en el i-nodo/. Esto permite a ReiserFS
   ahorrar espacio en disco (se estima que logra una eficiencia hasta
   5% mayor que sistemas que no emplean esta técnica), y además reduce
   el tiempo requerido para recuperar estos archivos, dado que los
   datos están en el mismo i-nodo y no hace falta leer ningún bloque
   adicional.

   ReiserFS se popularizó alrededor del 2001, pero su desarrollo se ha
   detenido, y esta característica en particular no ha sido adoptada
   más que por unos pocos sistemas de archivos (UFS2 y BTRFS). ¿Qué
   problemas podrías encontrar con el planteaiento de las /colitas/?

8. Describe el funcionamiento de un /sistema de archivos con bitácora/
   (/journaling file system/). ¿Cómo nos asegura que el sistema se
   mantendrá consistente después de una interrupción abrupta?

9. Presentamos algunos algoritmos para gestionar las solicitudes de
   acceso a disco — /Primero llegado, primero servido/ (FIFO), /Tiempo
   más corto a continuación/ (SSTF), /Elevador/ (SCAN), y algunas de
   sus variaciones. Mencionamos también que, a pesar de la importancia
   de conocerlos por su importancia histórica, hoy en día han dejado
   de ser tan importantes como lo fueron hacia los 1980. Menciona dos
   factores que han llevado a que pierdan relevancia.

10. Dibuja un esquema de cómo se estructura la información sobre varios
    discos bajo RAID niveles 0, 1 y 5. Para cada uno de estos niveles,
    indica el impacto que su empleo tendría en cuanto a espacio total,
    velocidad de acceso y confiabilidad.
