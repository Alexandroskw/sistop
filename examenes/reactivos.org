#+TITLE: Reactivos para exámenes y ejercicios
#+AUTHOR: Sistemas Operativos · Gunnar Wolf
#+OPTIONS: num:t toc:nil
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage[margin=2cm]{geometry}
#+LATEX_HEADER: \usepackage[spanish]{babel}
#+LANGUAGE: es

* Administración de procesos
** Conceptos de procesos e hilos
 1. ¿Qué diferencia hay entre un programa y un proceso?

 2. Un proceso puede estar en uno de los siguientes cinco
    estados. Describe brevemente cada a uno de ellos.
    - Nuevo:
    - Listo:
    - Bloqueado:
    - En ejecución:
    - Terminado:

 3. Dentro del /bloque de control del proceso/ (PCB) encontramos toda
    la información que, junto con su imagen en memoria, define e
    identifica a un proceso en particular. Describe qué información
    contienen:
    - Registros del CPU:
    - Información de contabilidad:
    - Contador del programa:

 4. Describe los tres principales patrones de trabajo para la
    /paralelización de la ejecución/ en varios hilos:
    - Jefe / trabajador:
    - Equipo de trabajo:
    - Línea de ensamblado:

** Sincronización
  1. Define brevemente los siguientes conceptos:
     - Concurrencia:
     - Operación atómica:
     - Condición de carrera:
     - Sección crítica:
     - Espera activa:

  2. Describe el funcionamiento (incluyendo las operaciones soportadas) de los /semáforos/

  3. Existen estrategias basadas en hardware para manejar la
     sincronización. Describe brevemente en lo que consisten las
     siguientes técnicas, y por qué no se encuentran en uso
     generalizado.

     2. Inhabilitación de interrupciones

     3. Memoria transaccional

  4. Vimos varios patrones de sincronización que emplean a los semáforos
     como mecanismo de comunicación. De ellos,

     1. ¿Cuándo se emplea un mutex? Muestra su implementación básica
       	entre dos hilos/procesos basada en semáforos.

     2. Explica cuál es la lógica y la utilidad del patrón /apagador/

     3. Menciona otros tres patrones

  5. Presenta en pseudocódigo la resolución del problema
     productores-consumidores. Menciona en qué puntos tuviste que
     emplear estructuras de sincronización, cuál estructura/patrón
     elegiste, y por qué.

     El planteamiento base es:
     - Un grupo de procesos va /produciendo/ ciertas estructuras
     - Otro grupo va /consumiéndolas/
     - Emplean un buffer de acceso compartido para comunicarse dichas
       estructuras
     - ¿Cómo pueden asegurar que no corromperán el buffer al haber
       accesos simultáneos?
     - ¿Cómo puedes evitar una /espera activa/ por parte del consumidor
       para encontrar cuándo hay elementos por procesar?

  6. ¿Cuál es la principal problemática ilustrado por el problema de la
     /cena de los filósofos/? Describe una de las estrategias que se
     presentaron para su resolución.

** Bloqueos mutuos y políticas
1. En clase vimos dos situaciones bastante similares de /bloqueos
   mutuos/ que se presentan en la vida real, fuera del ámbito del
   cómputo. Describe uno de estos ejemplos (o algún otro ejemplo que
   puedas citar que constituya un bloqueo mutuo), explicando por qué
   lo caracterizamos como objeto mutuo. /Tip/: Recuerda las cuatro
   /condiciones de Coffman/. Puedes describir por qué se cumple cada
   una de ellas (aunque sea "jalando" su definición al alejarla el
   entorno de los sistemas operativos).

2. Presenta, en prosa y a través de un esquema, la situación /clásica
   mínima/ de bloqueo mutuo. Detalla el órden de instrucciones que
   tienen que presentarse para que se dé el bloqueo.

3. Vimos tres categorías de estrategias ante los bloqueos
   mutuos. Describe en qué consisten, y cuáles son sus principales
   ventajas o desventajas:

   - Prevención:

   - Evasión:

   - Detección y recuperación:

4. En el caso de políticas preventivas, ¿cómo se comportaría la
   situación /clásica mínima/ de bloqueo mutuo que describiste en el
   inciso 2 si el sistema implementa una política de:

   - Serialización

   - Asignación jerárquica (inventa y detalla la jerarquía que emplearás)

5. ¿Cuál es la lógica básica de operación del algoritmo del banquero?

6. En un sistema con 2 unidades de cinta y 3 impresoras, y partiendo
   de la siguiente situación, con el algoritmo del banquero:
   |         |  Impresoras |    Reclamo |  U. Cinta |  Reclamo |
   | Proceso | Asignadadas | Impresoras | Asignadas | U. Cinta |
   |---------+-------------+------------+-----------+----------|
   | A       |           1 |          3 |         0 |        1 |
   | B       |           1 |          2 |         0 |        2 |
   | C       |           1 |          1 |         1 |        2 |
   - ¿Estamos en un /estado seguro/?
   - ¿Qué solicitudes nos llevarían a otro /estado seguro/?
   - ¿Qué solicitudes nos llevarían a un /estado inseguro/?
   - Presenta una /secuencia segura/ de finalización.

7. Cuando un algoritmo de detección y recuperación detecta un bloqueo,
   /casi siempre/ va a terminar la ejecución de un proceso.
   - Dame dos criterios según los cuales podría elegir a cuál
     finalizar.
   - ¿Qué otra estrategia podría emplear, además de la de finalizar a
     los procesos involucrados? ¿Por qué es tan poco frecuente emplearla?

* Planificación de procesos

** Tipos de proceso
1. Describe los siguientes conceptos empleados para la medición
   relacionada con el planificador a corto plazo:
   - Tick:
   - Quantum:
   - Tiempo de respuesta ($T$):
   - Tiempo en espera ($E$):
   - Proporción de penalización ($P$):
   - Proporción de respuesta ($R$):
   - Valor de saturación ($\rho$):

2. En un sistema interactivo, los procesos típicamente están en
   ejecución un largo periodo de tiempo (entre minutos y días), sin
   embargo, en nuestros ejemplos manejamos casi siempre a los procesos
   interactivos como /procesos cortos/. ¿Por qué? ¿Cuál sería un
   ejemplo de /proceso largo/?

** Algoritmos de planificación
1. Asumiendo los siguientes procesos:
   | Proceso | Llegada | $t$ |
   |---------+---------+-----|
   | A       | 0       | 7   |
   | B       | 2       | 15  |
   | C       | 3       | 2   |
   | D       | 4       | 6   |
   | E       | 6       | 8   |
   | F       | 6       | 3   |
   Presenta la representación gráfica de cómo el despachador les
   asignaría el CPU, y la tabla de análisis, bajo:
   - Ronda con $q=1$
   - Ronda con $q=3$
   - Proceso más corto a continuación
   - Retroalimentación multinivel con $q=1$, $n=1$ y $Q=nq$


2. ¿Qué algoritmos de los estudiadios son más susceptibles a la
   inanición que se presenta cuando $\rho > 1$? ¿Cuáles menos?
   Menciona por lo menos dos y dos.

3. Describe dos de los esquemas híbridos de planificación presentados.

4. En su libro /Sistemas operativos: diseño e implementación/, Andrew
   Tannenbaum sugiere otro esquema de planificación: El de la
   /lotería/.

   En este esquema, cada proceso tiene un cierto número de /boletos/,
   y sl siguiente /quantum/ es asignado a través de la selección
   aleatoria de uno de los boletos disponibles. Un proceso de mayor
   prioridad tendrá más boletos, uno de menor prioridad tendrá
   menos.

   - ¿Cómo se compararía este método con los otros revisados en clase?
   - ¿Para qué tipo de carga es más apto? ¿Y menos apto?
   - ¿Qué tan susceptible resulta a producir inanición?
   - ¿Qué tan /justa/ sería su ejecución?
   - ¿Cómo lo emplearías si tuvieras procesos con necesidades de
     tiempo real?
   - ¿Se te ocurre algún punto adicional no mencionado en el
     planteamiento para que resulte mejor?

** Planificación de multiprocesadores
1. Tanto la afinidad a procesador como el balanceo de cargas son
   elementos importantes y deseables en todo planificador que se
   ejecute en un entorno multiprocesador. Sin embargo, afinidad y
   balanceo de cargas trabajan uno en contra del otro. ¿Por qué?
   ¿Cuándo debe predominar cada uno?

2. ¿Cuál sería el impacto de no contar con /afinidad dura/ en un
   sistema NUMA? (recuerda: Non-Uniform Memory Access, Acceso
   No-Uniforme a Memoria)

3. Si nuestro planificador maneja una sóla cola de procesos para todos
   los procesadores, ¿Cómo se ve afectado el balanceo de cargas? ¿La
   afinidad?

** Tiempo real

1. ¿Por qué un sistema operativo /de propósito general/ no puede
   ofrecer garantías /de tiempo real duro/ en una computadora
   /estándar/?
* Administración de memoria

1. Diagrama el acomodo del espacio en memoria de un proceso. ¿Qué
   diferencias principales y qué similitudes tienen la /sección de
   datos/ con el /espacio de libres/? ¿Y el /espacio de libres/ con el
   /stack/?

2. ¿Qué es la /fragmentación interna/? ¿Y la /fragmentación externa/?
   ¿En qué se parecen? ¿En qué se distinguen?

3. Tienes un sistema con 4MB de memoria, basado en particiones de
   memoria de tamaño variable. El sistema tiene cinco /agujeros/
   disponibles:

   1. 216KB a partir de los 192KB
   2. 1168KB a partir de los 704KB
   3. 384KB a partir de los 2640KB
   4. 96KB a partir de los 3280KB
   5. 208KB a partir de los 3888KB

   Indica cómo responderá a las siguientes solicitudes (ocurridas en
   el órden que te las presento) bajo los esquemas de primer ajuste,
   mejor ajuste y peor ajuste: 190KB, 64KB, 320KB, 720KB.

4. Un proceso en un sistema con arquitectura de memoria basada en la
   /segmentación/ tiene la siguiente tabla de segmentos:

    | Segmento | Inicio | Tamaño | Permisos |
    |----------+--------+--------+----------|
    |        0 |    240 |    600 | RX       |
    |        1 |   2300 |     16 | R        |
    |        2 |     90 |    100 | RW       |
    |        3 |   1320 |    950 | RW       |
    |        4 |      - |     96 | RX       |

   Para cada una de las siguientes solicitudes, indica qué dirección
   física correspondería, y –de ser el caso– qué excepción se
   generará.

   1. Lectura, 0-430
   2. Escritura, 0-150
   3. Lectura, 1,15
   4. Escritura, 2-130
   5. Ejecución, 4-25

5. La paginación fue concebida cuando las arquitecturas más comunes
   tenían espacios de direccionamiento de 16 bits. Este espacio de
   direccionamiento puede dividirse, por ejemplo, en 128 páginas de
   512 bytes cada una (7 bits indicando la página, 9 bits indicando el
   desplazamiento). Sin embargo, al pasar a los 32 bits, el espacio
   requerido crece considerablemente: Con el tamaño más habitual de
   páginas (4KB, 12 bits), requerimos de 1048576 entradas (20 bits) en
   la tabla de páginas — Y la tabla de páginas ocupa 5MB de memoria
   por proceso. Y al pasar a 64 bits, esta sobrecarga administrativa
   es muchísimo más grande aún.

   Describe un mecanismo que permita reducir el tamaño de la tabla de
   páginas.

6. El buffer de traducción adelantada (TLB) de un sistema en
   particular presenta una efectividad del 95%. Obtener un valor del
   TLB nos toma 10ns. La memoria principal tarda 120ns en recuperar un
   valor. ¿Cuál es el tiempo promedio para completar una operación a
   memoria?

7. Con la siguiente cadena de referencia, y empleando cuatro marcos de
   memoria física, desarrolla la asignación bajo los esquemas FIFO,
   OPT y LRU:
   #+BEGIN_QUOTE
   1, 3, 2, 1, 5, 3, 4, 1, 5, 2, 6, 7, 5, 7, 2, 5, 3, 5, 3, 1
   #+END_QUOTE
   Asumiendo que cada fallo de página toma 8 milisegundos en ser
   atendido, ¿cuál es la diferencia en rendimiento?
   # 1   4   5
   #  3   1   2
   #   2   6   3
   #    5   7   1
   #
   # 1      7 1
   #  3   2
   #   2 4 6 3
   #    5
   #
   # 1   7 1
   #  3   6 4 2
   #   5
   #    2    3

8. Un equipo está presentando rendimiento muy deficiente. Ante un
   análisis de utilización a lo largo de un día, encontramos que el
   promedio de uso de CPU está al 20% y el uso de la interfaz al disco
   duro que aloja a la memoria virtual al 95%. ¿En qué condición
   estamos?

   Elige de la siguiente lista las dos respuestas que /mayor impacto/
   tendrían para mejorar el rendimiento del sistema. Fundamenta con
   una breve explicación por qué elegiste a esas dos. En todos los
   casos, asume que la velocidad o capacidad nueva no variará en más
   de 30% sobre de la actual.

   1. Reemplazar al CPU por uno más rápido
   2. Instalar un disco más grande para la memoria virtual
   3. Aumentar el grado de multiprogramación
   4. Reducir el grado de multiprogramación
   5. Instalar más memoria principal
   6. Instalar un disco duro más rápido

9. Describe en qué consiste un ataque de /desbordamiento de pila/
   (/stack overflow/), y un mecanismo de protección del sistema para
   contrarrestarlos.

* Sistemas de archivos

1. Describe dos mecanismos por medio de los cuales el sistema de
   archivos puede identificar de qué tipo es determinado archivo.

2. Hay diferentes modos en que un programa puede accesar a la
   información contenida en un archivo; los principales modos que
   vimos en clase son /secuencial/, /aleatorio/ y /relativo a
   índice/. Indica qué casos de uso resuelve mejor cada uno de estos
   modos de acceso.

3. ¿Qué tipo de optimización podría llevar a cabo el sistema operativo
   si requiriera que todo programa declarara al momento de abrir un
   archivo si va a utilizarlo de forma mayormente secuencial o
   aleatoria?

4. De las siguientes afirmaciones, indica cuáles se refieren a /ligas
   duras/ (D), cuáles a /ligas simbólicas/ (S), y cuáles a /enlaces
   directos/ (E). Hay una sóla respuesta correcta para cada
   afirmación.
   1. Son dos (o más) entradas en el directorio apuntando al mismo
      i-nodo
   2. Es un archivo normal e independiente en el sistema de archivos,
      que podría ser abierto directamente por los programas
   3. Pueden apuntar a directorios, incluso creando ciclos
   4. Su tipo de archivo en el directorio está indicado por la
      extensión =.LNK=
   5. El sistema operativo /resuelve directamente/ todas las
      operaciones /como si fueran/ al archivo referido
   6. No pueden referirse a archivos en sistemas de archivos distintos
      del propio
   7. Pueden existir en un sistema de archivos tipo FAT
   8. Si un usuario elimina cualquiera de las referencias a un archivo
      empleando este esquema, el archivo sigue existiendo en las demás

5. Cuando hablamos acerca de los sistemas de archivos remotos o en
   red, ¿a qué nos referimos con la /semántica de manejo de errores/?
   Presenta un ejemplo de cómo se refleja una distinta semántica entre
   un sistema de archivos local y uno en red.

6. Estás diseñando un sistema de archivos basado en /asignación
   indexada/. Cada /cluster/ mide 4096 bytes, y el apuntador a un
   bloque requiere 32 bits (4 bytes). Dados los metadatos que vas a
   almacenar en el i-nodo del archivo, dentro del i-nodo principal
   puedes guardar 24 apuntadores directos, y estás considerando
   indirección sencilla y doble.

   ¿Cuál es el tamaño máximo de archivo que podrá manejar este sistema
   de archivos?

7. El sistema de archivos /ReiserFS/ está basado en la /asignación
   indexada/, pero introduce un nuevo concepto que no vimos en clase:
   Las /colitas/. Los archivos muy pequeños, de hasta 4KB, pueden ser
   almacenados /directamente en el i-nodo/. Esto permite a ReiserFS
   ahorrar espacio en disco (se estima que logra una eficiencia hasta
   5% mayor que sistemas que no emplean esta técnica), y además reduce
   el tiempo requerido para recuperar estos archivos, dado que los
   datos están en el mismo i-nodo y no hace falta leer ningún bloque
   adicional.

   ReiserFS se popularizó alrededor del 2001, pero su desarrollo se ha
   detenido, y esta característica en particular no ha sido adoptada
   más que por unos pocos sistemas de archivos (UFS2 y BTRFS). ¿Qué
   problemas podrías encontrar con el planteaiento de las /colitas/?

8. Describe el funcionamiento de un /sistema de archivos con bitácora/
   (/journaling file system/). ¿Cómo nos asegura que el sistema se
   mantendrá consistente después de una interrupción abrupta?

9. Presentamos algunos algoritmos para gestionar las solicitudes de
   acceso a disco — /Primero llegado, primero servido/ (FIFO), /Tiempo
   más corto a continuación/ (SSTF), /Elevador/ (SCAN), y algunas de
   sus variaciones. Mencionamos también que, a pesar de la importancia
   de conocerlos por su importancia histórica, hoy en día han dejado
   de ser tan importantes como lo fueron hacia los 1980. Menciona dos
   factores que han llevado a que pierdan relevancia.

10. Dibuja un esquema de cómo se estructura la información sobre varios
    discos bajo RAID niveles 0, 1 y 5. Para cada uno de estos niveles,
    indica el impacto que su empleo tendría en cuanto a espacio total,
    velocidad de acceso y confiabilidad.
