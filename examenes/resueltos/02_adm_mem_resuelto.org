#+TITLE: Examen parcial 2: Administración de memoria
#+AUTHOR: Sistemas Operativos (Grupo 1 – Gunnar Wolf)
#+DATE: 2013-04-19
#+OPTIONS: num:t toc:nil
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage[margin=2cm]{geometry}
#+LATEX_HEADER: \usepackage[spanish]{babel}
#+LANGUAGE: es

1. ¿Qué son, en qué se parecen y en qué se diferencian la
   /fragmentación interna/ y la /fragmentación externa/?

   *Respuesta:*

   La /fragmentación interna/ es el espacio que se pierde dentro del
   espacio de memoria asignado a cada proceso, dentro del espacio que
   tiene asignado, puede ser por haber tenido que pedir más memoria de
   la que va a usar el proceso en determinado momento, o por tenerse
   que alinear al tamaño del bloque. La /fragmentación externa/ es el
   espacio que se pierde entre los distintos bloques de memoria
   asignados.

   Su principal similitud es que ambos llevan a que parte de la
   memoria resulte desperdiciada (en el primer caso, dentro del
   espacio de los procesos, y en el segundo, dentro del total
   disponible al sistema operativo). Si bien la fragmentación interna
   es casi imposible de evitar, la fragmentación externa puede
   combatirse /compactando/ las regiones asignadas (moviendo a los
   procesos para reducir la cantidad de espacios entre regiones), o
   por medio de la paginación, que la resuelve por completo.

2. Tienes un sistema con 4MB de memoria, basado en particiones de
   memoria de tamaño variable. El sistema tiene cinco /agujeros/
   disponibles:

   1. 216KB a partir de los 192KB
   2. 1168KB a partir de los 704KB
   3. 384KB a partir de los 2640KB
   4. 96KB a partir de los 3280KB
   5. 208KB a partir de los 3888KB

   Indica cómo responderá a las siguientes solicitudes (ocurridas en
   el órden que te las presento) bajo los esquemas de primer ajuste,
   mejor ajuste y peor ajuste: 190KB, 64KB, 320KB, 720KB.

   *Respuesta:*

   /Primer ajuste/:
   - 190K en el bloque 1 (queda de 26K)
   - 64K en el bloque 2 (queda de 1104K)
   - 320K en el bloque 2 (queda de 784K)
   - 720K en el bloque 2 (queda de 64K)

   /Mejor ajuste/:
   - 190K en el bloque 5 (queda de 18K)
   - 64K en el bloque 4 (queda de 32K)
   - 320K en el bloque 3 (queda de 64K)
   - 720K en el bloque 2 (queda de 448K)

   /Peor ajuste/:
   - 190K en el bloque 2 (queda de 978K)
   - 64K en el bloque 2 (queda de 914K)
   - 320K en el bloque 2 (queda de 594K)
   - 720K no puede ser satisfecho, se hace necesario compactar.

3. Un proceso en un sistema con arquitectura de memoria basada en la
   /segmentación/ tiene la siguiente tabla de segmentos:

    | Segmento | Inicio | Tamaño | Permisos |
    |----------+--------+--------+----------|
    |        0 |    240 |    600 | RX       |
    |        1 |   2300 |     16 | R        |
    |        2 |     90 |    100 | RW       |
    |        3 |   1320 |    950 | RW       |
    |        4 |      - |     96 | RX       |

   Para cada una de las siguientes solicitudes, indica qué dirección
   física correspondería, y –de ser el caso– qué excepción se
   generará.

   1. Lectura, 0-430
   2. Escritura, 0-150
   3. Lectura, 1,15
   4. Escritura, 2-130
   5. Ejecución, 4-25

   *Respuesta:*

   1. 640; OK
   2. Sería la dirección 390, pero genera una excepción por violación
      de permisos: El segmento 0 no permite la escritura.
   3. 2315; OK.
   4. Dirección inválida: El segmento mide sólo 100 bytes, la
      dirección 130 no existe.
   5. El segmento no está en memoria activo (está intercambiado a
      disco). El sistema operativo debe leerlo y traerlo a
      memoria. Una vez que esté en memoria y reciba una dirección
      física de inicio (digamos, la 2100), podría entregar la 2125.

4. Un equipo está presentando rendimiento muy deficiente. Un análisis
   arroja que el promedio de uso de CPU está al 20% y el uso del disco
   duro al 95%. ¿En qué condición estamos?

   Elige de la siguiente lista las dos respuestas que /mayor impacto/
   tendrían para mejorar el rendimiento del sistema. Fundamenta con
   una breve explicación por qué elegiste a esas dos.

   1. Reemplazar al CPU por uno 30% más rápido
   2. Instalar un disco 30% más grande para la memoria virtual
   3. Aumentar el grado de multiprogramación en 25%
   4. Reducir el grado de multiprogramación en 25%
   5. Instalar más memoria principal (un 30% más)
   6. Instalar un disco duro un 20% más rápido

   *Respuesta:*

   La condición en que está el sistema es de /hiperpaginación/ (en
   inglés, /thrashing/). De las opciones presentadas, las más
   efectivas serían: Benéficas, 4, 5 y 6; prácticamente indiferentes,
   1, 2; dañina, 3 (y calificaré commo correctas a 4, 5 y 6, aunque
   el impacto de 6 sea relativamente menor)

   - /Reducir el grado de multiprogramación/ puede ser aplicado en el
     momento que sea necesario, puede ayudarnos a salur de una
     situación actual de hiperpaginación sin tener que dar de baja el
     sistema y esperar a que se presente nuevamente. Si detenemos a
     algunos de los procesos y controlamos que no compitan tanto por
     la memoria física, podremos continuar operando.
   - /Instalar más memoria principal/ brindaría espacio para que sea
     menos probable caer en esta situación. Si nuestro sistema
     presenta /crónicamente/ hiperpaginación, este puede ser el camino
     a seguir. Requiere, sí, un gasto, el tiempo de conseguirlo, y dar
     de baja temporalmente al sistema, aunque el problema disminuye a
     mediano/largo plazo.
   - /Instalar un disco duro más rápido/ ayuda, sin duda, dado que la
     demora se presenta precisamente por la velocidad del disco,
     millones de veces menor que la de la memoria. Presenta, sin
     embargo, las mismas desventajas que la anterior. Es una medida
     paliativa, y sólo va a evitar marginalmente que caigamos en
     hiperpaginación.
   - /Reemplazar al CPU por uno más rápido/ no tendrá mayor efecto,
     dado que el CPU está mayormente libre, a la espera de datos que
     tienen que venir del disco a la memoria física.
   - /Instalar un disco más grande para la memoria virtual/ no tendrá
     ningún efecto sensible, nada indica que nos falte espacio en
     disco.
   - /Aumentar el grado de multiprogramación/ sería dañino, pues
     correr un mayor número de procesos simultánteamente aumentaría la
     necesidad de uso de memoria física.

5. Describe en qué consiste un ataque de /desbordamiento de pila/
   (/stack overflow/), y un mecanismo de protección del sistema para
   contrarrestarlos.

   *Respuesta:*

   Cuando empleamos un buffer de tamaño definido y usamos
   (principalmente) operaciones de manejo de cadenas que no toman en
   cuenta límites en lenguajes que no hacen gestión automática de la
   memoria (no limitado a estos, pero podemos tener como ejemplo a C,
   C++, ensamblador), como las funciones =gets=, =sprintf=, =strcpy= o
   =strcat=, podemos /desbordar/ el límite de la variable y terminar
   sobreescribiendo alguna estructura, ya sea otra variable que exista
   en el mismo /marco de la pila/ (/stack frame/) o el apuntador de
   retorno (que indica a qué dirección debe volver el flujo al
   terminar la función actual, permitiendo al atacante modificar el
   flujo del programa, o incluso adueñarse de los permisos de
   ejecución con los cuales está corriendo.

   Los tres mecanismos de protección que vimos son:

   - Aleatorización de direcciones :: Agregar espacio arbitrario y
        aleatorio entre las partes del /marco de la pila/, para que
        el atacante no pueda "atinarle" al espacio de la la dirección
        de retorno, o que no pueda apuntar a un lugar que le resulte
        tan fácil de adueñarse

   - Canario :: Insertar un valor aleatorio, que el atacante no pueda
                conocer o predecir, y verificar antes de retornar de
                la función; si el atacante lo sobreescribió, abortar
                la ejecución del proceso.

   - Pila no ejecutable :: Usar los mecanismos de protección de
        memoria para marcar a la pila como no ejecutable, y de este
        modo evitar que el atacante inyecte código que le permita
        tomar el control del sistema.

   Aunque los tres mecanismos dificultan la tarea al atacante, ninguno
   de ellos es invulnerable, y hay métodos para burlarlos a todos. El
   único mecanismo suficiente de protección del código es que el
   programador sea consciente y cuide las consdieraciones de
   seguridad al escribir su código.
