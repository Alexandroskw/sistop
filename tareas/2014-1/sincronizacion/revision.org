#+title: Tarea: Sincronización
#+date: 5-12 de septiembre
#+options: toc: nil

Implementa hilos que controlen el siguiente sistema:

 - La cochera de casa es de portón de apertura automática
 - Una vez que la puerta comienza a abrir, tarda x tiempo en quedar
   abierta
 - Una vez que la puerta comienza a cerrar, tarda x tiempo en quedar
   cerrada
 - El coche toma cierto tiempo en entrar y salir. Particularmente si
   hay peatones o vehículos cruzando frente a la puerta, tienes que
   esperar a que terminen de pasar.
 - La batería del control está muy débil, por lo que cuando llegas
   tienes que pedirle a otro actor que abra y cierre por tí. Cuando te
   vas también necesitas esta ayuda.
 - Si el coche es golpeado por la puerta, se abolla y hay que llevarlo
   al taller. No quieres que eso ocurra.

Implementa un sistema que tome en cuenta las restricciones en cuestión. Para su calificación, importa que:

 - El problema se resuelva correctamente
 - El tiempo de espera sea razonable
 - El código sea válido y legal en tu lenguaje favorito
   - Puedes asumir que la semántica del control de hilos, señales y
     primitivas de sincronización es similar a la expuesta en clase,
     no hace falta implementar eso a detalle.

Puedes enviar tu código más de una vez si sientes que lo mejoras; el
que vale es el último.

Esta tarea pueden hacerla individualmente o en equipos de dos
personas; en caso de que elijan hacerlo así, les pido que /ambos/
suban el mismo archivo, y que /ambos/ indiquen quiénes son los
autores.

La tarea debe ser enviada a la hora de inicio de la próxima clase
(jueves 12 de septiembre). Recuerda que, si no la enviaste a tiempo,
puedes enviar tu tarea todavía por una semana más, con un máximo del
80% de calificación.

* Premisas de calificación
- Intento :: 50% (entregando código que busque resolver el problema,
             incluso si el planteamiento es incorrecto)

- Cubre el planteamiento :: 10% dependiendo de qué tan completa es la
     cobertura de las condiciones planteadas

- Identificación de componentes :: 10%

- Lógica correcta :: 10%

- Código funcional :: 10%

- Originalidad y elegancia :: 10%

* Comentarios

** David Álvarez

- *6*

- Cobertura incompleta: Cubre al conductor y al asistente, pero no
  contempla el tiempo de demora de puerta ni los peatones

- Se organiza en torno a semáforos, pero no hay flujo: No hay hilos,
  sólo están definidas las funciones.
  - Para intentar evaluar, modifico a:

    #+begin_src python
      import threading
      
      abran = threading.Semaphore(1)
      cierren= threading.Semaphore(1)
      
      def entrando():
        while True:
          entra()
          cierra_porton()
      
      def saliendo():
        while True:
          sal()
          cierra_porton()
      
      def entra():
        abran.acquire()
        print "Voy a meter el carro"
        abran.release()
      
      def sal():
        abran.acquiere()
        print "voy a sacar el carro"
        abran.release()
      
      def cierra_porton():
        cierren.acquire()
        cierren.release()
      
      threading.Thread(target=entrando, args=[]).start
      threading.Thread(target=saliendo, args=[]).start
      
    #+end_src

- No funcional:
  - Hay bloques no indentados
  - La sintaxis de los comentarios es errónea
  - Incluso con la versión modificada, los semáforos no están bien
    engranados: =abran= protege al tiempo en lo que se abre/cierra la
    puerta; no entiendo bien el rol del torniquete =cierren=.

** Abraham Bonilla y Héctor Canseco

- *8.5*

- Difícil de seguir
  - Mucho código autogenerado
  - Variables con nombre que no indica su función
- Compila exitosamente, pero no pude correrlo
- Inicia dos hilos, pero no encuentro primitivas de sincronización.
  - ¿Basado en variables de condición? (wait / notifyAll) ¿Qué lógica
    manejan?
  - No encuentro cómo Ayudante y Conductor se comunican los cambios de
    estado — No hay ninguna variable compartida
-----
- Revisada en clase, les hice ya los comentarios
- Requiere prácticas más limpias de programación: ¡Líneas como
  =if(var.getVar()==2&&var.getVar2()==1||var.getVar()==2&&var.getVar2()==0){=
  son garantía de no-mantenibilidad!
- Hay elementos que deberían manejarse por sincronización explícita y
  no lo hacen, llevando a condiciones de carrera (por ejemplo, la
  señalización respecto a la siguiente acción que lleva a que se
  bloquee después de imprimir «salio carro»


** Lisette Castro

- *5*
- Uso incorrecto de las estructuras presentadas
- Ejecución sin paralelismo ni sincronización de ningún tipo
- Dos esperas activas sin necesidad, debería usar =sleep()= (o
  =usleep()=)

** Antonio Cruz y Estefanía Delgadillo

- *10*
- Implementación copmleta, funcional
- Buen manejo de los semáforos (creo que podrían implementarlo con uno
  menos, no estoy seguro de que requiera a =torniquete=)
- Tres hilos: Implementa a los peatones que cruzan como un hilo aparte
  - Las personas pasando pueden llevar a inanición

** José Espinosa y Arturo López

- *7.5* (revisado a *9*)
- Semántica en Python: Varias llamadas a métodos no se efectúan por no
  incluir el =()=
- Indentación inconsistente
- Llama a =semaforo()=, no a =threading.Semaphore()=
- No la pude hacer ejecutar correctamente
- Punto de vista interesante: Los hilos son el conductor y los
  obstáculos
  - ¿Y el asistente? =pedir_ayuda(accion)= es llamado como función
    dede =automovil()=
  - Mutex innecesaario =ayudando=, sólo se usa en un punto
- Semáforos principales bien identificados:
  - =Vía_libre= (mutex para la banqueta)
  - =entrar_salir= (indicar cambio de estado entre =pedir_ayuda()= y
    =automovil()= — Una sola función en vez de una para abrir y otra
    para cerrar
- Algunos semáforos, creo, supérfluos
  - =puerta=, =ayudando=, =mutex= sólo se usan desde una ejecución
    lineal, no sincronizan/comunican
  - No me queda clara la función de =torniquete=, pero me preocupa la
    llamada de tantas funciones que se pueden bloquear al usarlo como
    mutex dentro de =pedir_ayuda=
-----
...Grrr, llevaba media hora escribiendo en EDUCAFI qué sí, qué no y
por qué, ilustrando con detalles... Y me caducó la sesión, y se comió
mi reporte :(

Pero a grandes rasgos, el programa opera casi-bien. Lo primero que me
llamó la atención es que, en varias ejecuciones, siempre pasaban
primero los 10 =obstaculo()s= y luego comenzaba a pasar el coche. Para
obligarlos a interactuar, agregué al código =from random import
random= y un =sleep(random())= tanto al inicio de =obstaculo()= como en
=main()= (en vez del =sleep(1)=).

*Casi* siempre me funcionó bien, pero una vez (supongo que porque el
=random()= en =main()= fue muy bajo) me dio:

#+BEGIN_SRC
   $ python /tmp/Tarea.py 
   Soy el auto y quiero entrar/salir 
   Obstaculo 2 pasando.
   Obstaculo 2 termine de pasar.
   Soy el auto y estoy pasando
   Obstaculo 8 pasando.
   Obstaculo 8 termine de pasar.
   Obstaculo 7 pasando.
   Obstaculo 7 termine de pasar.
   Obstaculo 10 pasando.
   Obstaculo 10 termine de pasar.
   Obstaculo 6 pasando.
   Obstaculo 6 termine de pasar.
   Obstaculo 5 pasando.
   Obstaculo 5 termine de pasar.
   Obstaculo 1 pasando.
   Obstaculo 1 termine de pasar.
   Obstaculo 9 pasando.
   Obstaculo 9 termine de pasar.
   Obstaculo 4 pasando.
   Obstaculo 4 termine de pasar.
   Obstaculo 3 pasando.
   Obstaculo 3 termine de pasar.
   Soy el auto y ya pase
   Soy el ayudante y abro la puerta
   Puerta abriendo/cerrando!
   Soy el ayudante y ya no veo obstaculos.
   Puerta termina de abrir/cerrar
   Soy el ayudante y le digo al auto que pase
   Soy el ayudante y cerrare la puerta
   Puerta abriendo/cerrando!
   Soy el ayudante y dejo pasar peatones
   Puerta termina de abrir/cerrar
#+END_SRC

Esto es, ¡atropellamos a 8, 7, 10, 6, 5, 1, 9, 4, 3 y además
destruimos la puerta! ¿Por qué? Porque el auto no espera /de forma
segura/ a que el =ayudante()= esté listo. Un =sleep()= no puede ser
usado para sincronización, tendría que haber una señalización
explícita.

Estuve jugando un poco acerca de convertir el programa de una sola
pasada en uno que pase continuamente, y me encontré con un manejo
incorrecto de =entrar_salir= en =ayudante()=: Hay dos =acquire()= y un
=release()= (y en =main()= hay uno y uno), con lo que se vuelve
imposible que vuelva a ejecutarse. Envolví a =ayudante()= completo en
un =while True:=, y le agregué un =entrar_salir.release()= antes del
=pass=. Tuve un par de comportamientos bastante extraños (que se
perdieron en el historial), pero a fin de cuentas quedó funcionando
bonito — y eterno :)

¡Ah! Y otra cosa que encontré: Si =ayudante()= es ejecutado
eternamente pero =main()= no, éste no espera a ninguna solicitud por
parte del conductor: Se queda abriendo y cerrando la puerta para
siempre. Nuevamente, =main()= tendría que notificar a =ayudante()=
para que comenzara a trabajar.



** Eduardo Flores
- *7*
- Las variables =mutex= y =señal= tienen nombres no descriptivos de su
  función verdadera (p.ej. ambas son usadas para señalizar únicamente)
- Envía correctamente la señal de haber llegado, pero nunca vuelve a
  salir — Planteamiento incompleto
- No contempla a los peatones

** Luis González
- *7*
- Interesante: Planteamiento con =fork()= y en C
- Probable problema de implementación: Al basarse en procesos y no
  hilos, =i= no es una variable compartida (sólo los semáforos)
  - Además de compartirse =i=, tendría que protegerse su modificación
    con un mutex
- ¿Por qué cierras los semáforos 2 y 3 antes de usarlos, antes del
  =fork()=?
- Me parece que el programa inicia directo a un bloqueo mutuo: Dos
  hijos esperan a =sem_1= y a =sem_3= (semáforos inicializados a 1 y 0
  respectivamente), y sólo esos dos procesos lo señalizan posteriormente.

** Luis Meléndez
- *6.5*
- No considera a los peatones.
- Al correr como hilos concurrentes a =carro_entra= y =carro_sale=, y
  a =cochera_abre= y =cochera_cierra=, ¿no es necesario sincronizar
  entre los pares? ¿No podría llevarse a una situación en que la
  puerta esté abriendo y cerrando a la vez? ¿Cuál es el resultado?
- El ciclo =for= está dentro de =cochera_abre= y =cochera_cierra=,
  pero tu lógica abre la puerta 10 veces seguidas tras la única señal
  recibida
- Al inicializar ambos semáforos a 0, garantizas que el programa nunca
  va iniciar (tienes bloqueo mutuo de entrada)

** Roy Pacheco
- *10*
- Buena implementación en Java, empleando métodos síncronos
  (=synchronized=), y no semáforos
- Duda: ¿No deberían marcarse también como síncronas =abrirPuerta()= y
  =cerrarPuerta()=? (modifican =this.porton=)
- Si =coche= y/o =porton= fueran =boolean= en vez de =int=, podrían
  hacerse /trucos/ que redujeran la repetición de código, como por
  ejemplo, reemplazar =meterCoche()= y =sacarCoche()= por:
  #+begin_src java
  public synchronized void meter_sacar_coche() {
    abrirPuerta();
    while (checarPeatones()==1) {
      System.out.println("No podemos cambiar el estado del coche: Hay gente");
    }
    coche = !coche
    imprimirEstado();
    cerrarPuerta();
    notifyAll();
  }
  #+end_src
  Claro, esto asumiría un único coche (tu implementación asume varios)
- Distribución de roles curiosa: El hilo =cochera= representa a la
  cochera /y/ a los asistentes, y los conductores son diferentes para
  salir (=persona2=) y para volver (=persona1=)

** Viridiana Vázquez
- *8.5*
- Deja varios puntos indicados
  - Falta el desarrollo de las funciones asistentes, =abreOcierra()=,
    =cruzanCalle()=, =entraOsale()=
  - Falta el iniciador de los hilos
  - Pero en líneas generales, muestra el punto medular solicitado: La
    sincronización
- Buena implementación, con un /apagador/ permitiendo que los
  =obstaculos= sean actores independientes (y más de uno)
  - Sin embargo, dos hilos =personas()= se van a quedar esperando
    mutuamente, dado que ambos tienen que adquirir =pasolibre=
  - Podría obtenerse =pasolibre= de forma condicional, sólo si
    =obstaculos==0=, al igual que se hace al liberarlo
- ¿Deben las =personas()= poder liberar =señal=? Creo yo que debería
  ser únicamente para la comunicación entre =carro()= y =controlpuerta()=

** Violeta Castillo
- *5* → *4*
  - Calificado sobre 80% (extemporáneo)
- Un sólo hilo, no hay verdadera sincronización / concurrencia
- Inicializa con un semáforo =puerta=, pero no lo usa
- =run()= es una sola función, lineal, que no implementa la lógica
  necesaria para el problema planteado
** Erick Osorio, Isaac Martínez Miguel
- *9* → *7.2*
  - Calificado sobre 80% por envío extemporáneo
- Enfoque bastante distinto de todos los demás que vi: Tu modelado
  responde más bien a dos autos: El que está adentro sale, y el que
  está afuera entra
- El asistente lo manejas como una función llamada por el auto en
  cuestión — No es incorrecto (sólo es diferente), aunque reduce mucho
  la interacción en cuestión de señalización que esperaba que ustedes
  modelaran
- Tu código no mantiene hasta done puedo ver estado: Asumes una
  cochera infinitamente profunda (pueden entrar cualquier número de
  coches si suspendiéramos al hilo =coche_sale=) e infinitamente surtida
  (igual, puede salir cualquier número de coches si bloqueamos a
  =coche_entra=).
- Es más: Si modifico =coche_sale()= y =coche_entra()= para que estén
  en un =while(1)= en vez de llegar a =pthread_exit(0)=, como quedan
  tan cerca el =pthread_mutex_unlock= del =pthread_mutex_lock=, el
  mismo hilo vuelve a correr (causando inanición en el otro y
  presentando un comportamiento infinito como el que te predije:
  #+BEGIN_SRC
    Abriendo puerta
    Puerta abierta
    Auto saliendo
    Auto afuera
    Cerrando puerta
    Puerta cerrada
    Abriendo puerta
    Puerta abierta
    Auto saliendo
    Auto afuera
    Cerrando puerta
    Puerta cerrada
    Abriendo puerta
    Puerta abierta
    Auto saliendo
    Auto afuera
    (...)
  #+END_SRC

