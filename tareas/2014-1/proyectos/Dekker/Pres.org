#+LaTeX_CLASS: beamer
#+MACRO: BEAMERMODE presentation
#+MACRO: BEAMERTHEME Warsaw
#+MACRO: BEAMERCOLORTHEME lily
#+MACRO: BEAMERINSTITUTE Facultad de Ingeniería

#+TITLE: Algoritmo de Dekker
#+AUTHOR: Arturo López - José Espinosa
#+DATE: Thu 5-08-2013



* Introducción
** Historia (1)
#+latex: \begin{columns}\begin{column}{0.5\textwidth}
- El algoritmo de Dekker es un algoritmo propuesto por Edgser W. Dijkstra en 1965.
- Es el primer algoritmo que soluciona correctamente el problema del doble acceso en la programación concurrente.
#+latex: \end{column} \begin{column}{0.5\textwidth}
#+caption: Edgser W. Dijkstra
#+attr_latex: width=0.6\textwidth
[[./dijkstra.jpg]]
#+latex: \end{column} \end{columns} 

** Historia (2)
- A grandes razgos permite a dos hilos/procesos compartir un recurso sin conflicto alguno, utilizando para ello memoria compartida.
   

* Algoritmo de Dekker (Versión 1)
** Funcionamiento (de la primera versión)
- Si dos procesos intentan entrar a una sección crítica al mismo tiempo, el algoritmo unicamente le permitirá el acceso a uno dependiendo del turno correspondiente.
- Se basa en espera activa (consume muchos recursos).
- Utiliza una variable compartida para asignar turnos de acceso.
- Unicamente se pueden ejecutar procesos/hilos en un orden determinado.
 - Gracias a esto tenemos cierto determinismo.

** Algoritmo(1)
#+BEGIN_LaTeX
\begin{lstlisting}[language=c]
int turno; //Va a definir el turno

proceso1(){ //n-esimo proceso
  [Tareas iniciales]
  while(turno = 2); //Ciclo esperando su turno
  [seccion critica]
  turno = 2 //Se le cede el turno a otro proceso
  [Tareas finales no criticas]
  }
}
\end{lstlisting}
#+END_LaTeX

** Algoritmo(2)
#+BEGIN_LaTeX
\begin{lstlisting}[language = c]
main(){
  paralelizar{
    proceso1()
    proceso2()
  }
}
\end{lstlisting}
#+END_LaTeX

** Ejemplo en c (Proceso 1)
#+BEGIN_SRC language=c
#include<stdio.h> 
#include<pthread.h> 
int turno , saldo;

void *proc1(void *id){ //Suma dos al saldo
  while(saldo < 100){
    while(turno == 2);
      printf("\nSaldo en 1 = %d",saldo);
      saldo += 2;
      turno = 2;
      nanosleep((struct timespec[])
                        {{0, 500000}}, NULL);
  }return NULL;}
#+END_SRC

** Ejemplo en c (Proceso 2)
#+BEGIN_LaTeX
\begin{lstlisting}[language=c]
void proc2(void *id){ //Resta 1 al saldo
  while(saldo < 100){
    while(turno == 1);
    printf("\nSaldo en 2 = %d", saldo);
    saldo -= 1;
    turno = 1;
    nanosleep((struct timespec[])
                      {{0, 500000}}, NULL); 
  }
  return NULL;
}
\end{lstlisting}
#+END_LaTeX

** Ejemplo en C (main 1)
#+BEGIN_LaTeX
\begin{lstlisting}[language=c]
void main(){
  pthread_t t1, t2;

  turno = 1;
  saldo = 13;
  
  //Creamos nuevos hilos
  pthread_create(&t1, NULL, proc1, NULL);
  pthread_create(&t2, NULL, proc2, NULL);
  
  //Se espera a terminar cada proceso, de lo
  //contrario llega al fin del main y sale.
  pthread_join(t1, NULL);
  pthread_join(t2, NULL);
\end{lstlisting}
#+END_LaTeX

** Ejemplo en C (main 2)
#+BEGIN_LaTeX
\begin{lstlisting}[language=c]
  printf("\n-----------------------\n\
             Saldo al terminar los dos procesos: 
                               %d\n\n", saldo);
}
\end{lstlisting}
#+END_LaTeX

#** Muestra de la ejecución (Ojala se pueda correr
#el programa)

** Ejemplo en Python (Proceso 1)
#+BEGIN_LaTeX
\begin{lstlisting}[language=python]
from threading import Thread 

lista = []
turno = 1 

def proceso1():
    global turno, lista;
    while (len(lista) < 20):
        while (turno == 2): pass
        lista.append(1)#agrega elemento
        turno = 2
    pass
\end{lstlisting}
#+END_LaTeX
** Ejemplo en Python (Proceso 2)
#+BEGIN_LaTeX
\begin{lstlisting}[language=python]
def proceso2():
    global turno, lista;
    while(len(lista) < 20):
        while(turno==1): pass
        lista.append(2)#Agrega elemento
        turno = 1
    pass
\end{lstlisting}
#+END_LaTeX
** Ejemplo en Python (main)
#+BEGIN_LaTeX
\begin{lstlisting}[language=python]
def main():
    global lista
    t1 = Thread(target=proceso1)
    t2 = Thread(target=proceso2)
    t1.start(); t2.start()
    t2.join(); t2.join()

    print lista
    pass
\end{lstlisting}
#+END_LaTeX



* Algoritmo de Dekker (Versión 2)
** Versión 2 - Algoritmo
#+BEGIN_SRC language=C
boolean p1_puede_entrar, p2_puede_entrar;
Proceso1()
while( true )
{
  @[REALIZA_TAREAS_INICIALES]@
  @p1_puede_entrar = true;@
  while( p2_puede_entrar ){}
  [SECCION_CRITICA]
  @p1_puede_entrar = false;@
  [REALIZA_TAREAS_FINALES]
 }
}
#+END_SRC** Funcionamiento de la segunda versión


* Algoritmo de Dekker (Versión 3)
** Versión 3 - Algoritmo  (Parte 1)
#+BEGIN_SRC language=c
boolean p1_esta_dentro, p2_esta_dentro; 
Proceso1()
{
 while( true )
 {
  [REALIZA_TAREAS_INICIALES]
  @while( p2_esta_dentro ){}@
  @p1_esta_dentro = true;@
  [SECCIÓN_CRITICA]
  @p1_esta_dentro = false;@
  [REALIZA_TAREAS_FINALES]
 }
}
#+END_SRC
** Versión 3 - Algoritmo  (Parte 2)
#+BEGIN_SRC language=c
Proceso2()
{
 while( true )
 {
  [REALIZA_TAREAS_INICIALES]
  @while( p1_esta_dentro ){}@
  @p2_esta_dentro = true;@
  [SECCIÓN_CRITICA]
  @p2_esta_dentro = false;@
  [REALIZA_TAREAS_FINALES]
 }
}
#+END_SRC 
** Versión 3 - Algoritmo  (Parte 3)
#+BEGIN_SRC language=c
iniciar()
{
 p1_esta_dentro = false;
 p2_esta_dentro = false;
 Proceso1();
 Proceso2();
}

#+END_SRC

   
* Algoritmo de Dekker (Versión 4)
** Versión 4 - Algoritmo (Parte 1)
#+BEGIN_SRC language=c
boolean p1_puede_entrar, p2_puede_entrar;
Proceso1(){
 while( true ){
  [REALIZA_TAREAS_INICIALES]
  p1_puede_entrar = true;
  @while( p2_puede_entrar )@{
   p1_puede_entrar = false;
   @retardo( tiempo_x ); //tiempo_x es  aleatorio@
   p1_puede_entrar = true;
  }
  [SECCION_CRITICA]
  @p1_puede_entrar = false;@
  [REALIZA_TAREAS_FINALES]
 }
}
#+END_SRC
** Versión 4 - Algoritmo (Parte 2)
#+BEGIN_SRC language=c
Proceso2(){
 while( true ){
  [REALIZA_TAREAS_INICIALES]
  p2_puede_entrar = true;
  @while( p1_puede_entrar )@{
   p2_puede_entrar = false;
   @retardo( tiempo_x ); //tiempo_x es aleatorio@
   p2_puede_entrar = true;
   }
  [SECCION_CRITICA]
  @p2_puede_entrar = false;@
  [REALIZA_TAREAS_FINALES]
 }
}

#+END_SRC
** Versión 4 - Algoritmo (Parte 3)
#+BEGIN_SRC language=c
iniciar()
{
 p1_puede_entrar = false;
 p2_puede_entrar = false;
 Proceso1();
 Proceso2();
}
#+END_SRC


* Algoritmo de Dekker (Versión 5)
** Versión 5 - Algoritmo (Parte 1)
#+BEGIN_SRC language=c
boolean p1_puede_entrar, p2_puede_entrar;
int turno;
 
Proceso1(){
 while( true ){
  [REALIZA_TAREAS_INICIALES]
  p1_puede_entrar = true;
  while( p2_puede_entrar ){
   @if( turno == 2 ){
    p1_puede_entrar = false;
    @while( turno == 2 ){}@
    p1_puede_entrar = true;
   }
  }
#+END_SRC
** Versión 5 - Algoritmo (Parte 2)
#+BEGIN_SRC language=c
  [REGION_CRITICA]
  @turno = 2;@
  @p1_puede_entrar = false;@
  [REALIZA_TAREAS_FINALES]
 }
}
#+END_SRC
** Versión 5 - Algoritmo (Parte 3)
#+BEGIN_SRC language=C
Proceso2(){
 while( true ){
  [REALIZA_TAREAS_INICIALES]
  p2_puede_entrar = true;
  while( p1_puede_entrar ){
   @if( turno == 1 )@{
    p2_puede_entrar = false;
    @while( turno == 1 ){}@
    p2_puede_entrar = true;
   }
  }
#+END_SRC
** Versión 5 - Algoritmo (Parte 4)
#+BEGIN_SRC language=C
  [REGION_CRITICA]
  @turno = 1;@
  @p2_puede_entrar = false;@
  [REALIZA_TAREAS_FINALES]
 }
} 
#+END_SRC
** Versión 5 - Algoritmo (Parte 5)
#+BEGIN_SRC language=C
iniciar(){
 p1_puede_entrar = false;
 p2_puede_entrar = false;
 turno = 1;
 Proceso1();
 Proceso2();
}
#+END_SRC
