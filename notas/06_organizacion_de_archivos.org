#+SETUPFILE: ../setup_notas.org
#+TITLE: Archivos y directorios: Organización de archivos

* Introducción
#<<DIR>>

De los roles que cumple el sistema operativo, probablemente el que más
consciente tengan en general sus usuarios es el de la gestión del
espacio de almacenamiento, esto es, la organización de la información
en un /sistema de archivos/. Al día de
hoy, todos los usuarios de equipo de cómputo dan por sentado y
comprenden a grandes rasgos la organización del espacio de
almacenamiento en un /directorio jerárquico/, con unidades de
almacenamiento llamadas /archivos/, de diferentes tipos según su
función. En el presente capítulo se revisará la semántica que compone
a este modelo, para en el capítulo \ref{FS} continuar con los detalles de la
gestión del espacio físico donde éstos están alojados.

La abstracción que hoy conocemos como /sistemas de archivos/ es una de
las que más tiempo han vivido y se han mantenido a lo largo de la
historia de la computación, sobreviviendo a lo largo de prácticamente
todas las generaciones de sistemas operativos. Sin embargo, para poder
analizar cómo es que el sistema operativo representa la información en
el dispositivo físico, comenzaremos discutiendo cómo es que esta
información es comprendida por los niveles más altos — Por los
programas en espacio de usuario.

#+attr_latex: height=0.5\textheight
#+label: DIR_capas_acceso_a_discos
#+caption: Capas de abstracción para implementar los sistemas de archivos
[[./img/dot/capas_acceso_a_discos.png]]

La información /cruda/ tiene que pasar una serie de
transformaciones. Yendo de niveles superiores a niveles más bajos, un
programa estructura sus datos en /archivos/, siguiendo el /formato/
que resulte mas pertinente al tipo de información a representar. Un
conjunto de archivos hoy en día es típicamente representado en una
estructura de /directorios/, y aunque existen otros mecanismos para su
organización, estos no están tan ampliamente difundidos. Y cuando un
sistema opera con más de un dispositivo físico, encontraremos
principalmente dos mecanismos para integrar a dichos dispositivos en
un /sistema de archivos virtual/, brindnado al usuario una interfaz
uniforme. Por último, los archivos son una estructura meramente lógica;
deben ser convertidos para ser representados en un /dispositivo
orientado a bloques/ como los diversos tipos de unidades que conocemos
–aunque esta nomenclatura es a veces incorrecta– como /discos/. Este
último paso será abordado en el capítulo \ref{FS}.

Del diagrama presentado en la figura \ref{DIR_capas_acceso_a_discos},
toca al objeto de nuestro estudio –el sistema operativo– recibir del
espacio de usuario las llamadas al sistema que presentan la interfaz
de archivos y directorios, integrar el sistema de archivos virtual, y
traducir la información resultante a un sistema de archivos.

Cabe mencionar que varias de las capas aquí presentadas podrían
perfectamente ser subdivididas, analizadas por separado, e incluso
tratarse de forma completamente modular — De hecho, este es
precisamente el modo en que se implementan de forma transparente
características hoy en día tan comunes como sistemas de archivos en
red, o compresión y cifrado de la información. Una referencia más
detallada acerca de ventajas, desventajas, técnicas y mecanismos de la
división y comunicación entre capas puede ubicarse en el artículo de
[[https://dl.acm.org/citation.cfm?doid=174613.174616][Heidemann y Popek (1994)]].

* Concepto de archivo

En primer término, un archivo es un /tipo de datos abstracto/ — Esto
es,  podría verse como una estructura que
exclusivamente permite la manipulación por medio de una interfaz
/orientada a objetos/: Los procesos en el sistema sólo pueden tener
acceso a los archivos por medio de la interfaz ofrecida por el sistema
operativo.[fn:: Como se verá en la sección \ref{FS_volumenes_crudos}, esto no es /necesariamente/
así, sin embargo, el uso de los dispositivos /en crudo/ es tan bajo
que podemos ignorarlos para propósitos de esta discusión] La siguiente
sección describe las principales operaciones provistas por esta
interfaz.

Para el usuario, los archivos son la /unidad lógica mínima/ al hablar
de almacenamiento: Todo el almacenamiento /persistente/ (que sobrevive
en el tiempo, sea a reinicios del sistema, a pérdida de corriente o a
otras circunstancias en el transcurso normal de ejecución) en el
sistema al que tiene acceso, se efectúa dentro de archivos; el espacio
libre en los diferentes dispositivos no tiene mayor existencia fuera
de saber que está /potencialmente/ disponible.

Dentro de cada /volúmen/ (cada medio de almacenamiento), los archivos
disponibles conforman a un /directorio/, y son típicamente
identificados por un /nombre/ o una /ruta/. Hablaremos más adelante
acerca de las diferentes construcciones semánticas que pueden
conformar a los directorios.

** Operaciones con archivos
#<<DIR_operaciones_con_archivos>>

Cada sistema operativo definirá la interfaz de archivos acorde con su
semántica, pero en líneas generales, las operaciones que siempre
estarán disponibles con un archivo son:

- Crear :: Asigna espacio en el dispositivo y en su directorio para
           alojar a un nuevo archivo.

- Borrar :: Elimina al archivo del directorio y, de ser procedente,
            libera el espacio del dispositivo

- Abrir :: Solicita al sistema operativo verificar si tenemos el
           acceso para el /modo de acceso/ al archivo que indiquemos y
           si el medio lo soporta (por ejemplo, a pesar de contar con
           todos los permisos necesarios, el sistema operativo no debe
           permitir abrir para escritura un archivo en un CD-ROM u
           otro medio de sólo lectura).

	   Al abrir un archivo, el sistema operativo asigna un
           /descriptor de archivos/ que identifica la relación entre
           el proceso y el archivo en cuestión; estos serán definidos
           propiamente en la sección \ref{DIR_tablas_de_archivos}.

	   Todas las operaciones descritas a continuación operan sobre
           el descriptor de archivos, no con su nombre o ruta.

- Cerrar :: Indica al sistema que /el proceso en cuestión/ terminó de
            trabajar con el archivo; el sistema entonces debe vaciar
            los buffers a disco y eliminar la entrada que representa a
            esta combinación archivo-proceso de las tablas activas,
            invalidando al /descriptor de archivo/.

	    Dado que todas las operaciones se realizan a través del
            descriptor de archivo, si un proceso cierra un archivo y
            requiere seguir utilizándolo, tendrá que abrirlo de nuevo
            para obtener un nuevo descriptor.

- Leer :: Cuando indicamos al sistema que queremos leer de un archivo
          hacia determinado buffer, éste copia el siguiente /pedazo/
          de información a éste. Este /pedazo/ podría ser una línea o
          un bloque de longitud definida, dependiendo del modo en que
          se solicite la lectura. El sistema mantiene un apuntador a
          la última posición leída, para poder /continuar/ con la
          lectura.

- Escribir :: Teniendo un archivo ya existente, guarda información en
              él. Puede ser que escriba desde su primer posición
              (/truncando/ al archivo, esto es, borrando toda la
              información que pudiera ya tener), o /agregando/ al
              archivo, esto es, iniciando con el apuntador de
              escritura al final del mismo.

- Reposicionar :: (/seek/) Tanto la lectura como la escritura se hacen
                  siguiendo a un /apuntador/, que indica cuál fue la
                  última posición del archivo a la que accesó el
                  proceso actual. Al reposicionar el apuntador,
                  podemos /saltar/ a otro punto del archivo.

Hay varias otras operaciones comunes que pueden implementarse con
llamadas compuestas a estas operaciones (por ejemplo, /copiar/ un
archivo puede implementarse como /crear/ un archivo nuevo en modo de
escritura, abrir en modo de lectura al archivo fuente, e ir /leyendo/ de éste
y /escribiendo/ al nuevo hasta llegar al fin de archivo).

Las operaciones que presentamos recién no son /todas/ las operaciones
existentes; dependiendo del sistema operativo, habrá algunas
adicionales; estas las presentamos como la base general sobre la cual
trabajaremos.

Vale la pena mencionar que esta semántica para el manejo de archivos
presenta a cada archivo como si fuera una /unidad de cinta/,
permitiéndonos avanzar o retroceder la cabeza lectora/escritora dentro
de ella.

** Tablas de archivos abiertos
# <<DIR_tablas_de_archivos>>

Tanto el sistema operativo como cada uno de los procesos mantienen
normalmente /tablas de archivos abiertos/. Estas mantienen información
acerca de todos los archivos actualmente abiertos, presentándolos
hacia el proceso por medio de un /descriptor de archivo/; una vez que
un archivo fue abierto, las operaciones que se realizan dentro de éste
no son empleando su nombre, sino que su descriptor de archivo.

En un sistema operativo multitareas, más de un proceso podría abrir el
mismo archivo a la vez; lo que cada uno de ellos pueda hacer, y cómo
esto impacte a lo que vean los demás procesos, depende de la semántica
que implemente el sistema; un ejemplo de las diferentes semánticas
posibles es el descrito en la sección \ref{DIR_bloq_arch}.

Ahora, ¿por qué mencionamos que estas tablas son mantenidas tanto por
el sistema operativo como por cada uno de los procesos? ¿No nos lleva
esto a una situación en que mantenemos información redundante?

La respuesta es que la información que cada uno debe manejar es
distinta. El sistema operativo necesita:

- Conteo de usuarios del archivo :: Cuando se solicita, por ejemplo,
     /desmontar/ una partición (por ejemplo, para expulsar una unidad
     removible) o eliminar un archivo, el sistema debe poder
     determinar cuándo es momento de declarar la solicitud como
     /efectuada/. Si algún proceso tiene abierto a un archivo, y
     particularmente si tiene cambios pendientes de guardar, el
     sistema debe hacer lo posible por evitar que el archivo /desaparezca/ de su
     visión.
- Modos de acceso :: Aunque un usuario tenga permisos de acceso a
     determinado recurso, el sistema puede determinar negarlo si
     llevaría a una inconsistencia. Por ejemplo, si dos procesos abren
     un mismo archivo en modo de escritura, es probable que los
     cambios que realice uno sobreescriban a los que haga el otro.
- Ubicación en disco :: Para evitar que cada proceso tenga que
     consultar las tablas en disco para encontrar al archivo, o cada
     uno de sus fragmentos.
- Información de bloqueo :: En caso de que los modos de acceso del
     archivo requieran protección mutua, puede implementarse por
     medio de un bloqueo.

Por otro lado, el proceso necesita:

- Descriptor de archivo :: Relación entre el nombre del archivo
     abierto y el identificador numérico que maneja internamente el
     proceso. Un archivo abierto por varios procesos tendrá
     descriptores de archivo distintos en cada uno de ellos.

     A nivel implementación, el descriptor de archivo otorgado por el
     sistema a un proceso es simplemente un número entero, que podría
     entenderse como /el n-ésimo archivo empleado por el
     proceso/.[fn:: No sólo los archivos reciben descriptores de
     archivo. Por ejemplo, en todos los principales sistemas
     operativos, los descriptores 0, 1 y 2 están relacionados a
     /flujos de datos/: respectivamente, la entrada estándar
     (=STDIN=), la salida estándar (=STDOUT=) y el error estándar
     (=STDERR=).]

- Permisos :: Los modos válidos de acceso para un archivo. Esto no
              necesariamente es igual a los permisos que tiene el
              archivo en cuestión en disco, sino que el /subconjunto/
              de dichos permisos bajo los cuales está operando para
              este proceso en particular — Si un archivo fue abierto
              en modo de sólo lectura, por ejemplo, este campo
              sólo permitirá la lectura.

** Acceso concurrente: Bloqueo de archivos
# <<DIR_bloq_arch>

Dado que los archivos pueden emplearse como mecanismo de comunicación
entre procesos que no guarden relación entre sí, incluso a lo largo
del tiempo, y para emplear un archivo basta indicar su nombre o ruta,
los sistemas operativos multitarea implementan mecanismos de bloqueo
para evitar que varios procesos intentando emplear de forma
concurrente a un archivo se corrompan mutuamente.

Algunos sistemas operativos permiten establecer bloqueos sobre
determinadas regiones de los archivos, aunque la semántica más común
es operar sobre el archivo entero.

En general, la nomenclatura que se sigue para los bloqueos es:

- Compartido :: (/Shared lock/) Podría verse como equivalente a un
                bloqueo (o /candado/) para realizar lectura — Varios
                procesos pueden adquirir al mismo tiempo un bloqueo de
                lectura, e indica que todos los que posean dicho
                /candado/ tienen la expectativa de que el archivo no
                sufrirá modificaciones.
- Exclusivo :: (/Exclusive lock/) Un bloqueo o /candado/ exclusivo
               puede ser adquirido por un sólo proceso, e indica que
               realizará operaciones que modifiquen al archivo (o, si
               la semántica del sistema operativo permite expresarlo,
               a la /porción/ del archivo que indica).

Respecto al /mecanismo/ de bloqueo, hay también dos tipos,
dependiendo de qué tan explícito tiene que ser su manejo:

- Mandatorio u obligatorio :: (/Mandatory locking/) Una vez que un
     proceso adquiere un candado obligatorio, el sistema operativo se
     encargará de imponer las restricciones corresponidentes de acceso
     a todos los demás procesos, independientemente de si éstos fueron
     programados para considerar la existencia de dicho bloqueo o no.
- Consultivo o asesor :: (/Advisory locking/) Este tipo de bloqueos
     es manejado cooperativamente entre los procesos involucrados, y
     depende del programador de /cada uno/ de los programas en
     cuestión el solicitar y respetar dicho bloqueo.

Haciendo un paralelo con los mecanismos presentados en el capítulo
\ref{PROC}, los mecanismos que emplean
mutexes, semáforos o variables de condición serían /consultivos/, y
únicamente los que emplean monitores (en que la única manera de llegar
a la información es a través del mecanismo que la protege) serían
/mandatorios/.

No todos los sistemas operativos implementan las cuatro posibilidades
(compartido mandatorio, o compartido compulsivo, exclusivo mandatorio
y exclusivo consultivo). Como regla general,
en los sistemas Windows se maneja un esquema de bloqueo obligatorio, y
en sistemas Unix es de bloqueo consultivo.[fn:: Esto explica por qué
en Windows es tan común que el sistema mismo rechace hacer
determinada operación porque /el archivo está abierto por otro
programa/ (bloqueo mandatorio compartido), mientras que en Unix esta
responsabilidad recae en cada uno de los programas de aplicación]

Cabe mencionar que el manejo de bloqueos con archivos requiere del
mismo cuidado que el de bloqueo por recursos que el que vubierto en
la sección \ref{PROC_bloq_mutuos}: Dos procesos intentando adquirir un
candado exclusivo sobre dos archivos pueden caer en un bloqueo mutuo
tal como ocurre con cualquier otro recurso físico.

** Tipos de archivo

Si los archivos son, como dijimos, la /unidad lógica mínima/ con la
que se puede guardar información en almacenamiento secundario,
naturalmente sigue que existen archivos de diferentes tipos: Cada
archivo podría ser un documento de texto, un binario ejecutable, un
archivo de audio o video, o un larguísimo etcetera, e intentar emplear
a un archivo como uno de un tipo distinto puede resultar desde una
frustración al usuario porque el programa no responde como éste
quiere, hasta en pérdidas económicas.[fn:: Por ejemplo, imprimir un
archivo binario resulta en una gran cantidad de hojas inútiles,
particularmente tomando en cuenta que hay caracteres de control como
el ASCII 12 (avance de forma, /form feed/), que llevan a las
impresoras que operan en modo texto a iniciar una nueva página; llevar
a un usuario a correr un archivo ejecutable /disfrazado/ de un
documento inocuo, como veremos a continuación, fue un importante
vector de infección de muchos virus.]

Hay tres estrategias principales para que el sistema operativo
reconozca al tipo de un archivo:

- Extensión :: En los sistemas CP/M de los 1970, el nombre de cada
               archivo se dividía en dos porciones, empleando como
               elemento separador al punto: El nombre del archivo y su
               extensión. El sistema mantenía una lista de extensiones
               conocidas, para las cuales sabría cómo actuar, y este
               diseño se extendería a las aplicaciones, que sólo
               abrirían a aquellos archivos cuyas extensiones
               supieran manejar.

	       Esta estrategia fue heredada por VMS y MS-DOS, de
               donde la adoptó Windows; ya en el contexto de un
               entorno gráfico, Windows agrega, más allá de las
               extensiones directamente ejecutables, la relación de
               extensiones con los programas capaces de trabajar con
               ellas, permitiendo invocar a un programa con sólo dar
               ``doble click'' en un documento.

	       Como nota, este esquema de asociación de tipo de
               archivo permite ocultar las extensiones toda vez que ya
               no requieren ser del conocimiento del usuario, sino que
               son gestionadas por el sistema operativo, abre una vía
               de ataque automatizado que se popularizó en su momento:
               El envío de correos con extensiones engañosas
               duplicadas — Esto es, el programa maligno (un /programa
               troyano/) se envía a todos los contactos del usuario
               infectado, presentándose por ejemplo como una imágen,
               con el nombre =inocente.png.exe=. Por el esquema de
               ocultamiento mencionado, éste se presenta al usuario
               como =inocente.png=, pero al abrirlo, el sistema
               operativo lo reconoce como un ejecutable, y lo ejecuta
               en vez de abrirlo en un visor de imágenes.

- Números mágicos :: La alternativa que emplean los sistemas Unix es,
     como siempre, simple y /elegante/, aunque indudablemente presenta
     eventuales lagunas: El sistema mantiene una lista compilada de
     las /huellas digitales/ de los principales formatos que debe
     manejar,[fn:: Una de las ventajas de este esquema es que cada
     administrador de sistema puede ampliar la lista con las huellas
     digitales que requiera localmente] para reconocer el contenido
     de un archivo basado en sus primeros bytes.

     Casi todos los formatos de archivo incluyen lo necesario para que
     se lleve a cabo este reconocimiento, y cuando no es posible
     hacerlo, se intenta por medio de ciertas reglas /heurísticas/.
     Por ejemplo, todos los archivos de imágen en /formato de
     intercambio gráfico/ (GIF) inician con la cadena =GIF87a= o
     =GIF89a=, dependiendo de la versión; los archivos del lenguaje de
     descripción de páginas PostScript inician con la cadena =%!=, el
     /Formato de Documentos Portátiles/ (PDF) con =%PDF=, etcétera. Un
     documento en formatos definidos alrededor de XML inicia con
     =<!DOCTYPE=.  Algunos de estos formatos no están /anclados/ al
     inicio, sino que en un punto específico del primer bloque.

     Un caso especial de números mágicos es el llamado /hashbang/
     (=#!=). Esto indica a un sistema Unix que el archivo en cuestión
     (típicamente un archivo de texto, incluyendo código fuente en
     algún lenguaje de /script/) debe tratarse como un ejecutable, y
     empleando como /intérprete/ al comando indicado inmediatamente
     después del /hashbang/. Es por esto que podemos ejecutar
     directamente, por ejemplo, los archivos que inician con
     =#!/usr/bin/bash=: El sistema operativo invoca al programa
     =/usr/bin/bash=, y le especifica como argumento al archivo en
     cuestión.

- Metadatos externos :: Los sistemas de archivos empleado por las
     Apple Macintosh desde 1984 separan en dos /divisiones/ (/forks/)
     la información de un archivo: Los datos que propiamente
     constituyen al archivo en cuestión son la /división de datos/
     (/data fork/), y la información /acerca del archivo/ se guardan
     en una estructura independiente llamada /división de recursos/
     (/resource fork/).

     Esta idea resultó fundamental para varias de las características
     /amigables al usuario/ que presentó Macintosh desde su
     introducción — Particularmente, para presentar un entorno gráfico
     que respondiera ágilmente, sin tener que buscar los datos base de
     una aplicación dentro de un archivo de mucho mayor tamaño. La
     /división de recursos/ cabe en pocos sectores de disco, y si
     tomamos en cuenta que las primeras Macintosh funcionaban
     únicamente con discos flexibles, el tiempo invertido en leer una
     lista de iconos podría ser demasiada.

     La división de recursos puede contener todo tipo de
     información; los programas ejecutables son los que le dan un
     mayor uso, dado que incluyen desde los aspectos gráficos (icono
     a mostrar para el archivo, ubicación de la ventana a ser
     abierta, etc.) hasta aspectos funcionales, como la traducción de
     sus cadenas al lenguaje particular del sistema en que está
     instalado. Esta división permite una gran flexibilidad, dado que
     no es necesario tener acceso al fuente del programa para crear
     traducciones y temas.

     En el tema particular que en esta sección nos concierne, la
     división de recursos incluye un campo llamado /creador/, que indica
     cuál programa fue el que generó al archivo. Si el usuario solicita
     ejecutar un archivo de datos, el sistema operativo lanzaría al
     programa /creador/, indicándole que abra al archivo en cuestión.

     Las versiones actuales de MacOS ya no emplean esta técnica, sino
     que una llamada /appDirectory/, para propósitos de esta
     discusión, la técnica base es la misma.

** Estructura de los archivos y métodos de acceso
# <<DIR_archivos_estructurados>>
La razón principal de la existencia del sistema de archivos son /los
archivos/. Un archivo almacena información de /algún tipo/,
estructurado o no estructurado.

La mayor parte de los sistemas operativos maneja únicamente archivos
/sin estructura/ — Cada aplicación es responsable de preparar la
información de forma congruente, y la responsabilidad del sistema
operativo es únicamente entregarlo como un conjunto de
bytes. Históricamente, hubo sistemas operativos, como IBM CICS (1968), IBM MVS
(1974) o DEC VMS (1977), que administraban ciertos tipos de datos en
un formato básico de /base de datos/.

El que el sistema operativo no imponga estructura a un archivo no
significa, claro está, que la aplicación que lo genera no lo haga. La
razón por la que los sistemas creados en los últimos 30 años no han
implementado este esquema de base de datos es que le /resta/
flexibilidad al sistema: El que una aplicación tuviera que ceñirse a
los tipos de datos y alineación de campos del sistema operativo
impedía su adecuación, y el que la funcionalidad de un archivo tipo
base de datos dependiera de la versión del sistema operativo creaba
un /acoplamiento/ demasiado rígido entre el sistema operativo y las
aplicaciones.

Esta práctica ha ido cediendo terreno a dejar esta responsabilidad en
manos de procesos independientes en espacio de usuario (como sería un
gestor de bases de datos tradicional), o de bibliotecas que ofrezcan
la funcionalidad de manejo de archivos estructurados (como en el caso
de /SQLite/, empleado tanto por herramientas de adquisición de datos
de bajo nivel como /systemtap/ como por herramientas tan de escritorio
como el gestor de fotografías /shotwell/ o el navegador /Firefox/).

Podemos ver aún un remanente de los archivos estructurados en los
sistemas derivados de MS-DOS: En estos sistemas, un archivo puede ser
/de texto/ o /binario/. Un archivo de texto está compuesto por una
serie de caracteres que forman /líneas/, y la separación entre una
línea y otra constituye de un /retorno de carro/ (=CR=, caracter
ASCII 13) seguido de un /salto de línea/ (=LF=, caracter ASCII
10).[fn:: Esta lógica es herencia de las máquinas de escribir
manuales, en que el /salto de línea/ (avanzar el rodillo a la línea
siguiente) era una operación distinta a la del /retorno de carro/
(devolver la cabeza de escritura al inicio de la línea). En la época
de los teletipos, como medida para evitar que se perdieran caracteres
mientras la cabeza volvía hasta la izquierda, se decidió separar el
inicio de nueva línea en los dos pasos que tienen las máquinas de
escribir, para inducir una demora que evitara la pérdida de
información.]

El acceso a los archivos puede realizarse de diferentes maneras:

- Acceso secuencial :: Mantiene la semántica por medio de la cual
     permite leer de nuestros archivos de forma equivalente a
     unidad de cinta que mencionamos en la sección
     \ref{DIR_operaciones_con_archivos}, y como lo ilustra la figura
     \ref{DIR_acceso_secuencial}:
     El mecanismo principal para leer o escribir es ir avanzando
     consecutivamente por los bloques que conforman al archivo hasta
     llegar a su final.

     Típicamente emplearemos este mecanismo de lectura para leer a
     memoria código (programas o bibliotecas) o documentos, sea
     enteros o fracciones de los mismos. Para un contenido
     estructurado, como una base de datos, resultaría absolutamente
     ineficiente, dado que no conocemos el punto de inicio o
     finalización de cada uno de los registros, y probablemente
     tendríamos que hacer /barridos secuenciales/ del archivo completo
     para cada una de las búsquedas.

#+attr_latex: width=\textwidth
#+label: DIR_acceso_secuencial
#+caption: Archivo de acceso secuencial
[[./img/ditaa/acceso_secuencial.png]]

- Acceso aleatorio :: El empleo de gestores como /SQLite/ u otros
     muchos motores de base de datos más robustos no exime al usuario de
     pensar en el archivo como una tabla estructurada, como lo ilustra
     la figura \ref{DIR_acceso_aleatorio}. Si la única semántica por
     medio de la cual el sistema operativo permitiera trabajar con los
     archivos fuera la equivalente a una unidad de cinta, implementar
     el acceso a un punto determinado del archivo podría resultar
     demasiado gravoso.

     Afortunadamente, el que el sistema operativo no imponga registros
     de longitud fija no impide que /el programa gestor/ lo haga. Si
     en el archivo al cual apunta el descriptor de archivos =FD=
     hay 2000 registros de 75 bytes cada uno y el usuario requiere
     recuperar el registro número 65 hacia el buffer =registro=, puede
     /reposicionar/ el apuntador de lectura al byte $65 \times 75 =
     4875$ (=seek(FD, 4875)=) y leer los siguientes 75 bytes en
     =registro= (=read(FD, *registro, 75)=).

#+attr_latex: width=\textwidth
#+label: DIR_acceso_aleatorio
#+caption: Archivo de acceso aleatorio
[[./img/ditaa/acceso_aleatorio.png]]

- Acceso relativo a índice :: En los últimos años se han popularizado
     los gestores de base de datos /débilmente estructurados/ u /orientados a
     documentos/, llamados genéricamente /NoSQL/. Estos gestores pueden
     guardar registros de tamaño variable en disco, por lo que, como
     lo ilustra la figura \ref{DIR_acceso_relativo_a_indice}, no
     pueden encontrar la ubicación correcta por medio de los
     mecanismos de acceso aleatorio.

     Para implementar este acceso, se divide al conjunto de datos en
     dos secciones (incluso, posiblemente, en dos archivos
     independientes): La primer sección es una lista corta de
     identificadores, cada uno con el punto de inicio y término de
     los datos a los que apunta. Para leer un registro, se emplea
     acceso aleatorio sobre el índice, y el apuntador se avanza a la
     ubicación específica que se solicita.

     En el transcurso de un uso intensivo de esta estructura, dado que
     la porción de índice es muy frecuentemente consultada y
     relativamente muy pequeña, muy probablemente se mantenga completa
     en memoria, y el acceso a cada uno de los registros puede
     resolverse en tiempo muy bajo.

     La principal desventaja de este modelo de indexación sobre
     registros de longitud variable es que sólo resulta eficiente
     para contenido /mayormente de lectura/: Cada vez que se produce
     una escritura y cambia la longitud de los datos almacenados, se
     va generando fragmentación en el archivo, y para resolverla
     probablemente se hace necesario suspender un tiempo la ejecución
     de todos los procesos que lo estén empleando
     (e invalidar, claro, todas las copias en caché de los
     índices). Ahora bien, para los casos de uso en que el
     comportamiento predominante sea de
     lectura, este formato tendrá la ventaja de no desperdiciar
     espacio en los campos nulos o de valor irrelevante para algunos
     de los registros, y de permitir la flexibilidad de registrar
     datos originalmente no contemplados sin tener que modificar la
     estructura.

     Es importante recalcar que la escritura en ambas partes de la
     base de datos (índice y datos) debe mantenerse con garantías de
     atomicidad — Si se pierde la sincronía entre ellas, el resultado
     será una muy probable corrupción de datos.

#+attr_latex: width=\textwidth
#+label: DIR_acceso_relativo_a_indice
#+caption: Acceso relativo a índice: Un índice apuntando al punto justo de un archivo sin estructura
[[./img/ditaa/acceso_relativo_a_indice.png]]

** Transferencias orientadas a bloques

Un sistema de archivos es la representación que se da a un conjunto
de archivos y directorios sobre un /dispositivo orientado a bloques/;
un /dispositivo orientado a bloques/ es uno que, para cualquier
transferencia que solicitemos desde o hacia él, nos responderá con un
bloque de tamaño predefinido.

Esto es, si bien el sistema operativo nos presenta una abstracción por
medio de la cual la lectura (=read()=) puede ser de un tamaño
arbitrario, todas las transferencias de datos desde cualquiera de los
discos serán de un múltiplo del tamaño de bloques, definido por el
hardware (típicamente 512 bytes).

Cuando leemos, como en el ejemplo anterior, sólamente un registro
de 75 bytes, el sistema operativo lee el bloque completo y
probablemente lo mantiene en un caché en la memoria principal; si en
vez de una lectura, la operación que efectuamos fue una de escritura
(=write()=), y el sector que vamos a modificar no ha sido leído aún a
memoria (o fue leído hace mucho, y puede haber sido expirado del
caché), el sistema tendrá que leerlo nuevamente, modificarlo en
memoria, y volver a guardarlo a disco.

* Organización de archivos

Hasta ahora, nos hemos enfocado en qué es y cómo se maneja un
archivo. Sin embargo, no hablaríamos de /sistemas de archivos/ si no
tuviéramos una gran cantidad de archivos. Es común que en un sólo
medio de almacenamiento de un equipo de uso doméstico tengamos a
/decenas de miles/ de archivos, y en equipos dedicados, no está fuera
de lugar tener cientos o miles de veces tanto. Por tanto, tenemos que
ver también cómo se organiza una gran cantidad de archivos.

** Evolución del concepto de /directorio/

El concepto dominante en almacenaimiento hoy en día es el /directorio
jerárquico/. Demos un breve repaso acerca de su historia.

*** Convenciones de nomenclatura

Cada sistema de archivos puede determinar cuántos y qué caracteres
son válidos para designar a uno de sus elementos, y cuáles son
separadores válidos. El caracter que se emplea para separar los
elementos de un directorio no es un estándar a través de todos los
sistemas operativos — Los más comunes que encontraremos hoy en día
son la diagonal (=/=), empleada en sistemas tipo Unix y derivados
(incluyendo MacOS X y Android), y la diagonal invertida ($\backslash$),
empleada en CP/M y derivados, incluyendo MS-DOS y Windows.

Diversos sistemas han manejado otros caracteres (por ejemplo, el MacOS
histórico empleaba los dos puntos, =:=), y aunque muchas veces los
mantenían ocultos del usuario a través de una interfaz gráfica rica,
los programadores siempre tuvieron que manejarlos explícitamente.

A lo largo del presente texto manejaremos la diagonal (=/=) como
separador de directorios.

*** Sistema de archivos /plano/

Los primeros sistemas de archivos limitaban el concepto de directorio
a una representación plana de los archivos que lo conformaban, sin
ningún concepto de /jerarquía de directorios/ como el que hoy nos es
natural. Esto se debía, en primer término, a lo limitado del espacio
de almacenamiento de las primeras computadoras en implementar esta
metáfora (por lo limitado del espacio de almacenamiento, los usuarios
no dejaban sus archivos a largo plazo en el
disco, sino que los tenían ahí meramente mientras los requerían), y en
segundo término, a que no se había aún desarrollado un concepto de
separación, permisos y privilegios como el que poco después
aparecería.

En las computadoras personales los sistemas de archivos eran también
planos en un primer momento, pero por otra razón: En los sistemas
/profesionales/ ya se había desarrollado el concepto; al aparecer la
primer computadora personal en 1975, ya existían incluso las primeras
versiones de Unix diseñadas para trabajo en red. La prioridad en los
sistemas personales era mantener el código del sistema operativo
simple, mínimo. Con unidades de disco capaces de manejar entre 80 y
160KB, no tenía mucho sentido implementar directorios — Si un usuario
quisiera llevar a cabo una división temática de su trabajo, lo
colocaría en distintos /discos flexibles/. El sistema operativo CP/M
nunca soportó jerarquías de directorios, como tampoco lo hizo la
primer versión de MS-DOS.[fn:: El soporte de jerarquías de directorios
fue introducido apenas en la versión 2, junto con el soporte a discos
duros de 10MB, acompañando al lanzamiento de la IBM PC modelo XT.]

El sistema de archivos original de la Apple Macintosh, MFS, estaba
construido sobre un modelo plano, pero presentando la /ilusión/ de
directorios de una forma comparable a las etiquetas: Existían bajo
/ciertas/ vistas (pero notoriamente no en los diálogos de abrir y
grabar archivos), pero el nombre de cada uno de los archivos tenía que
ser único, dado que el direcorio al que pertenecía era básicamente
sólo un atributo del archivo.

Y contrario a lo que dicta la intuición, el modelo de directorio plano
no ha desaparecido: El sistema de /almacenamiento en la nube/ ofrecido
por el servicio /Amazon S3/ (/Simple Storage Service/, /Servicio
Simple de Almacenamiento/) maneja únicamente /objetos/ (comparable con
nuestra definición de archivos) y /cubetas/ (que reconoceríamos como
/unidades/ o /volúmenes/), y permite referirse a un objeto o un
conjunto de objetos basado en /filtros/ sobre el total que conforman a
una cubeta.

Probablemente a futuro nos encontremos con más ofertas como la de
Amazon S3, pero por ahora, continuemos sobre la línea histórica de los
directorios.

*** Directorios de profundidad fija

Las primeras implementaciones de directorios eran /de un sólo nivel/:
El total de archivos en un sistema podía estar dividido en
directorios, fuera por tipo de archivo (separando, por ejemplo,
programas de sistema, programas de usuario y textos del correo), por
usuario (facilitando una separación lógica de los archivos de un
usuario de pertenecientes a los demás usuarios del sistema)

El directorio /raiz/ (base) se llama en este esquema /MFD/ (/Master
File Directory/, /Directorio Maestro de Archivos/), y cada uno de los
directorios derivados es un /UFD/ (/User File Directory/, /Directorio
de Archivos de Usuario/).

#+attr_latex: width=\textwidth
#+label: DIR_directorio_simple
#+caption: Directorio simple, limitado a un sólo nivel de profundidad
[[./img/dot/directorio_simple.png]]

Este esquema resuelve el problema principal del nombre global único:
Antes de los directorios, cada usuario tenía que cuidar que los
nombres de sus archivos fueran únicos en el sistema, y ya teniendo
cada uno su propio espacio, se volvió una tarea mucho más simple. La
desventaja es que, si el sistema restringe a cada usuario a escribir
en su UFD, se vuelve fundamentalmente imposible trabajar en algún
proyecto conjunto: No puede haber un directorio que esté tanto dentro
de =usr1= como de =usr2=, y los usuarios encontrarán más dificil
llevar un proyecto conjunto.

*** Directorios estructurados en árbol

El siguiente paso natural para este esquema es permitir una /jerarquía
ilimitada/: En vez de exigir que exista una capa de directorios, se le
puede /dar la vuelta/ al argumento, y permitir que cada directorio
pueda contener a otros archivos o directorios a niveles
arbitrarios. Esto permite que cada usuario (y que el administrador del
sistema) estructure su información siguiendo criterios lógicos y
piense en el espacio de almacenamiento como un espacio a largo plazo.

#+attr_latex: width=\textwidth
#+label: DIR_directorio_arbol
#+caption: Directorio estucturado en árbol
[[./img/dot/directorio_arbol.png]]

Junto con esta estructura nacen las /rutas de búsqueda/ (/search
path/): Tanto los programas como las bibliotecas de sistema ahora
pueden estar en cualquier lugar del sistema de archivos. Al definirle
al sistema una /ruta de búsqueda/, el usuario operador puede
desentenderse del lugar exacto en el que está determinado programa —
El sistema se encargará de buscar en todos los directorios mencionados
los programas o bibliotecas que éste requiera.[fn:: La /ruta de
búsqueda/ refleja la organización del sistema de archivos en el
contexto de la instalación específica. Es común que la ruta de
búsqueda de un usuario estándar en Unix sea similar a
=/usr/local/bin:/usr/bin:/bin:~/bin= — Esto significa que cualquier
comando que sea presentado es buscado, en el órden indicado, en los
cuatro directorios presentados (separados por el caracter =:=, la
notación =~= indica el directorio personal del usuario activo). En
Windows, es común ver una ruta de búsqueda
=c:\WINDOWS\system32;c:\WINDOWS= ]

*** El directorio como un /grafo dirigido/
# <<DIR_grafo_dirigido>>

Si bien parecería que muchos de los sistemas de archivos que empleamos
hoy en día pueden modelarse suficientemente con un árbol, donde hay un
sólo nodo raiz, y donde cada uno de los nodos tiene un sólo nodo
padre, la semántica que ofrecen es en realidad un /superconjunto
estricto/ de esta: La de un grafo dirigido.

En un grafo dirigido como el presentado en la figura \ref{DIR_directorio_DAG}, un mismo nodo puede tener varios directorios
/padre/, permitiendo por ejemplo que un directorio de trabajo común
sea parte del directorio personal de dos usuarios. Esto es, /el mismo
objeto/ está presente en más de un punto del árbol.

#+attr_latex: width=0.5\textwidth
#+label: DIR_directorio_DAG
#+caption: Directorio como un /grafo dirigido acíclico/: El directorio =proyecto= está tanto en el directorio =/home/usr1= como en el directorio =/home/usr2=
[[./img/dot/directorio_DAG.png]]

Un sistema de archivos puede permitir la organización como un /grafo
dirigido/, aunque es común que la interfaz que presenta al
usuario[fn:: Esta simplificación es simplemente una abstracción, y
contiene una pequeña mentira, que será desmentida en breve.] se
restrinja a un /grafo dirigido acíclico/: Las ligas múltiples son
permitidas, siempre y cuando no generen un ciclo.

La semántica de los sistemas Unix implementa directorios como grafos
dirigidos por medio de dos mecanismos:

- Liga dura :: La entrada de un archivo en un directorio Unix es la
               relación entre la ruta del archivo y el /número de
               i-nodo/ en el sistema de archivos.[fn:: El significado
               y la estructura de un i-nodo se abordan en
               el capítulo \ref{FS}.] Si a partir de un archivo
               existente se crea una /liga dura/ a él, ésta es
               sencillamente otra entrada en el directorio apuntando
               al mismo /i-nodo/. Ambas entradas, pues, son el mismo
               archivo — No hay uno /maestro/ y uno /dependiente/.

	       En un sistema Unix, este mecanismo tiene sólo dos
               restricciones:

  1. Sólo se pueden hacer ligas duras dentro del mismo volumen.

  2. No pueden hacerse ligas duras a directorios, sólo a
     archivos.[fn:: Formalmente, puede haberlas, pero sólo el
     administrador puede crearlas; en la sección
     \ref{DIR_dir_traversal} se cubre la razón de esta restricción al
     hablar de recorrer los directorios.]

- Liga simbólica :: Es un archivo /especial/, que meramente indica a
                    dónde apunta. El encargado de seguir este archivo
                    a su destino (esto es, de /resolver/ la liga
                    simbólica) es el sistema operativo mismo; un
                    proceso no tiene que hacer nada especial para
                    seguir la liga.

		    Una liga simbólica puede /apuntar/ a directorios,
                    incluso creando ciclos, o a archivos en otros
		    volúmenes.

		    Cuando se crea una liga simbólica, la liga y el
                    archivo son dos entidades distintas. Si bien
                    cualquier proceso que abra al archivo destino
                    estará trabajando con la misma entidad, en caso de
                    que éste sea renombrado o eliminado, la liga
                    quedará /rota/ (esto es, apuntará a una ubicación
                    inexistente).

Si bien estos dos tipos de liga existen también en los sistemas
Windows[fn:: Únicamente en aquellos que emplean el sistema de archivos
/NTFS/, no en los que utilizan alguna de las variantes
de /FAT/ ], en dichos sistemas sigue siendo más común emplear los
/accesos directos/. Se denomina así a un archivo (identificado por su
extensión, =.lnk=), principalmente creado para poder /apuntar/ a los
archivos desde el escritorio y los menúes — Si un proceso solicita al
sistema abrir el /acceso directo/, no obtendrá al archivo destino,
sino que al acceso directo mismo.

Ahora, si bien tanto las ligas duras como las ligas simbólicas existen
también en Windows, su uso es muy poco frecuente. El API de Win32
ofrece las funciones necesarias, pero éstas no están reflejadas desde
la interfaz usuario del sistema — Y son sistemas donde el usuario
promedio no emplea una interfaz programador, sino que una interfaz
gráfica. Las ligas, pues, no son más empleadas por
/cuestión cultural/: En sus comunidades de usuarios, nunca fueron
frecuentes, por lo cual se mantienen como conceptos empleados sólo por
los /usuarios poderosos/.

Ya con el conocimiento de las ligas, y reelaborando la figura
\ref{DIR_directorio_DAG} con mayor apego a la realidad: En los
sistemas operativos (tanto Unix como Windows), todo directorio tiene
dos entradas especiales: Los directorios =.= y =..=, que aparecen tan
pronto como el directorio es creado, y resultan fundamentales para
mantener la /navegabilidad/ del árbol.

#+attr_latex: width=0.5\textwidth
#+label: DIR_directorio_DAG_completo
#+caption: Directorio como un /grafo dirigido/, mostrando los /enlaces ocultos/ al directorio actual =.= y al directorio /padre/ =..=
[[./img/dot/directorio_DAG_completo.png]]

Como se puede ver en la figura \ref{DIR_directorio_DAG_completo}, en
todos los directorios, =.= es una liga dura al mismo directorio, y
=..= es una liga al directorio /padre/ (de nivel jerárquico
inmediatamente superior). Claro está, como sólo puede
haber una liga =..=, un directorio enlazado desde dos lugares
distintos sólo apunta hacia uno de ellos con
su enlace =..=; en este caso, el directorio común =proyecto= está
dentro del directorio =/home/usr2=. La figura representa la /liga
simbólica/ desde =/home/usr1= como una línea punteada.

Hay una excepción a esta regla: El directorio raiz. En este caso,
tanto =.= como =..= apuntan al mismo directorio.

Esta es la razón por la cual no se puede tomar rigurosamente a un
árbol de archivos como a un /grafo dirigido acíclico/, ni en Windows
ni en Unix: Tanto las entradas =.= (al apuntar al mismo directorio
donde están contentidas) como las entradas =..= (al apuntar al
directorio padre) crean ciclos.

** Operaciones con directorios
# <<DIR_oper_dirs>>
Al igual que los archivos, los directorios tienen una semántica
básica de acceso. Los directorios resultan también tipos de datos
abstractos con algunas operaciones definidas — Y como veremos, muchas
de las operaciones que realizaremos con los directorios son análogas
a las empleadas para los archivos.[fn:: De hecho, en algunos sistemas
operativos, los directorios son meramente archivos de tipo especial,
que son presentados al usuario de forma distinta. Pero no adelantemos
vísperas, ese tema lo veremos más adelante.] Las operaciones básicas
a presentar son:

- Abrir y cerrar  :: Al igual que los archivos, los directorios deben
     ser /abiertos/ para trabajar con ellos, y /cerrados/ cuando ya no
     se les requiera. Para esto, en C, se emplean las funciones
     =opendir()= y =closedir()=. Estas funciones trabajan asociadas a
     un /flujo de directorio/ (/directory stream/), que funciona de
     forma análoga a un descriptor de archivo.

- Listado de archivos :: Para mostrar los archivos que conforman a un
     directorio, el directorio se /abre/ (tal como un archivo, pero en
     C, con la función =opendir()= en vez de =open()=), y va /leyendo/
     (con =readdir()=) sus entradas una a una. Cada uno de los
     resultados es una estrcutura =dirent= (/entrada de directorio/),
     cada una de las cuales contiene su nombre en =d_name=, el
     identificador de su /i-nodo/ en =d_ino=, y algunos datos
     adicionales del arcihvo en cuestión.

     Para presentar al usuario la lista de archivos que conforman un
     directorio, podría hacerse:

     #+BEGIN_SRC c
       #include <stdio.h>
       #include <dirent.h>
       #include <sys/types.h>
       
       int main(int argc, char *argv[]) {
         struct dirent *archivo;
         DIR *dir;
         if (argc != 2) {
           printf("Indique el directorio a mostrar\n");
           return 1;
         }
         dir = opendir(argv[1]);
         while ((archivo = readdir(dir)) != 0) {
           printf("%s\t", archivo->d_name);
         }
         printf("\n");
         closedir(dir);
       }
     #+END_SRC

     Al igual que en al hablar de archivos, podemos /rebobinar/ el
     listado del directorio al principio del listado con
     =rewinddir()=.

- Buscar un elemento :: La mayor parte de las veces, no nos interesa
     tanto ver el listado de archivos que existen, sino que abrir uno
     en particular — Esto es, buscar el archivo que cumpla con cierto
     criterio, con cierto nombre. Queda claro que esto podemos hacerlo
     discriminando, de entre los resultados que nos va arrojando
     =readdir=, y obtener la o las entradas que nos interesen.

- Crear, eliminar o renombrar un elemento :: Si bien estas tres
     operaciones se implementan por medio de una operación de
     escritura en el directorio, se implementan a través de las
     funciones de manejo de archivos.

*** Recorriendo los directorios
# <<DIR_dir_traversal>>

Es frecuente requerir aplicar una operación a todos los archivos
dentro de cierto directorio — Por ejemplo, si queremos agrupar a un
directorio completo en un archivo comprimido, o si queremos copiar
todos sus contenidos a otro medio. Procesar todas las entradas de un
directorio, incluyendo las de sus subdirectorios, se denomina
/recorrer el directorio/ (en inglés, /directory traversal/).

Si estamos trabajando en un sistema de archivos plano, la operación de
recorrido completo puede realizarse con un programa tan simple como el
que presentamos en la sección anterior.

Al hablar de un sistema de profundidad fija, e incluso de un
directorio estructurado en árbol, la lógica se complica levemente,
dado que para recorrer el directorio tenemos que revisar, a cada
entrada, si esta es a su vez un directorio (y en caso de que así sea,
entrar y procesar a cada uno de sus elementos). Hasta aquí, sin
embargo, podemos recorrer el directorio sin requerir de mantener
estructuras adicionales en memoria representando el estado.

Sin embargo, cuando consideramos a los grafos dirigidos, se vuelve
indispensable mantener en memoria la contabilidad de todos los nodos
que ya hemos tocado — en caso contrario, al caer en un ciclo (incluso
si este es creado por mecanismos como las /ligas simbólicas/),
caeríamos en un ciclo infinito.

Para esto, no bastaría tomar nota de las rutas de los archivos
conforme avanzamos por el grafo — Cada vez que los encontremos, su
ruta será distinta (por ejemplo, encontraríamos a
=/home/usr/proy/archivo=, seguido de =/home/usr/proy/mios/archivo=, a
continuación del cual seguiría =/home/usr/proy/mios/mios/archivo=, del
cual proseguiría ahora con =/home/usr/proy/mios/mios/mios/archivo=, y
un etcétera infinito), pero emplear un indexado basado en el número de
/i-nodo/[fn:: Que si bien no definimos aún formalmente lo que
significa, sabemos que es único por sistema de archivos] identifica
sin lugar a dudas a cada uno de los archivos.

*** Otros esquemas de organización

Por más que el uso de sistemas de archivos basados en directorios
jerárquicos nos parece universal y muy ampliamente aceptado, hay cada
vez más casos de uso que apuntan a que podemos estar por dar la
bienvenida a una nueva metáfora de organización de archivos.

Hay distintas propuestas, y claro está, es imposible aún saber cuál
dirección obtendrá el favor del mercado — O, dado que no
necesariamente sigamos teniendo un modelo apto para todos los usos, de
/qué/ segmento del mercado.


** /Montaje/ de directorios

Para trabajar con el contenido de un sistema de archivos, el sistema
operativo tiene que /montarlo/: Ubicarlo en un punto del árbol de
archivos visible al sistema.

Es muy común, especialmente en los entornos derivados de Unix, que un
sistema operativo trabaje con distintos sistemas de archivos al mismo
tiempo. Esto puede obedecer a varias causas, entre las cuales tenemos:

- Distintos medios físicos :: Si la computadora tiene más de una
     unidad de almacenamiento, el espacio dentro de cada uno de los
     discos se maneje como un sistema de archivos indepentiente. Esto
     es especialmente cierto en la presencia de unidades removibles
     (diskettes, CDs, unidades USB, discos duros externos, etc.)

- Diferentes usos esperados :: Como veremos más adelante, distintos
     /esquemas de organización/ (esto es, distintos sistemas de
     archivos) presentan ventajas para distintas formas de uso. Por
     ejemplo, tiene sentido que una base de datos resida sobre una
     organización distinta a la de los comandos (binarios) del
     sistema.

- Abstracciones de sistemas no-físicos :: El sistema operativo puede
     presentar diversas estructuras /con una estructura/ de sistema de
     archivos. El ejemplo más claro de esto es el sistema de archivos
     virtual =/proc=, existente en los sistemas Unix, que permite ver
     diversos aspectos de los procesos en ejecución (y, en Linux, del
     sistema en general). Los archivos bajo =/proc= no existen en
     ningún disco, pero se presentna como si fueran archivos estándar.

- Razones administrativas :: El administrador del sistema puede
     emplear sistemas de archivos distintos para aislar espacios de
     usuarios entre sí: Por ejemplo, para evitar que un exceso de
     mensajes enviados en la bitácora (típicamente bajo =/var/log=)
     saturen al sistema de archivos principal, o para determinar
     patrones de uso máximo por grupos de usuarios.

En los sistemas tipo Unix, el mecanismo para montar los archivos es el
de un árbol con /puntos de montaje/. Esto es, /todos los archivos y
directorios/ del sistema operativo están estructurados en torno a /un
sólo árbol/. Cuando se solicita al sistema operativo /montar/ un
sistema de archivos en determinado lugar, éste se integra al árbol,
ocultando todo lo que el directorio en cuestión previamente
tuviera.[fn:: Hay implementaciones que exigen que el montaje se realice
exclusivamente en directorios vacíos; existen otras, como UnionFS, que
buscan seguir presentando una interfaz /de lectura/ a los objetos que
existían en el directorio previo al montaje, pero realizan las
escrituras únicamente en el sistema ya montado; estas complican
fuertemente algunos aspectos semánticos, por lo cual resultan poco
comunes.]

#+attr_latex: width=\textwidth
#+label: DIR_puntos_de_montaje
#+caption: Árbol formado del montaje de =sda1= en la raiz, =sda2= como =/usr=, =sdb1= como =/home=, y el directorio virtual =proc=
[[./img/dot/puntos_de_montaje.png]]

La manera en que esto se presenta en sistemas Windows es muy
distinta. Ahí, cada uno de los sistemas de archivos /detectados/
recibe un /identificador de volumen/, y es montado automáticamente en
un sistema de directorio estructurado como árbol de un sólo nivel
representando a los dispositivos del sistema.[fn:: En realidad, este
árbol no sólo incluye a los volúmenes de almacenamiento, sino que a
los demás dispositivos del sistema, como los distintos puertos, pero
los /oculta/ de la interfaz gráfica.] Este árbol es presentado a
través de la interfaz gráfica (aunque este nombre no significa nada
para el API del sistema) como /Mi PC/.

Entrando con el identificador de volumen, encontramos al contenido de
cada uno. De este modo, la especificación absoluta de un archivo es
una cadena como =VOL:\Dir1\Dir2\Archivo.ext= — El caracter =:= separa
al volumen del árbol del sistema de archivos, y el caracter
$\backslash$ separa uno de otro a los directorios.

Los identificadores de volumen están preasignados, muchos de ellos
siguiendo a un esquema heredado desde la época de las primeras PC: Los
volúmenes =A= y =B= están reservados para las unidades de disco
flexible; =C= se refiere al disco duro de arranque, y las unidades
posteriores que va detectando el sistema son =D=, =E=, =F=, etc.

Es posible modificar esta nomenclatura y configurar a los discos para
estar en otra ubicación, pero muchas aplicaciones dependen ya de este
comportamiento y configuración específicos.

#+attr_latex: width=0.7\textwidth
#+label: DIR_montaje_windows
#+caption: Vista de un sistema de archivos Windows
[[./img/dot/montaje_windows.png]]

** Sistemas de archivos remotos

Uno de los principales y primeros usos que se dio a la comunicación en
red fue el de compartir archivos entre computadoras independientes. En
un principio, esto se realizaba de forma /explícita/, con
transferencias manuales a través de programas dedicados a ello, como
sería hoy en día el FTP.

Por otro lado, desde mediados de los 1980, es posible realizar estas
transferencias de forma /implícita/ y /automática/, empleando
/sistemas de archivos sobre la red/ (o lo que es lo mismo, /sistemas
de archivos remotos/).  Estos se nos presentan como caso particular de
la /abstracción de sistemas no-físicos/ que mencionamos en la sección
anterior: Si bien el sistema operativo no tiene acceso /real/ a los
archivos y directorios que le solicitará el usuario, a través de los
módulos de red, sabe cómo obtenerlos y presentarlos /como si fueran
locales/.

Al hablar de sistemas de archivos en red, casi siempre lo haremos
siguiendo un /modelo cliente-servidor/. Estos términos no se refieren
a las prestaciones relativas de una computadora, sino al rol que ésta
juega /dentro de cada conexión/ — Esto es, designamos como /cliente/ a
la computadora que solicita un servicio, y como /servidor/ a la que lo
provee; es frecuente que dos computadoras sean tanto servidor como
cliente la una de la otra en distintos servicios.

*** Network File System (NFS)

El /Sistema de Archivos en Red/ (/Network File System/, mejor conocido
por sus siglas, /NFS/) fue creado por Sun Microsystems, y desde 1984
forma parte de su sistema operativo — Resultó una implementación tan
exitosa que a los pocos años formaba parte de todos los sistemas tipo
Unix.

NFS está construido sobre el mecanismo /RPC/ (/Remote Procedure Call/,
/Llamada a Procedimientos Remotos/), un mecanismo de mensajes y manejo
básico de sesión que actúa como una capa superior a TCP/IP, incluyendo
facilidades de /descubrimiento de recursos/ y /abstracción/. RPC puede
ser comparado con protocolos como /DCE/RPC/ de OSF, /DCOM/ de
Microsoft, y hoy en día, /SOAP/ y /XML-RPC/. Estos mecanismos permiten
al programador delegar en un /servicio/ el manejo de las conexiones de
red, particularmente (en el caso que en este momento nos importa) la
persistencia de sesiones en caso de desconexión, y limitar su atención
a una /conexión establecida/.

La motivación de origen para la creación de NFS fue presentar una
solución que aprovechara el hardware existente y centralizara la
administración: Ofrecer las facilidades para contar con redes donde
hubiera un /servidor de archivos/, y donde las estaciones de trabajo
tuvieran únicamente una instalación básica,[fn:: Incluso manejando
estaciones de trabajo /diskless/, esto es, computadoras sin disco
duro, cuyo sistema de arranque tiene la capacidad de solicitar al
servidor le envíe incluso el núcleo del sistema operativo que
ejecutará] y el entorno de usuario completo estuviera disponible en
cualquiera de las estaciones.

NFS ofrece sobre la red un sistema de archivos con la semántica Unix
completa — Para montar un sistema remoto, basta montarlo[fn:: Para
montar un sistema remoto, usaríamos un comando como =mount
archivos.unam.mx:/home /home= ] y usarlo como si fuera local. El
manejo de permisos, usuarios, e incluso las ligas duras y simbólicas
se manejan exactamente como se haría localmente.

NFS es un protocolo muy ligero — No implementa cifrado ni
verificaciones adicionales, pero al día de hoy, es uno de los mejores
mecanismos para el envío de grandes cantidades de información — Pero
siempre en redes que sean /completamente confiables/.

Ahora, NFS se presenta como uno de los componentes de una solución
completa. Dado que se espera que la información de usuarios y permisos
sea /consistente/ en todos los clientes; Sun ofrecía también un
esquema llamado /Yellow Pages/ (posteriormente renombrado a NIS,
/Network Information System/) para compartir la información de
autenticación y listas de usuarios.

La desventaja, en entornos sin NIS, es que los permisos se manejan
según el ID numérico del usuario. Si en diferentes sistemas el mismo
usuario tiene diferentes IDs, los permisos no coincidirán. Es más,
dado que el control de acceso principal es únicamente por dirección
IP, para tener acceso irrestricto a los archivos de otros usuarios en
NFS basta con tener control pleno de una computadora cualquiera en la
red para poder /asumir o usurpar la identidad/ de cualquier otro
usuario.

Por último, para garantizar que las escrituras a archivos se llevaran
a cabo cuando eran solicitadas (en contraposición a asumir éxito y
continuar), todas las escrituras en un principio sobre NFS eran
manejadas de forma síncrona, esto es, tras grabar un archivo, el
cliente no continuaba con la ejecución hasta no tener confirmación por
parte del servidor de que los datos estaban ya guardados en
disco.

Versiones posteriores del protocolo mejoraron sobre los puntos débiles
aquí mencionados. Al día de hoy, casi 30 años después de su
presentación, NFS es aún un sistema de archivos en red muy ampliamente
empleado.

*** Common Internet File System (CIFS)

El equivalente a NFS en los entornos donde predominan los sistemas
Windows es el protocolo CIFS (/Common Internet File System/, Sistema
de Archivos Común para Internet). Aparece en los sistemas primarios de
Microsoft alrededor de 1990[fn:: El desarrollo de SMB nació como /LAN
Manager/, originalmente para OS/2], originalmente bajo el nombre SMB
(/Server Message Block/, /Bloque de Mensaje del Servidor/).

Las primeras implementaciones estaban orientadas al protocolo /NBF/,
frecuentemente conocido como /NetBEUI/, aunque a partir de Windows
2000 se ha reimplementado completamente para operar sobre TCP/IP. Es a
partir de este momento que se le comienza a denominar /CIFS/, aunque
el nombre /SMB/ sigue siendo ampliamente utilizado.[fn:: Es a este
nombre que la implementación de CIFS para sistemas Unix, /Samba/,
fue llamado de esta manera.]

CIFS se ajusta mucho más a la semántica de los sistemas MS-DOS y
Windows, aunque dado el lapso de tiempo que ha existido, ha pasado por
varios cambios fundamentales, que al día de hoy complican su uso.

Para tener acceso a un volumen compartido por SMB se introdujo el
comando =NET=;[fn:: Este comando es empleado en MS-DOS, pero está
también disponible en Windows, y al día de hoy es una de las
principales herramientas para administrar usuarios.] basta indicar a
DOS o Windows (desde la línea de comando) =NET USE W: \\servidor\directorio= para que el recurso
compartido bajo el nombre =directorio= dentro del equipo conocido como
=servidor= aparezca en el árbol /Mi PC/, y el usuario pueda emplear
sus contenidos como si fuera un sistema de archivos local, con un
volumen asignado de =W:=.

Cuando fue introducido al mercado, los sistemas Microsoft no manejaban
aún el concepto de usuarios, por lo que la única medida de seguridad
que implementaba SMB era el manejo de hasta dos contraseñas por
directorio compartido: Con una, el usuario obtenía acceso de sólo
lectura, y con la otra, de lectura y escritura. Tras la aparición de
Windows NT, se agregó un esquema de identificación por
usuaro/contraseña, que posibilita el otorgamiento de permisos con una
/granularidad/ mucho menor.[fn:: Esto significa, que puede
controlarse el acceso permitido más finamente, a nivel archivo
individual y usuario individual.]

SMB fue pensado originalmente para una red /pequeña/, con hasta un par
de decenas de equipos. La mayor parte de los paquetes eran enviados en
modo /de difusión/ (/broadcast/), por lo que era fácil llegar a la
saturación, y no existía un esquema centralizado de resolución de
nombres, con lo que era frecuente /no encontrar/ a determinado
equipo.

Los cambios que CIFS presenta a lo largo de los años son muy
profundos. Las primeras implementaciones presentan fuertes problemas
de confiabilidad, rendimiento y seguridad, además de estar planteadas
para su uso en un sólo tipo de sistema operativo; al día de hoy, estos
puntos han todos mejorado fuertemente. En sistemas Unix, la principal
implementación, /Samba/, fue creada haciendo ingeniería inversa sobre
el protocolo; a lo largo de los años, se ha convertido en un esquema
tan robusto que es hoy por hoy tomado como implementación refrencia.

*** Sistemas de archivos distribuídos: Andrew File System (AFS)

# Valdría la pena actualizar esto... Andrew tiene ya sus muchos
# años. ¿Tal vez agregar como ejemplo, o incluso reemplazarlo, con
# esquemas como CEPH, Gluster?

Los dos ejemplos de sistema de archivos en red presentados hasta ahora
comparten una visión /tradicional/ del modelo cliente-servidor: Al ver
el comando que inicializa una conexión, e incluso a ver la
información que guarda el núcleo del cliente respecto a cualquiera de
los archivos, resulta claro cuál es el servidor para cada uno de
ellos.

/Andrew File System/, desarrolaldo en la Carnegie Mellon
University[fn:: Como parte del /Proyecto Andrew/, denominado así por
el nombre de los fundadores de esta universidad: Andrew Carnegie y
Andrew Mellon] y publicado en 1989, plantea presentar un verdadero
/sistema de archivos distribuído/, en el cual los /recursos
compartidos/ no tengan que estar en un servidor en particular, sino
que un conjunto de equipos se repartan la carga (esto es,
/agnosticismo a la ubicación/). AFS busca también una /fácil
escalabilidad/, la capacidad de agregar tanto espacio de
almacenamiento como equipos con rol de servidor. AFS permite inclusive
migrar completamente un volumen mientras está siendo empleado, de
forma transparente.

Ante la complejidad e inestabilidad adicional que nos presentan con
tanta frecuencia las redes grandes[fn:: El uso típico de AFS se
planteaba para organizaciones grandes, del órden de decenas de miles
de estaciones] (y lo hacían mucho más hace 30 años): AFS debe operar
tan confiablemente como sea posible, /incluso sin la certeza de que la
red opera correctamente/.

AFS construye fuertemente sobre el modelo de /tickets/ y credenciales
de /Kerberos/, pero se aleja sensiblemente de la semántica de
operación de archivos que hasta ahora hemos manejado. Muchos eventos,
operaciones y estados van ligados al /momento en el tiempo/ en que se
presentan, a través de un /modelo de consistencia débil/ (/weak
consistency model/). Muy a grandes rasgos, esto significa que:

- Cuando se abre un archivo, éste se copia completo al cliente. Todas
  las lecturas /y escrituras/ (a diferencia de los esquemas
  tradicionales, en que éstas son enviadas al servidor /lo antes
  posible/ y de forma síncrona) se dirigen únicamente a la copia
  local.

- Al cerrar el archivo, éste se copia de vuelta al /servidor de
  origen/, el cual se /compromete/ a notificar a los clientes si un
  archivo abierto fue modificado (esto es, a /hacer una llamada/ o
  /callback/). Los clientes pueden entonces intentar incorporar los
  cambios a su versión de trabajo, o continuar con la copia ya
  obtenida — Es /esperable/ que si un segundo cliente realiza alguna
  modificación, incorpore los cambios hechos por el primero, pero esto
  se deja a la implementación del programa en cuestión.

Esto significa en pocas palabras que los cambios a un archivo abierto
por un usuario no son visibles a los demás de inmediato; sólo una vez
que se cierra un archivo, los cambios hechos a éste son puestos a
disposición de las sesiones abiertas actuales, y sólo son enviados
como /versión actual/ a las sesiones abiertas posteriormente.

Con este cambio semántico, debe quedar claro que AFS no busca ser un
sistema para todo uso ni un reemplazo universal de los sistemas de
archivos locales, en contraposición de los sistemas de archivos
centralizados. AFS no plantea en ningún momento una operación
/diskless/. Bajo el esquema aquí descrito, las lecturas y escrituras
resultan baratas, porque se realizan exclusivamente sobre el caché
local, pero abrir y cerrar un archivo puede ser muy caro, porque debe
transferirse el archivo completo.

Hay aplicaciones que verdaderamente sufrirían si
tuvieran que implementarse sobre un sistema de archivos distribuído —
Por ejemplo, si una base de datos se distribuyera sobre AFS, la
carencia de mecanismos de bloqueo sobre /secciones/ del archivo, y el
requisito de operar sobre /archivos completos/ harían impracticable
compartir un archivo de uso intensivo y aleatorio.


* Otros recursos

- [[http://cyanezfdz.me/post/los-discos-desde-la-perspectiva-de-un-sistema-de-archivos][Los discos desde la perspectiva de un sistema de archivos]] (César
  Yáñez)

- [[https://dl.acm.org/citation.cfm?doid%3D174613.174616][File-system development with stackable layers]] (Heidemann y Popek,
  1994 ACM Transactions on Computer Systems)

- [[https://dl.acm.org/citation.cfm?doid=225535.225537][Serverless network file systems]] (Thomas E. Anderson et. al., 1996,
  ACM Transactions on Computer Systems)

- [[http://data.openplanetsfoundation.org/ref/][OpenPlanets Results Evaluation Framework]], Open Planets
  Foundation. Muestra la evolución a lo largo de los años de cómo
  reconocen archivos de tipos conocidos varias herramientas
