#+SETUPFILE: ../setup_notas.org
#+TITLE: Sistemas Operativos — Sistemas de archivos

* Concepto de archivo

De los roles que cumple el sistema operativo, probablemente el que más
consciente tengan en general sus usuarios es el de la gestión del
espacio de almacenamiento, esto es, el sistema de archivos. Al día de
hoy, todos los usuarios de equipo de cómputo dan por sentado y
comprenden a grandes rasgos la organización del espacio de
almacenamiento en un /directorio jerárquico/, con unidades de
almacenamiento llamadas /archivos/, de diferentes tipos según su
función. En la primer parte de esta unidad revisaremos algo más a
profundidad a este modelo, para posteriormente ver los detalles de la
gestión del espacio físico donde éstos están alojados.

La abstracción que hoy conocemos como /archivos/ es una de las que más
tiempo han vivido y se han mantenido a lo largo de la historia de la
computación, sobreviviendo a lo largo de prácticamente todas las
generaciones de sistemas operativos.

En primer término, un archivo es un /tipo de datos abstracto/ — Esto
es, en programación moderna podríamos verlo como una estructura que
exclusivamente permite que la manipulemos por medio de una interfaz
/orientada a objetos/: Los procesos en el sistema sólo pueden tener
acceso a los archivos por medio de la interfaz ofrecida por el sistema
operativo.[fn:: Veremos más adelante que esto no es /necesariamente/
cierto, sin embargo, el uso de los dispositivos /en crudo/ es tan bajo
que podemos ignorarlos para propósitos de esta discusión] Abordaremos
los detalles de esta interfaz [[#operaciones_con_archivos][en breve]].

Para el usuario, los archivos son la /unidad lógica mínima/ al hablar
habla de almacenamiento: Todo el almacenamiento /persistente/ (que
sobrevive en el tiempo, sea a reinicios del sistema, a pérdida de
corriente o a otras circunstancias en el transcurso normal de
ejecución) en el sistema al que tiene acceso, se efectúa dentro de
archivos; el espacio libre en los diferentes dispositivos no tiene
mayor existencia fuera de saber que está /potencialmente/ disponible.

Dentro de cada /volúmen/ (cada medio de almacenamiento), los archivos
disponibles conforman a un /directorio/, y son típicamente
identificados por un /nombre/ o una /ruta/. Hablaremos más adelante
acerca de las diferentes construcciones semánticas que pueden
conformar a los directorios.

** Operaciones con archivos
#<<operaciones_con_archivos>>

Cada sistema operativo definirá la interfaz de archivos acorde con su
semántica, pero en líneas generales, las operaciones que siempre
estarán disponibles con un archivo son:

- Crear :: Asigna espacio en el dispositivo y en su directorio para
           alojar a un nuevo archivo.

- Borrar :: Elimina al archivo del directorio y, de ser procedente,
            libera el espacio del dispositivo

- Abrir :: Solicita al sistema operativo verificar si tenemos el
           acceso para el /modo de acceso/ al archivo que indiquemos y
           si el medio lo soporta (por ejemplo, a pesar de contar con
           los permisos, no podemos abrir para escritura un archivo en
           un disco de sólo lectura), y asigna un /descriptor de
           archivos/ que identifica la relación entre el proceso y el
           archivo en cuestión. Abrir un archivo es necesario para
           todas las siguientes operaciones.

- Cerrar :: Indica al sistema que /el proceso en cuestión/ terminó de
            trabajar con el archivo; el sistema entonces debe vaciar
            los buffers a disco y eliminar la entrada que representa a
            esta combinación archivo-proceso de las tablas activas,
            invalidando al /descriptor de archivo/. Si un proceso
            cierra un archivo y quiere volver a emplearlo, tendrá que
            abrirlo explícitamente.

- Leer :: Cuando indicamos al sistema que queremos leer de un archivo
          hacia determinado buffer, éste copia el siguiente /pedazo/
          de información a éste. Este /pedazo/ podría ser una línea o
          un bloque de longitud definida, dependiendo del modo en que
          se solicite la lectura. El sistema mantiene un apuntador a
          la última posición leída, para poder /continuar/ con la
          lectura.

- Escribir :: Teniendo un archivo ya existente, guarda información en
              él. Puede ser que escriba desde su primer posición
              (/truncando/ al archivo, esto es, borrando toda la
              información que pudiera ya tener), o /agregando/ al
              archivo, esto es, iniciando con el apuntador de
              escritura al final del mismo.

- Reposicionar :: (/seek/) Tanto la lectura como la escritura se hacen
                  siguiendo a un /apuntador/, que indica cuál fue la
                  última posición del archivo a la que accesó el
                  proceso actual. Al reposicionar el apuntador,
                  podemos /brincar/ a otro punto del archivo.

Hay varias otras operaciones comunes que pueden implementarse con
llamadas compuestas a estas operaciones (por ejemplo, /copiar/ un
archivo puede implementarse como /crear/ un archivo nuevo en modo de
escritura, abrir en modo de lectura al fuente, e ir /leyendo/ de éste
y /escribiendo/ al nuevo hasta llegar al fin de archivo).

Las operaciones que presentamos recién no son /todas/ las operaciones
existentes; dependiendo del sistema operativo, habrá algunas
adicionales; estas las presentamos como la base general sobre la cual
trabajaremos.

Vale la pena mencionar que esta semántica para el manejo de archivos
presenta a cada archivo como si fuera una /unidad de cinta/,
permitiéndonos avanzar o retroceder la cabeza lectora/escritora dentro
de ella.

** Tablas de archivos abiertos

Tanto el sistema operativo como cada uno de los procesos mantienen
normalmente /tablas de archivos abiertos/. Estas mantienen información
acerca de todos los archivos actualmente abiertos, presentándolos
hacia el proceso por medio de un /descriptor de archivo/; una vez que
un archivo fue abierto, las operaciones que se realizan dentro de éste
no son empleando su nombre, sino que su descriptor de archivos.

En un sistema operativo multitareas, más de un proceso podría abrir el
mismo archivo a la vez; lo que cada uno de ellos pueda hacer, y cómo
esto impacte a lo que vean los demás procesos, depende de la semántica
que implemente el sistema.

Ahora, ¿por qué mencionamos que estas tablas son mantenidas tanto por
el sistema operativo como por cada uno de los procesos? ¿No nos lleva
esto a una situación en que mantenemos información redundante?

La respuesta es que la información que cada uno debe manejar es
distinta. El sistema operativo necesita:

- Conteo de usuarios del archivo :: Cuando se solicita, por ejemplo,
     /desmontar/ una partición (por ejemplo, para expulsar una unidad
     removible) o eliminar un archivo, el sistema debe poder
     determinar cuándo es momento de declarar la solicitud como
     /efectuada/. Si algún proceso tiene abierto a un archivo, y
     particularmente si tiene cambios pendientes de guardar, el
     sistema no debe permitir que el archivo /desaparezca/ de su
     visión.
- Modos de acceso :: Aunque un usuario tenga permisos de acceso a
     determinado recurso, el sistema puede determinar negarlo si
     llevaría a una inconsistencia. Por ejemplo, si dos procesos abren
     un mismo archivo para escritura, es probable que los cambios que
     realice uno sobreescriban a los que haga el otro.
- Ubicación en disco :: Para evitar que cada proceso tenga que
     consultar las tablas en disco para encontrar al archivo, o sus
     fragmentos.
- Información de bloqueo :: En caso de que los modos de acceso del
     archivo requieran protección mutua, puede implementarse por
     medio de un bloqueo.

Por otro lado, el proceso necesita:

- Descriptor de archivo :: Relación entre el nombre del archivo
     abierto y el identificador numérico que maneja internamente el
     proceso. Un archivo abierto por varios procesos tendrá
     descriptores de archivo distintos en cada uno de ellos. El
     descriptor de archivo es un número entero.
- Permisos :: Los modos válidos de acceso para un archivo. Esto no
              necesariamente es igual a los permisos que tiene el
              archivo en cuestión en disco, sino que el /subconjunto/
              de dichos permisos bajo los cuales está operando para
              este proceso en particular — Si un archivo fue abierto
              en modo de sólo lectura, por ejemplo, este campo
              sólo permitirá la lectura.

** Acceso concurrente: Bloqueo de archivos

Dado que los archivos pueden emplearse como mecanismo de comunicación
entre procesos que no guarden relación entre sí, incluso a lo largo
del tiempo, y para emplear un archivo basta indicar su nombre o ruta,
los sistemas operativos multitarea implementan mecanismos de bloqueo
para evitar que varios procesos intentando emplear de forma
concurrente a un archivo se corrompan mutuamente.

Algunos sistemas operativos permiten establecer bloqueos sobre
determinadas regiones de los archivos, aunque la semántica más común
es operar sobre el archivo como una sola unidad.

En general, la nomenclatura que se sigue para los bloqueos es:

- Compartido :: (/Shared lock/) Podría verse como equivalente a un
                bloqueo (o /candado/) para realizar lectura — Varios
                procesos pueden adquirir al mismo tiempo un bloqueo de
                lectura, e indica que todos los que posean dicho
                /candado/ tienen la expectativa de que el archivo no
                sufrirá modificaciones.
- Exclusivo :: (/Exclusive lock/) Un bloqueo o /candado/ exclusivo
               puede ser adquirido por un sólo proceso, e indica que
               realizará operaciones que modifiquen al archivo (o, si
               la semántica del sistema operativo permite expresarlo,
               a la /porción/ del archivo que indica).

Respecto al /mecanismo/ de bloqueo, hay también dos tipos,
dependiendo de qué tan explícito tiene que ser su manejo:

- Mandatorio u obligatorio :: (/Mandatory locking/) Una vez que un
     proceso adquiere un candado obligatorio, el sistema operativo se
     encargará de imponer las restricciones corresponidentes de acceso
     a todos los demás procesos, independientemente de si éstos fueron
     programados para considerar la existencia de dicho bloqueo o no.
- Consultivo o asesor :: (/Advisory locking/) Este tipo de bloqueos
     es manejado exclusivamente entre los procesos involucrados, y
     depende del programador de /cada uno/ de los programas en
     cuestión el solicitar y respetar dicho bloqueo.

Haciendo un paralelo con los mecanismos presentados en la [[./02_administracion_de_procesos.org][unidad de
administración de procesos]], los mecanismos que emplean mutexes,
semáforos o variables de condición serían /consultivos/, y únicamente
los que emplean monitores (en que la única manera de llegar a la
información es a través del mecanismo que la protege) serían
/mandatorios/.

De esta matriz de $2\times2$ tipos de bloqueo, no todos los sistemas
operativos implementan las cuatro posibilidaddes. Como regla general,
en los sistemas Windows se maneja un esquema de bloqueo obligatorio, y
en sistemas Unix es de bloqueo consultivo.[fn:: Esto explica por qué
en Windows es tan común que el sistema mismo nos rechace hacer
determinada operación porque /el archivo está abierto por otro
programa/ (bloqueo mandatorio compartido), mientras que en Unix esta
responsabilidad recae en cada uno de los programas de aplicación]

Cabe mencionar que el manejo de bloqueos con archivos requiere del
mismo cuidado que el de bloqueo por recursos que el que vimos en
/administración de procesos/: Dos procesos intentando adquirir un
candado exclusivo sobre dos archivos pueden caer en un bloqueo mutuo
tal como ocurre con cualquier otro recurso externo.

** Tipos de archivo

Si los archivos son, como dijimos, la /unidad lógica mínima/ con la
que se puede guardar información en almacenamiento secundario,
naturalmente sigue que existen archivos de diferentes tipos — Un
archivo puede ser un documento de texto, un binario ejecutable, un
archivo de audio o video, y un larguísimo etcetera, e intentar emplear
a un archivo como uno de un tipo distinto puede resultar desde una
frustración al usuario porque el programa no responde como éste
quiere, hasta en pérdidas económicas.[fn:: Por ejemplo, imprimir un
archivo binario resulta en una gran cantidad de hojas inútiles,
particularmente tomando en cuenta que hay caracteres de control como
el ASCII 12 (avance de forma, /form feed/), que llevan a las
impresoras que operan en modo texto a iniciar una nueva página; llevar
a un usuario a correr un archivo ejecutable /disfrazado/ de un
documento inocuo, como veremos a continuación, fue un importante
vector de infección de muchos virus.]

Hay tres estrategias principales para que el sistema operativo
reconozca al tipo de un archivo:

- Extensión :: En los sistemas CP/M de los 1970, el nombre de cada
               archivo se dividía en dos porciones, empleando como
               separador al punto: El nombre del archivo y su
               extensión. El sistema mantenía una lista de extensiones
               conocidas, para las cuales sabría cómo actuar, y este
               diseño se extendería a las aplicaciones, que sólo
               abrirían a aquellos archivos cuyas extensiones
               supieran manejar.

	       Esta estrategia fue heredada por VMS y MS-DOS, de
               donde la adoptó Windows; ya en el contexto de un
               entorno gráfico, Windows agrega, más allá de las
               extensiones directamente ejecutables, la relación de
               extensiones con los programas capaces de trabajar con
               ellas, permitiendo invocar a un programa con sólo dar
               ``doble click'' en un documento.

	       Como nota, este esquema de asociación de tipo de
               archivo permite ocultar las extensiones toda vez que ya
               no requieren ser del conocimiento del usuario, sino que
               son gestionadas por el sistema operativo, abre una vía
               de ataque automatizado que se popularizó en su momento:
               El envío de correos con extensiones engañosas
               duplicadas — Esto es, el programa maligno (un /programa
               troyano/) se envía a todos los contactos del usuario
               infectado, presentándose por ejemplo como una imágen,
               con el nombre =inocente.png.exe=. Por el esquema de
               ocultamiento mencionado, éste se presenta al usuario
               como =inocente.png=, pero al abrirlo, el sistema
               operativo lo reconoce como un ejecutable, y lo ejecuta
               en vez de abrirlo en un visor de imágenes.

- Números mágicos :: La alternativa que emplean los sistemas Unix es,
     como siempre, simple y /elegante/, aunque indudablemente presenta
     eventuales lagunas: El sistema mantiene una lista compilada de
     las /huellas digitales/ de los principales formatos que debe
     manejar,[fn:: Una de las ventajas de este esquema es que cada
     administrador de sistema puede ampliar la lista con las huellas
     digitales que requiera localmente] para reconocer el contenido
     de un archivo basado en sus primeros bytes.

     Casi todos los formatos de archivo incluyen lo necesario para que
     se lleve a cabo este reconocimiento, y cuando no es posible
     hacerlo, se intenta por medio de ciertas reglas /heurísticas/.
     Por ejemplo, todos los archivos de imágen en /formato de
     intercambio gráfico/ (GIF) inician con la cadena =GIF87a= o
     =GIF89a=, dependiendo de la versión; los archivos del lenguaje de
     descripción de páginas PostScript inician con la cadena =%!=, el
     /Formato de Documentos Portátiles/ (PDF) con =%PDF=, etcétera. Un
     documento en formatos definidos alrededor de XML inicia con
     =<!DOCTYPE=.  Algunos de estos formatos no están /anclados/ al
     inicio, sino que en un punto específico del primer bloque.

     Un caso especial de números mágicos es el llamado /hashbang/
     (=#!=). Esto indica a un sistema Unix que el archivo en cuestión
     (típicamente un archivo de texto, incluyendo código fuente en
     algún lenguaje de /script/) debe tratarse como un ejecutable, y
     empleando como /intérprete/ al comando indicado inmediatamente
     después del /hashbang/. Es por esto que podemos ejecutar
     directamente, por ejemplo, los archivos que inician con
     =#!/usr/bin/bash=: El sistema operativo invoca al programa
     =/usr/bin/bash=, y le especifica como argumento al archivo en
     cuestión.

- Metadatos externos :: Los sistemas de archivos empleado por las
     Apple Macintosh desde 1984 separan en dos /divisiones/ (/forks/)
     la información de un archivo: Los datos que propiamente
     constituyen al archivo en cuestión son la /división de datos/
     (/data fork/), y la información /acerca del archivo/ se guardan
     en una estructura independiente llamada /división de recursos/
     (/resource fork/).

     Esta idea resultó fundamental para varias de las características
     /amigables al usuario/ que presentó Macintosh desde su
     introducción — Particularmente, para presentar un entorno gráfico
     que respondiera ágilmente, sin tener que buscar los datos base de
     una aplicación dentro de un archivo de mucho mayor tamaño. La
     /división de recursos/ cabe en pocos sectores de disco, y si
     tomamos en cuenta que las primeras Macintosh funcionaban
     únicamente con discos flexibles, el tiempo invertido en leer una
     lista de iconos podría ser demasiada.

     La división de recursos puede contener todo tipo de
     información; los programas ejecutables son los que le dan un
     mayor uso, dado que incluyen desde los aspectos gráficos (icono
     a mostrar para el archivo, ubicación de la ventana a ser
     abierta, etc.) hasta aspectos funcionales, como la traducción de
     sus cadenas al lenguaje particular del sistema en que está
     instalado. Esta división permite una gran flexibilidad, dado que
     no es necesario tener acceso al fuente del programa para crear
     traducciones y temas.

     En el tema particular que en esta sección nos concierne, la
     división de recursos incluye un campo /creador/, que indica qué
     programa fue el que creó al archivo, mismo que será llamado
     en caso de que el usuario invoque directamente al archivo.

     Las versiones actuales de MacOS ya no emplean esta técnica, sino
     que una llamada /appDirectory/, para propósitos de esta
     discusión, la técnica base es la misma.

** Estructura de los archivos y métodos de acceso
# <<archivos_estructurados>>
La razón principal de la existencia del sistema de archivos son /los
archivos/. Un archivo almacena información de /algún tipo/,
estructurado o no estructurado.

La mayor parte de los sistemas operativos maneja únicamente archivos
/sin estructura/ — Cada aplicación es responsable de preparar la
información de forma congruente, y la responsabilidad del sistema
operativo es únicamente entregarlo como un conjunto de bytes. Ha
habido sistemas de archivos históricos, como IBM CICS (1968), IBM MVS
(1974) o DEC VMS (1977), que administraban ciertos tipos de datos en
un formato básico de /base de datos/.

El que el sistema operativo no imponga estructura a un archivo no
significa, claro está, que la aplicación que lo genera no lo haga. La
razón por la que los sistemas creados en los últimos 30 años no han
implementado este esquema de base de datos es que le /resta/
flexibilidad al sistema: El que una aplicación tuviera que ceñirse a
los tipos de datos y alineación de campos del sistema operativo
impedía su adecuación, y el que la funcionalidad de un archivo tipo
base de datos dependiera de la versión del sistema operativo creaba
un /acoplamiento/ demasiado rígido entre el sistema operativo y las
aplicaciones: Hoy en día es mucho más común ver que los programas que
requieren gestores de base de datos interactúen con uno, implementado
independientemente en espacio de usuario, o incluso que /liguen/ con
un gestor implementado como biblioteca, como es el caso de /SQLite/
(que es empleado por herramientas de adquisición de datos tan de bajo
nivel como /systemtap/, y por herramientas tan de escritorio como el
gestor de fotografías /shotwell/ o el navegador /Firefox/).

Podemos ver aún un remanente de los archivos estructurados en los
sistemas derivados de MS-DOS: En estos sistemas, un archivo puede ser
/de texto/ o /binario/. Un archivo de texto está compuesto por una
serie de caracteres que forman /líneas/, y la separación entre una
línea y otra constituye de un /retorno de carro/ (=CR=, caracter
ASCII 13) seguido de un /salto de línea/ (=LF=, caracter ASCII
10).[fn:: Esta lógica es herencia de las máquinas de escribir
manuales, en que el /salto de línea/ (avanzar el rodillo a la línea
siguiente) era una operación distinta a la del /retorno de carro/
(devolver la cabeza de escritura al inicio de la línea). En la época
de los teletipos, como medida para evitar que se perdieran caracteres
mientras la cabeza volvía hasta la izquierda, se decidió separar el
inicio de nueva línea en los dos pasos que tienen las máquinas de
escribir, para inducir una demora que evitara la pérdida de
información.]

El acceso a los archivos puede realizarse de diferentes maneras:

- Acceso secuencial :: Mantiene la semántica por medio de la cual
     pudiéramos leer de nuestros archivos fuera la equivalente a
     unidad de cinta que mencionamos en la sección [[#operaciones_con_archivos][Operaciones con
     archivos]]: El mecanismo principal para leer o escribir es ir
     avanzando consecutivamente por los bloques que conforman al
     archivo hasta llegar a su final.

     Típicamente emplearemos este mecanismo de lectura para leer a
     memoria código (programas o bibliotecas) o documentos, sea
     enteros o fracciones de los mismos. Para un contenido
     estructurado, como una base de datos, resultaría absolutamente
     ineficiente, dado que no conocemos el punto de inicio o
     finalización de cada uno de los registros, y probablemente
     tendríamos que hacer /barridos secuenciales/ del archivo completo
     para cada una de las búsquedas.

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Archivo de acceso secuencial
#+begin_src ditaa :file ltxpng/acceso_secuencial.png :cmdline -E
          Lectura -=->
             |
             V
-=-+--------------------------------------------------------------------------+-=-
   |...Nombre##Gonzalo;Apellido##Oliva;Nombre##Raquel;Apellido##Domínguez;E...|
-=-+--------------------------------------------------------------------------+-=-
#+end_src
#+html: <p align="center">Archivo de acceso secuencial</p></div>

- Acceso aleatorio :: El empleo de gestores como /SQLite/ u otros
     muchos motores de base de datos más robustos no nos exime de
     pensar en nuestro archivo como una tabla estructurada. Si la
     única semántica por medio de la cual pudiéramos leer de nuestros
     archivos fuera la equivalente a una unidad de cinta, implementar
     el acceso a un punto determinado del archivo podría resultar
     demasiado gravoso.

     Afortunadamente, el que el sistema operativo no imponga registros
     de longitud fija no impide que /el programa gestor/ lo haga. Si
     en el archivo al cual apunta el descriptor de archivos =FD=
     tenemos 2000 registros de 75 bytes cada uno y necesitamos
     recuperar el registro número 65 hacia el buffer =registro=,
     /reposicionamos/ el apuntador de lectura al byte $65 \times 75 =
     4875$ (=seek(FD, 4875)=) y leemos los siguientes 75 bytes en
     =registro= (=read(FD, *registro, 75)=).

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Archivo de acceso aleatorio
#+begin_src ditaa :file ltxpng/acceso_aleatorio.png :cmdline -E

       +--------+-----------+-----------+-------------------+--------------+-------------+
       | Nombre | Apellido  | Teléfono  | Correo            | ultimaSesion | usuarioDesde|
     0 +--------+-----------+-----------+-------------------+--------------+-------------+
       :        :           :           :                   :              :             :
       : ...    : ...       : ...       : ...               : ...          : ...         :
  4800 +--------+-----------+-----------+-------------------+--------------+-------------+
       | José   | Chávez    | 5154-4553 | chavez@aqui.no.es | 2013.04.05   | 2012.01.15  |
  4875 +--------+-----------+-----------+-------------------+--------------+-------------+
------>| Gonzalo| Oliva     |           |                   |              |             |
  4950 +--------+-----------+-----------+-------------------+--------------+-------------+
       | Raquel | Domínguez |           | rdomgz@aca.si.es  |              |             |
  5025 +--------+-----------+-----------+-------------------+--------------+-------------+
       :        :           :           :                   :              :             :
       : ...    : ...       : ...       : ...               : ...          : ...         :
150000 +--------+-----------+-----------+-------------------+--------------+-------------+
#+end_src
#+html: <p align="center">Archivo de acceso aleatorio</p></div>

- Acceso relativo a índice :: En los últimos años se han popularizado
     los gestores de base de datos /no estructurados/ u /orientados a
     texto/, llamados genéricamente /NoSQL/. Estos gestores pueden
     guardar registros de tamaño variable en disco, por lo que no
     podríamos encontrar la ubicación correcta por medio de los
     mecanismos de acceso aleatorio.

     Para implementar este acceso, se divide al conjunto de datos en
     dos secciones (incluso, posiblemente, en dos archivos
     independientes): La primer sección es una lista corta de
     identificadores, cada uno con el punto de inicio y término de
     los datos a los que apunta. Para leer un registro, se emplea
     acceso aleatorio sobre el índice, y el apuntador se avanza a la
     ubicación específica que se solicita.

     En el transcurso de un uso intensivo de esta estructura, dado que
     la porción de índice es muy frecuentemente consultada y
     relativamente muy pequeña, muy probablemente se mantenga completa
     en memoria, y el acceso a cada uno de los registros puede
     resolverse en tiempo muy bajo.

     La principal desventaja de este modelo de indexación sobre
     registros de longitud variable es que sólo resulta eficiente
     para contenido /mayormente de lectura/: Cada vez que se produce
     una escritura y cambia la longitud de los datos almacenados, se
     va generando fragmentación en el archivo, y para resolverla
     probablemente se hace necesario suspender un tiempo la ejecución
     de todos los procesos que estén empleando al archivo en cuestión
     (e invalidar, claro, todas las copias en caché de los
     índices). Ahora bien, mientras se mantenga como mayormente de
     lectura, este formato tendrá la ventaja de no desperdiciar
     espacio en los campos nulos o de valor irrelevante para algunos
     de los registros.

     Además de esto, la escritura en ambas partes de la base de datos
     debe mantenerse con garantías de atomicidad — Si se pierde la
     sincronía entre índice y datos, nos enfrentamos a una muy
     probable corrupción de datos.

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Acceso relativo a índice: Un índice apuntando al punto justo de un archivo sin estructura
#+begin_src ditaa :file ltxpng/acceso_relativo_a_indice.png :cmdline -E
+-----------+--------+--------+
| Apellido  | Inicio | Tamaño |
+-----------+--------+--------+
| Chávez    |     0  |    132 |
+-----------+--------+--------+
| Domínguez |   163  |    200 |        +--------------------+
+-----------+--------+--------+     63 |...fono##5154-4553;E|  82
| Godoy     |   428  |     62 |     83 |mail##chavez@aqui.no| 102
+-----------+--------+--------+    103 |.es;ultimaSesion##20| 122
| Oliva     |    132 |     31 +------->+13.04.05;Nombre##Gon| 142
+-----------+--------+--------+    143 |zalo;Apellido##Oliva| 162
| Vázquez   |   408  |     20 |    163 |;Nombre##Raquel;Apel| 182
+-----------+--------+--------+    183 |lido##Domínguez;E...| 202
| Zapata    |   363  |     45 |        +--------------------+
+-----------+--------+--------+
#+end_src
#+html: <p align="center">Acceso relativo a índice: Un índice apuntando al punto justo de un archivo sin estructura</p></div>

** Transferencias orientadas a bloques

Un sistema de archivos es la representación que se da a un conjunto
de archivos y directorios sobre un /dispositivo orientado a bloques/;
un /dispositivo orientado a bloques/ es uno que, para cualquier
transferencia que solicitemos desde o hacia él, nos responderá con un
bloque de tamaño predefinido.

Esto es, si bien el sistema operativo nos presenta una abstracción por
medio de la cual la lectura (=read()=) puede ser de un tamaño
arbitrario, todas las transferencias de datos desde cualquiera de los
discos serán de un múltiplo del tamaño de bloques, definido por el
hardware (típicamente 512 bytes).

Cuando leemos, como en el ejemplo anterior, sólamente un registro
de 75 bytes, el sistema operativo lee el bloque completo y
probablemente lo mantiene en un caché en la memoria principal; si en
vez de una lectura, la operación que efectuamos fue una de escritura
(=write()=), y el sector que vamos a modificar no ha sido leído aún a
memoria (o fue leído hace mucho, y puede haber sido expirado del
caché), el sistema tendrá que leerlo nuevamente, modificarlo en
memoria, y volver a guardarlo a disco.


* Organización de archivos

Hasta ahora, nos hemos enfocado en qué es y cómo se maneja un
archivo. Sin embargo, no hablaríamos de /sistemas de archivos/ si no
tuviéramos una gran cantidad de archivos. Es común que en un sólo
medio de almacenamiento de un equipo de uso doméstico tengamos a
/decenas de miles/ de archivos, y en equipos dedicados, no está fuera
de lugar tener cientos o miles de veces tanto. Por tanto, tenemos que
ver también cómo se organiza una gran cantidad de archivos.

** Evolución del concepto de /directorio/

El concepto dominante en almacenaimiento hoy en día es el /directorio
jerárquico/. Demos un breve repaso acerca de su historia.

*** Convenciones de nomenclatura

Cada sistema de archivos puede determinar cuántos y qué caracteres
son válidos para designar a uno de sus elementos, y cuáles son
separadores válidos. El caracter que se emplea para separar los
elementos de un directorio no es un estándar a través de todos los
sistemas operativos — Los más comunes que encontraremos hoy en día
son la diagonal (=/=), empleada en sistemas tipo Unix y derivados
(incluyendo MacOS X y Android), y la diagonal invertida ($\backslash$),
empleada en CP/M y derivados, incluyendo MS-DOS y Windows.

Diversos sistemas han manejado otros caracteres (por ejemplo, el MacOS
histórico empleaba los dos puntos, =:=), y aunque muchas veces los
mantenían ocultos del usuario a través de una interfaz gráfica rica,
los programadores siempre tuvieron que poder especificarlos.

A lo largo del presente texto manejaremos la diagonal (=/=) como
separador de directorios.

*** Sistema de archivos /plano/

Los primeros sistemas de archivos limitaban el concepto de directorio
a una representación plana de los archivos que lo conformaban, sin
ningún concepto de /jerarquía de directorios/ como el que hoy nos es
natural. Esto se debía, en primer término, a lo limitado del espacio
de almacenamiento de las primeras computadoras en implementar esta
metáfora (los usuarios no dejaban sus archivos a largo plazo en el
disco, sino que los tenían ahí meramente cuando les eran útiles), y en
segundo término, a que no se había aún desarrollado un concepto de
separación, permisos y privilegios como el que poco después
aparecería.

En las computadoras personales los sistemas de archivos eran también
planos en un primer momento, pero por otra razón: En los sistemas
/profesionales/ ya se había desarrollado el concepto; al aparecer la
primer computadora personal en 1975, ya existían incluso las primeras
versiones de Unix diseñadas para trabajo en red. La prioridad en los
sistemas personales era mantener el código del sistema operativo
simple, mínimo. Con unidades de disco capaces de manejar entre 80 y
160KB, no tenía mucho sentido implementar directorios — Si un usuario
quisiera llevar a cabo una división temática de su trabajo, lo
colocaría en distintos /discos flexibles/. El sistema operativo CP/M
nunca soportó jerarquías de directorios, como tampoco lo hizo la
primer versión de MS-DOS[fn:: el soporte de jerarquías de directorios
fue introducido apenas en la versión 2, junto con el soporte a discos
duros de 10MB, con la IBM XT].

El sistema de archivos original de la Apple Macintosh, MFS, estaba
construido sobre un modelo plano, pero presentando la /ilusión/ de
directorios de una forma comparable a las etiquetas: Existían bajo
/ciertas/ vistas (pero notoriamente no en los diálogos de abrir y
grabar archivos), pero el nombre de cada uno de los archivos tenía que
ser único, dado que el direcorio al que pertenecía era básicamente
sólo un atributo del archivo.

Y contrario a lo que dicta la intuición, el modelo de directorio plano
no ha desaparecido: El sistema de /almacenamiento en la nube/ ofrecido
por el servicio /Amazon S3/ (/Simple Storage Service/, /Servicio
Simple de Almacenamiento/) maneja únicamente /objetos/ (comparable con
nuestra definición de archivos) y /cubetas/ (que reconoceríamos como
/unidades/ o /volúmenes/), y permite referirse a un objeto o un
conjunto de objetos en base a /filtros/ sobre el total que conforman a
una cubeta.

Probablemente a futuro nos encontremos con más ofertas como la de
Amazon S3, pero por ahora, continuemos sobre la línea histórica de los
directorios.

*** Directorios de profundidad fija

Las primeras implementaciones de directorios eran /de un sólo nivel/:
El total de archivos en un sistema podía estar dividido en
directorios, fuera por tipo de archivo (separando, por ejemplo,
programas de sistema, programas de usuario y textos del correo), por
usuario (facilitando una separación lógica de los archivos de un
usuario de pertenecientes a los demás usuarios del sistema)

El directorio /raiz/ (base) se llama en este esquema /MFD/ (/Master
File Directory/, /Directorio Maestro de Archivos/), y cada uno de los
directorios derivados es un /UFD/ (/User File Directory/, /Directorio
de Archivos de Usuario/).

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Directorio simple, limitado a un sólo nivel de profundidad
#+begin_src dot :exports results :file ltxpng/directorio_simple.png
  digraph G {
          subgraph cluster0 {
                  label = "MFD";
                  color=lightgray
                  style=filled;
                  sys;
                  mail;
                  usr1;
                  usr2;
          }
          subgraph cluster1 {
                  label="UFD: sys";
                  color=lightgray
                  style=filled;
                  list;
                  copy;
                  edit;
                  login;
          }
          subgraph cluster2 {
                  label="UFD: mail";
                  color=lightgray
                  style=filled;
                  m_usr1;
                  m_usr2;
          }
          subgraph cluster3 {
                  label="UFD: usr1";
                  color=lightgray
                  style=filled;
                  test_c1;
                  a_out;
          }
          subgraph cluster4 {
                  label="UFD: usr2";
                  color=lightgray
                  style=filled;
                  tarea_c;
                  instrucciones;
          }
          sys -> list;
          sys -> copy;
          sys -> edit;
          sys -> login;
  
          usr1 -> test_c1;
          usr1 -> a_out;
          usr2 -> tarea_c;
          usr2 -> instrucciones;
          mail -> m_usr1;
          mail -> m_usr2;
  
          sys [shape=box];
          mail [shape=box];
          usr1 [shape=box];
          usr2 [shape=box];
          test_c1 [label="test.c"];
          a_out [label="a.out"];
          tarea_c [label="tarea.c"];
          m_usr1 [label="usr1"];
          m_usr2 [label="usr2"];
  }
#+end_src

#+results:
[[file:ltxpng/directorio_simple.png]]
#+html: <p align="center">Directorio simple, limitado a un sólo nivel de profundidad</p></div>

Este esquema resuelve el problema principal del nombre global único:
Antes de los directorios, cada usuario tenía que cuidar que los
nombres de sus archivos fueran únicos en el sistema, y ya teniendo
cada uno su propio espacio, se volvió una tarea mucho más simple. La
desventaja es que, si el sistema restringe a cada usuario a escribir
en su UFD, se vuelve fundamentalmente imposible trabajar en algún
proyecto conjunto: No puede haber un directorio que esté tanto dentro
de =usr1= como de =usr2=, y los usuarios encontrarán más dificil
llevar un proyecto conjunto.

*** Directorios estructurados en árbol

El siguiente paso natural para este esquema es permitir una /jerarquía
ilimitada/: En vez de exigir que exista una capa de directorios, se le
puede /dar la vuelta/ al argumento, y permitir que cada directorio
pueda contener a otros archivos o directorios a niveles
arbitrarios. Esto permite que cada usuario (y que el administrador del
sistema) estructure su información siguiendo criterios lógicos y
piense en el espacio de almacenamiento como un espacio a largo plazo.

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Directorio estucturado en árbol
#+begin_src dot :exports results :file ltxpng/directorio_arbol.png
digraph G {
  root -> bin;
  root -> home;
  root -> lib;
  
  bin -> ls;
  bin -> cp;
  bin -> ed;
  bin -> login;

  lib -> libc;

  home -> usr1;
  home -> usr2;
  home -> usr3;

  usr1 -> test_c1;
  usr1 -> a_out;
  usr2 -> tarea_c2;
  usr2 -> instrucciones;
  usr3 -> tarea_c;
  usr3 -> a_out2;
  
  root [label="<raiz>", shape=box];
  bin [shape=box];
  home [shape=box];
  lib [shape=box];
  usr1 [shape=box];
  usr2 [shape=box];
  usr3 [shape=box];
  a_out [label="a.out"];
  test_c1 [label="test.c"];
  a_out2 [label="a.out"];
  tarea_c [label="tarea.c"];
  tarea_c2 [label="tarea.c"];
}
#+end_src

#+results:
[[file:ltxpng/directorio_arbol.png]]
#+html: <p align="center">Directorio estructurado en árbol</p></div>

Junto con esta estructura nacen las /rutas de búsqueda/ (/search
path/): Tanto los programas como las bibliotecas de sistema ahora
pueden estar en cualquier lugar del sistema de archivos. Al definirle
al sistema una /ruta de búsqueda/, el usuario operador puede
desentenderse del lugar exacto en el que está determinado programa —
El sistema se encargará de buscar en todos los directorios mencionados
los programas o bibliotecas que éste requiera.[fn:: La /ruta de
búsqueda/ refleja la organización del sistema de archivos en el
contexto de la instalación específica. Es común que la ruta de
búsqueda de un usuario estándar en Unix sea similar a
=/usr/local/bin:/usr/bin:/bin:~/bin= — Esto significa que cualquier
comando que sea presentado es buscado, en el órden indicado, en los
cuatro directorios presentados (separados por el caracter =:=, la
notación =~= indica el directorio personal del usuario activo). En
Windows, es común ver una ruta de búsqueda
=c:\WINDOWS\system32;c:\WINDOWS= ]

*** El directorio como un /grafo dirigido/

Si bien parecería que muchos de los sistemas de archivos que empleamos
hoy en día pueden modelarse suficientemente con un árbol, donde hay un
sólo nodo raiz, y donde cada uno de los nodos tiene un sólo nodo
padre, la semántica que ofrecen es en realidad un /superconjunto
estricto/ de esta: La de un grafo dirigido.

En un grafo dirigido, un mismo nodo puede tener varios directorios
/padre/, permitiendo por ejemplo que un directorio de trabajo común
sea parte del directorio personal de dos usuarios. Esto es, /el mismo
objeto/ está presente en más de un punto del árbol.

#+html: <div class="figure">
#+attr_latex: width=0.5\textwidth
#+caption: Directorio como un /grafo dirigido acíclico/: El directorio =proyecto= está tanto en el directorio =/home/usr1= como en el directorio =/home/usr2=
#+begin_src dot :exports results :file ltxpng/directorio_DAG.png
digraph G {
  root -> home;

  home -> usr1;
  home -> usr2;

  usr1 -> test_c1;
  usr1 -> a_out;
  usr1 -> proyecto;
  usr2 -> tarea_c2;
  usr2 -> proyecto;

  proyecto -> README;
  proyecto -> proy_c;

  root [label="<raiz>", shape=box];
  home [shape=box];
  usr1 [shape=box];
  usr2 [shape=box];
  proyecto [shape=box];
  a_out [label="a.out"];
  test_c1 [label="test.c"];
  tarea_c2 [label="tarea.c"];
  proy_c [label="proy.c"];
}
#+end_src

#+results:
[[file:ltxpng/directorio_DAG.png]]
#+html: <p align="center">Directorio como un /grafo dirigido acíclico/: El directorio <tt>proyecto</tt> está tanto en el directorio <tt>/home/usr1</tt> como en el directorio <tt>/home/usr2</tt></p></div>

Un sistema de archivos puede permitir la organización como un /grafo
dirigido/, aunque es común que la interfaz que presenta al usuario se
restrinja a un /grafo dirigido acíclico/: Las ligas múltiples son
permitidas, siempre y cuando no generen un ciclo.

La semántica de los sistemas Unix implementa directorios como grafos
dirigidos por medio de dos mecanismos:

- Liga dura :: La entrada de un archivo en un directorio Unix es la
               relación entre la ruta del archivo y el /número de
               i-nodo/ en el sistema de archivos.[fn:: Abordaremos a
               detalle el significado y la estructura de un i-nodo más
               adelante en esta misma unidad] Si tenemos un archivo
               existente y creamos una /liga dura/ a él, ésta es
               sencillamente otra entrada en el directorio apuntando
               al mismo /i-nodo/. Ambas entradas, pues, son el mismo
               archivo — No hay uno /maestro/ y uno /dependiente/.

	       En un sistema Unix, este mecanismo tiene sólo dos
               restricciones:
  1. Sólo se pueden hacer ligas duras dentro del mismo sistema de
     archivos

  2. No pueden hacerse ligas duras a directorios, sólo a archivos[fn::
     Formalmente, puede haberlas, pero sólo el administrador puede
     crearlas; detallaremos el por qué al hablar de [[#dir_traversal][recorrer los
     directorios]]]

- Liga simbólica :: Es un archivo /especial/, que meramente indica a
                    dónde apunta. El encargado de seguir este archivo
                    a su destino (esto es, de /resolver/ la liga
                    simbólica) es el sistema operativo mismo; un
                    proceso no tiene que hacer nada especial para
                    seguir la liga.

		    Una liga simbólica puede /apuntar/ a directorios,
                    incluso creando ciclos, o a archivos de otros
                    sistemas de archivos.

		    Cuando creamos una liga simbólica, la liga y el
                    archivo son dos entidades distintas. Si bien
                    cualquier proceso que abra al archivo destino
                    estará trabajando con la misma entidad, en caso de
                    que éste sea renombrado o eliminado, la liga
                    quedará /rota/, apuntando a una ubicación
                    inexistente.

Si bien estos dos tipos de liga existen también en los sistemas
Windows[fn:: Únicamente en aquellos que emplean el sistema de archivos
/NTFS/, no en los que están instalados sobre alguna de las variantes
de /FAT/ ], en dichos sistemas sigue siendo más común emplear los
/accesos directos/. Se denomina así a un archivo (identificado por su
extensión, =.lnk=), principalmente creado para poder /apuntar/ a los
archivos desde el escritorio y los menúes — Si un proceso solicita al
sistema abrir el /acceso directo/, no obtendrá al archivo destino,
sino que al acceso directo mismo.

Ahora, si bien tanto las ligas duras como las ligas simbólicas existen
también en Windows, su uso es muy poco frecuente. El API de Win32
ofrece las funciones necesarias, pero éstas no están reflejadas desde
la interfaz usuario del sistema — Y son sistemas donde el usuario
promedio no emplea una interfaz programador, sino que una interfaz
gráfica. Las ligas, podemos concluir, no son más empleadas por
/cuestión cultural/: En sus comunidades de usuarios, nunca fueron
frecuentes, por lo cual se mantienen como conceptos empleados sólo por
los /usuarios poderosos/.

Ya con el conocimiento de las ligas, podemos presentar la figura
anterior más apegada a la realidad: En los sistemas operativos (tanto
Unix como Windows), todo directorio tiene dos entradas especiales:
Los directorios =.= y =..=

#+html: <div class="figure">
#+attr_latex: width=0.5\textwidth
#+caption: Directorio como un /grafo dirigido/, mostrando los /enlaces ocultos/ =.= y =..=
#+begin_src dot :exports results :file ltxpng/directorio_DAG_completo.png
digraph G {
  root -> root [label="."];
  root -> root [label=".."];

  root -> home;
  home -> home [label="."];
  home -> root [label=".."];

  home -> usr1;
  usr1 -> home [label=".."];
  usr1 -> usr1 [label="."];
  home -> usr2;
  usr2 -> home [label=".."];
  usr2 -> usr2 [label="."];

  usr1 -> test_c1;
  usr1 -> a_out;
  usr1 -> proyecto [style="dotted"];
  proyecto -> proyecto [label="."];
  proyecto -> usr2 [label=".."];
  usr2 -> tarea_c2;
  usr2 -> proyecto;

  proyecto -> README;
  proyecto -> proy_c;

  root [label="<raiz>", shape=box];
  home [shape=box];
  usr1 [shape=box];
  usr2 [shape=box];
  proyecto [shape=box];
  a_out [label="a.out"];
  test_c1 [label="test.c"];
  tarea_c2 [label="tarea.c"];
  proy_c [label="proy.c"];
}
#+end_src

#+results:
[[file:ltxpng/directorio_DAG_completo.png]]
#+html: <p align="center">Directorio como un /grafo dirigido/: El directorio <tt>proyecto</tt> está tanto en el directorio <tt>/home/usr1</tt> como en el directorio <tt>/home/usr2</tt></p></div>

En todos los directorios, =.= es una liga dura al mismo directorio, y
=..= es una liga al directorio padre. Claro está, como sólo puede
haber una liga =..=, un directorio que está enlazado desde dos lugares
distintos del sistema de archivos sólo apunta hacia uno de ellos con
su enlace =..=; en este caso, el directorio común =proyecto= está
dentro del directorio =/home/usr2=, y representamos la /liga
simbólica/ desde =/home/usr1= como una línea punteada.

Notarán que hay una excepción: El directorio raiz. En este caso,
tanto =.= como =..= apuntan al mismo directorio.

Y esta es la razón que mencionamos hace algunas líneas por la cual no
podemos ver a un árbol de archivos, ni en Windows ni en Unix, como a
un /grafo dirigido acíclico/: Tanto las entradas =.= (al apuntar al
mismo directorio donde están contentidas) como las entradas =..= (al
apuntar al directorio padre) crean ciclos.

** Operaciones con directorios
# <<oper_dirs>>
Al igual que los archivos, los directorios tienen una semántica
básica de acceso. Los directorios resultan también tipos de datos
abstractos con algunas operaciones definidas — Y como veremos, muchas
de las operaciones que realizaremos con los directorios son análogas
a las empleadas para los archivos.[fn:: De hecho, en algunos sistemas
operativos, los directorios son meramente archivos de tipo especial,
que son presentados al usuario de forma distinta. Pero no adelantemos
vísperas, ese tema lo veremos más adelante.] Las operaciones básicas
a presentar son:

- Abrir y cerrar  :: Al igual que los archivos, los directorios deben
     ser /abiertos/ para trabajar con ellos, y /cerrados/ cuando ya no
     se les requiera. Para esto, en C, se emplean las funciones
     =opendir()= y =closedir()=. Estas funciones trabajan asociadas a
     un /flujo de directorio/ (/directory stream/), que funciona de
     forma análoga a un descriptor de archivo.

- Listado de archivos :: Para mostrar los archivos que conforman a un
     directorio, el directorio se /abre/ (tal como un archivo, pero en
     C, con la función =opendir()= en vez de =open()=), y va /leyendo/
     (con =readdir()=) sus entradas una a una. Cada uno de los
     resultados es una estrcutura =dirent= (/entrada de directorio/),
     cada una de las cuales contiene su nombre en =d_name=, el
     identificador de su /i-nodo/ en =d_ino=, y algunos datos
     adicionales del arcihvo en cuestión.

     Para presentar al usuario la lista de archivos que conforman un
     directorio, podría hacerse:

     #+BEGIN_SRC c
       #include <stdio.h>
       #include <dirent.h>
       #include <sys/types.h>
       
       int main(int argc, char *argv[]) {
         struct dirent *archivo;
         DIR *dir;
         if (argc != 2) {
           printf("Indique el directorio a mostrar\n");
           return 1;
         }
         dir = opendir(argv[1]);
         while ((archivo = readdir(dir)) != 0) {
           printf("%s\t", archivo->d_name);
         }
         printf("\n");
         closedir(dir);
       }
     #+END_SRC

     Al igual que en al hablar de archivos, podemos /rebobinar/ el
     listado del directorio al principio del listado con
     =rewinddir()=.

- Buscar un elemento :: La mayor parte de las veces, no nos interesa
     tanto ver el listado de archivos que existen, sino que abrir uno
     en particular — Esto es, buscar el archivo que cumpla con cierto
     criterio, con cierto nombre. Queda claro que esto podemos hacerlo
     discriminando, de entre los resultados que nos va arrojando
     =readdir=, y obtener la o las entradas que nos interesen.

- Crear, eliminar o renombrar un elemento :: Si bien estas tres
     operaciones se implementan por medio de una operación de
     escritura en el directorio, se implementan a través de las
     funciones de manejo de archivos.

*** Recorriendo los directorios
# <<#dir_traversal>>

Es frecuente requerir aplicar una operación a todos los archivos
dentro de cierto directorio — Por ejemplo, si queremos agrupar a un
directorio completo en un archivo comprimido, o si queremos copiar
todos sus contenidos a otro medio. Procesar todas las entradas de un
directorio, incluyendo las de sus subdirectorios, se denomina
/recorrer el directorio/ (en inglés, /directory traversal/).

Si estamos trabajando en un sistema de archivos plano, la operación de
recorrido completo puede realizarse con un programa tan simple como el
que presentamos en [[#oper_dirs][la sección anterior]].

Al hablar de un sistema de profundidad fija, e incluso de un
directorio estructurado en árbol, la lógica se complica levemente,
dado que para recorrer el directorio tenemos que revisar, a cada
entrada, si esta es a su vez un directorio (y en caso de que así sea,
entrar y procesar a cada uno de sus elementos). Hasta aquí, sin
embargo, podemos recorrer el directorio sin requerir de mantener
estructuras adicionales en memoria representando el estado.

Sin embargo, cuando consideramos a los grafos dirigidos, se vuelve
indispensable mantener en memoria la contabilidad de todos los nodos
que ya hemos tocado — en caso contrario, al caer en un ciclo (incluso
si este es creado por mecanismos como las /ligas simbólicas/),
caeríamos en un ciclo infinito.

Para esto, no bastaría tomar nota de las rutas de los archivos
conforme avanzamos por el grafo — Cada vez que los encontremos, su
ruta será distinta (por ejemplo, veríamos =/home/usr/proy/archivo=,
seguido de =/home/usr/proy/mios/archivo=, a continuación del cual
seguiría =/home/usr/proy/mios/mios/archivo=, después de éste, seguiría
con =/home/usr/proy/mios/mios/mios/archivo=, etc.), pero emplear un
indexado basado en el número de /i-nodo/[fn:: Que si bien no definimos
aún formalmente lo que significa, sabemos que es único por sistema de
archivos] identifica sin lugar a dudas a cada uno de los archivos.

*** Otros esquemas de organización

Por más que el uso de sistemas de archivos basados en directorios
jerárquicos nos parece universal y muy ampliamente aceptado, hay cada
vez más casos de uso que apuntan a que podemos estar por dar la
bienvenida a una nueva metáfora de organización de archivos.

Hay distintas propuestas, y claro está, es imposible aún saber cuál
dirección obtendrá el favor del mercado — O, dado que no
necesariamente sigamos teniendo un modelo apto para todos los usos, de
/qué/ segmento del mercado.


** /Montaje/ de directorios

Para trabajar con el contenido de un sistema de archivos, el sistema
operativo tiene que /montarlo/: Ubicarlo en un punto del árbol de
archivos visible al sistema.

Es muy común, especialmente en los entornos derivados de Unix, que un
sistema operativo trabaje con distintos sistemas de archivos al mismo
tiempo. Esto puede obedecer a varias causas, entre las cuales tenemos:

- Distintos medios físicos :: Si la computadora tiene más de una
     unidad de almacenamiento, el espacio dentro de cada uno de los
     discos se maneje como un sistema de archivos indepentiente. Esto
     es especialmente cierto en la presencia de unidades removibles
     (diskettes, CDs, unidades USB, discos duros externos, etc.)

- Diferentes usos esperados :: Como veremos más adelante, distintos
     /esquemas de organización/ (esto es, distintos sistemas de
     archivos) presentan ventajas para distintas formas de uso. Por
     ejemplo, tiene sentido que una base de datos resida sobre una
     organización distinta a la de los comandos (binarios) del
     sistema.

- Abstracciones de sistemas no-físicos :: El sistema operativo puede
     presentar diversas estructuras /con una estructura/ de sistema de
     archivos. El ejemplo más claro de esto es el sistema de archivos
     virtual =/proc=, existente en los sistemas Unix, que permite ver
     diversos aspectos de los procesos en ejecución (y, en Linux, del
     sistema en general). Los archivos bajo =/proc= no existen en
     ningún disco, pero se presentna como si fueran archivos estándar.

- Razones administrativas :: El administrador del sistema puede
     emplear sistemas de archivos distintos para aislar espacios de
     usuarios entre sí: Por ejemplo, para evitar que un exceso de
     mensajes enviados en la bitácora (típicamente bajo =/var/log=)
     saturen al sistema de archivos principal, o para determinar
     patrones de uso máximo por grupos de usuarios.

En los sistemas tipo Unix, el mecanismo para montar los archivos es el
de un árbol con /puntos de montaje/. Esto es, /todos los archivos y
directorios/ del sistema operativo están estructurados en torno a /un
sólo árbol/. Cuando se solicita al sistema operativo /montar/ un
sistema de archivos en determinado lugar, éste se integra al árbol,
ocultando todo lo que el directorio en cuestión previamente
tuviera.[fn:: Hay implementaciones que exigen que el montaje se realice
exclusivamente en directorios vacíos; existen otras, como UnionFS, que
buscan seguir presentando una interfaz /de lectura/ a los objetos que
existían en el directorio previo al montaje, pero realizan las
escrituras únicamente en el sistema ya montado; estas complican
fuertemente algunos aspectos semánticos, por lo cual resultan poco
comunes.]

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Árbol formado del montaje de =sda1= en la raiz, =sda2= como =/usr=, =sdb1= como =/home=, y el directorio virtual =proc=
#+begin_src dot :exports results :file ltxpng/puntos_de_montaje.png
  digraph G {
          rankdir = TB;
          subgraph cluster_root {
                  label = "sda1";
                  color = lightgray;
                  style = filled;
                  root -> var;
                  root -> bin;
                  root -> sbin;
          }
          subgraph cluster_sda2 {
                  label = "sda2";
                  color = lightblue;
                  style = filled;
                  usr -> usrbin;
                  usr -> usrlib;
                  usrbin -> bash;
                  usrbin -> perl;
          }
          subgraph cluster_proc {
                  label="proc"
                  color=yellow;
                  style=filled;
                  proc -> 1;
                  proc -> 2;
                  proc -> 3;
          }
          subgraph cluster_sdb1 {
                  label = "sdb1";
                  color = pink;
                  style = filled;
                  home -> juan;
                  home -> pedro;
                  home -> irene;
                  juan -> tarea_c;
                  pedro -> proyecto_pl [style=dotted];
                  irene -> proyecto_pl;
          }
          subgraph cluster_sda3 {
                   label = "sda3"
                   color = green;
                   style = filled;
                   usrlocal -> locbin;
                   usrlocal -> locgames;
          }
          
          root -> proc;
          root -> home;
          root -> usr;
          usr -> usrlocal;
          
          root [shape=box, label="/"];
          bin [shape=box];
          sbin [shape=box];
          usr [shape=box];
          proc [shape=box];
          var [shape=box];
          home [shape=box];
          usrbin [shape=box, label="bin"];
          usrlib [shape=box, label="lib"];
          juan [shape=box];
          pedro [shape=box];
          irene [shape=box];
          usrlocal [shape=box, label="local"];
          locgames [shape=box, label="games"];
          locbin [shape=box, label="bin"];
  }
  
    
#+end_src

#+results:
[[file:ltxpng/puntos_de_montaje.png]]
#+html: <p align="center">Árbol formado del montaje de <tt>sda1</tt> en la raiz, <tt>sda2</tt> como <tt>/usr</tt>, <tt>sdb1</tt> como <tt>/home</tt>, y el directorio virtual <tt>proc</tt></p></div>

La manera en que esto se presenta en sistemas Windows es muy
distinta. Ahí, cada uno de los sistemas de archivos /detectados/
recibe un /identificador de volumen/, y es montado automáticamente en
un sistema de directorio estructurado como árbol de un sólo nivel
representando a los dispositivos del sistema.[fn:: En realidad, este
árbol no sólo incluye a los volúmenes de almacenamiento, sino que a
los demás dispositivos del sistema, como los distintos puertos, pero
los /oculta/ de la interfaz gráfica.] Este árbol es presentado a
través de la interfaz gráfica (aunque este nombre no significa nada
para el API del sistema) como /Mi PC/.

Entrando con el identificador de volumen, encontramos al contenido de
cada uno. De este modo, la especificación absoluta de un archivo es
una cadena como =VOL:\Dir1\Dir2\Archivo.ext= — El caracter =:= separa
al volumen del árbol del sistema de archivos, y el caracter
$\backslash$ separa uno de otro a los directorios.

Los identificadores de volumen están preasignados, muchos de ellos
siguiendo a un esquema heredado desde la época de las primeras PC: Los
volúmenes =A= y =B= están reservados para las unidades de disco
flexible; =C= se refiere al disco duro de arranque, y las unidades
posteriores que va detectando el sistema son =D=, =E=, =F=, etc.

Es posible modificar esta nomenclatura y configurar a los discos para
estar en otra ubicación, pero muchas aplicaciones dependen ya de este
comportamiento y configuración específicos.

#+html: <div class="figure">
#+attr_latex: width=0.7\textwidth
#+caption: Vista de un sistema de archivos Windows
#+begin_src dot :exports results :file ltxpng/montaje_windows.png
  digraph G {
          rankdir=LR;
          subgraph cluster0 {
                  label = "C:"
                  color = lightblue;
                  style="filled"
                  raiz_c [shape=box, label="\\"];
                  windows [shape=box, label="Windows"];
                  archprog [shape=box, label="Archivos de programa"]
                  docset [shape=box, label="Documents and Settings"]
                  usr1 [shape=box, label="Usuario 1"]
                  desktop [shape=box, label="Escritorio"]
                  menu [shape=box, label="Menú Inicio"]
                  misdoc [shape=box, label="Mis documentos"]
                  system32 [shape=box];
                  prog1 [label="prog1.exe"];
                  prog2 [label="prog2.exe"];
                  prog3 [label="prog3.exe"];
  
                  raiz_c -> windows;
                  windows -> system32;
                  system32 -> prog1;
                  system32 -> prog2;
                  system32 -> prog3;
                  raiz_c -> archprog;
                  raiz_c -> docset;
                  docset -> usr1;
                  usr1 -> desktop;
                  usr1 -> menu;
                  usr1 -> misdoc;
          }
  
          subgraph cluster1 {
                  label = "D:"
                  color = yellow;
                  style="filled"
                  raiz_d [shape=box, label="\\"];
                  doc [shape=box, label="Documentos"]
                  pres [shape=box, label="Presentaciones"]
                  doc1 [label="Avance del proyecto.docx"]
                  doc2 [label="Datos 2000-2004.doc"]
                  pres1 [label="Presentación.ppt"]
  
                  raiz_d -> doc;
                  raiz_d -> pres;
                  doc -> doc1;
                  doc -> doc2;
                  pres -> pres1;
          }
  
          raiz [shape=box, label="<Mi PC>"];
          raiz -> COM1;
          raiz -> CON;
          raiz -> LPT1;
          raiz -> raiz_c;
          raiz -> raiz_d;
  
          COM1 [shape=note, label="COM1:"]
          LPT1 [shape=note, label="LPT1:"]
          CON [shape=note, label="CON:"]
  }
#+end_src

#+results:
[[file:ltxpng/montaje_windows.png]]
#+html: <p align="center">Vista de un sistema de archivos Windows</p></div>

** Sistemas de archivos remotos

Uno de los principales y primeros usos que se dio a la comunicación en
red fue el de compartir archivos entre computadoras independientes. En
un principio, esto se realizaba de forma /explícita/, con
transferencias manuales a través de programas dedicados a ello, como
sería hoy en día el FTP.

Por otro lado, desde mediados de los 1980, es posible realizar estas
transferencias de forma /implícita/ y /automática/, empleando
/sistemas de archivos sobre la red/ (o lo que es lo mismo, /sistemas
de archivos remotos/).  Estos se nos presentan como caso particular de
la /abstracción de sistemas no-físicos/ que mencionamos en la sección
anterior: Si bien el sistema operativo no tiene acceso /real/ a los
archivos y directorios que le solicitará el usuario, a través de los
módulos de red, sabe cómo obtenerlos y presentarlos /como si fueran
locales/.

Al hablar de sistemas de archivos en red, casi siempre lo haremos
siguiendo un /modelo cliente-servidor/. Estos términos no se refieren
a las prestaciones relativas de una computadora, sino al rol que ésta
juega /dentro de cada conexión/ — Esto es, designamos como /cliente/ a
la computadora que solicita un servicio, y como /servidor/ a la que lo
provee; es frecuente que dos computadoras sean tanto servidor como
cliente la una de la otra en distintos servicios.

*** Network File System (NFS)

El /Sistema de Archivos en Red/ (/Network File System/, mejor conocido
por sus siglas, /NFS/) fue creado por Sun Microsystems, y desde 1984
forma parte de su sistema operativo — Resultó una implementación tan
exitosa que a los pocos años formaba parte de todos los sistemas tipo
Unix.

NFS está construido sobre el mecanismo /RPC/ (/Remote Procedure Call/,
/Llamada a Procedimientos Remotos/), un mecanismo de mensajes y manejo
básico de sesión que actúa como una capa superior a TCP/IP, incluyendo
facilidades de /descubrimiento de recursos/ y /abstracción/. RPC puede
ser comparado con protocolos como /DCE/RPC/ de OSF, /DCOM/ de
Microsoft, y hoy en día, /SOAP/ y /XML-RPC/. Estos mecanismos permiten
al programador delegar en un /servicio/ el manejo de las conexiones de
red, particularmente (en el caso que en este momento nos importa) la
persistencia de sesiones en caso de desconexión, y limitar su atención
a una /conexión establecida/.

La motivación de origen para la creación de NFS fue presentar una
solución que aprovechara el hardware existente y centralizara la
administración: Ofrecer las facilidades para contar con redes donde
hubiera un /servidor de archivos/, y donde las estaciones de trabajo
tuvieran únicamente una instalación básica,[fn:: Incluso manejando
estaciones de trabajo /diskless/, esto es, computadoras sin disco
duro, cuyo sistema de arranque tiene la capacidad de solicitar al
servidor le envíe incluso el núcleo del sistema operativo que
ejecutará] y el entorno de usuario completo estuviera disponible en
cualquiera de las estaciones.

NFS ofrece sobre la red un sistema de archivos con la semántica Unix
completa — Para montar un sistema remoto, basta montarlo[fn:: Para
montar un sistema remoto, usaríamos un comando como =mount
archivos.unam.mx:/home /home= ] y usarlo como si fuera local. El
manejo de permisos, usuarios, e incluso las ligas duras y simbólicas
se manejan exactamente como se haría localmente.

NFS es un protocolo muy ligero — No implementa cifrado ni
verificaciones adicionales, pero al día de hoy, es uno de los mejores
mecanismos para el envío de grandes cantidades de información — Pero
siempre en redes que sean /completamente confiables/.

Ahora, NFS se presenta como uno de los componentes de una solución
completa. Dado que se espera que la información de usuarios y permisos
sea /consistente/ en todos los clientes; Sun ofrecía también un
esquema llamado /Yellow Pages/ (posteriormente renombrado a NIS,
/Network Information System/) para compartir la información de
autenticación y listas de usuarios.

La desventaja, en entornos sin NIS, es que los permisos se manejan
según el ID numérico del usuario. Si en diferentes sistemas el mismo
usuario tiene diferentes IDs, los permisos no coincidirán. Es más,
dado que el control de acceso principal es únicamente por dirección
IP, para tener acceso irrestricto a los archivos de otros usuarios en
NFS basta con tener control pleno de una computadora cualquiera en la
red para poder /asumir o usurpar la identidad/ de cualquier otro
usuario.

Por último, para garantizar que las escrituras a archivos se llevaran
a cabo cuando eran solicitadas (en contraposición a asumir éxito y
continuar), todas las escrituras en un principio sobre NFS eran
manejadas de forma síncrona, esto es, tras grabar un archivo, el
cliente no continuaba con la ejecución hasta no tener confirmación por
parte del servidor de que los datos estaban ya guardados en
disco.

Versiones posteriores del protocolo mejoraron sobre los puntos débiles
aquí mencionados. Al día de hoy, casi 30 años después de su
presentación, NFS es aún un sistema de archivos en red muy ampliamente
empleado.

*** Common Internet File System (CIFS)

El equivalente a NFS en los entornos donde predominan los sistemas
Windows es el protocolo CIFS (/Common Internet File System/, Sistema
de Archivos Común para Internet). Aparece en los sistemas primarios de
Microsoft alrededor de 1990[fn:: El desarrollo de SMB nació como /LAN
Manager/, originalmente para OS/2], originalmente bajo el nombre SMB
(/Server Message Block/, /Bloque de Mensaje del Servidor/).

Las primeras implementaciones estaban orientadas al protocolo /NBF/,
frecuentemente conocido como /NetBEUI/, aunque a partir de Windows
2000 se ha reimplementado completamente para operar sobre TCP/IP. Es a
partir de este momento que se le comienza a denominar /CIFS/, aunque
el nombre /SMB/ sigue siendo ampliamente utilizado.[fn:: Es a este
nombre que la implementación de CIFS para sistemas Unix, /Samba/,
fue llamado de esta manera.]

CIFS se ajusta mucho más a la semántica de los sistemas MS-DOS y
Windows, aunque dado el lapso de tiempo que ha existido, ha pasado por
varios cambios fundamentales, que al día de hoy complican su uso.

Para tener acceso a un volumen compartido por SMB se introdujo el
comando =NET=;[fn:: Este comando es empleado en MS-DOS, pero está
también disponible en Windows, y al día de hoy es una de las
principales herramientas para administrar usuarios.] basta indicar a
DOS o Windows =NET USE W: \\servidor\directorio= para que el recurso
compartido bajo el nombre =directorio= dentro del equipo conocido como
=servidor= aparezca en el árbol /Mi PC/, y el usuario pueda emplear
sus contenidos como si fuera un sistema de archivos local.

Cuando fue introducido al mercado, los sistemas Microsoft no manejaban
aún el concepto de usuarios, por lo que la única medida de seguridad
que implementaba SMB era el manejo de hasta dos contraseñas por
directorio compartido: Con una, el usuario obtenía acceso de sólo
lectura, y con la otra, de lectura y escritura. Tras la aparición de
Windows NT, se agregó un esquema de identificación por
usuaro/contraseña, que posibilita el otorgamiento de permisos con una
/granularidad/ mucho menor.[fn:: Esto significa, que puede
controlarse el acceso permitido más finamente, a nivel archivo
individual y usuario individual.]

SMB fue pensado originalmente para una red /pequeña/, con hasta un par
de decenas de equipos. La mayor parte de los paquetes eran enviados en
modo /de difusión/ (/broadcast/), por lo que era fácil llegar a la
saturación, y no existía un esquema centralizado de resolución de
nombres, con lo que era frecuente /no encontrar/ a determinado
equipo.

Los cambios que CIFS presenta a lo largo de los años son muy
profundos. Las primeras implementaciones presentan fuertes problemas
de confiabilidad, rendimiento y seguridad, además de estar planteadas
para su uso en un sólo tipo de sistema operativo; al día de hoy, estos
puntos han todos mejorado fuertemente. En sistemas Unix, la principal
implementación, /Samba/, fue creada haciendo ingeniería inversa sobre
el protocolo; a lo largo de los años, se ha convertido en un esquema
tan robusto que es hoy por hoy tomado como implementación refrencia.

*** Sistemas de archivos distribuídos: Andrew File System (AFS)

Los dos ejemplos de sistema de archivos en red presentados hasta ahora
comparten una visión /tradicional/ del modelo cliente-servidor: Al ver
el comando que inicializa una conexión, e incluso a ver la
información que guarda el núcleo del cliente respecto a cualquiera de
los archivos, resulta claro cuál es el servidor para cada uno de
ellos.

/Andrew File System/, desarrolaldo en la Carnegie Mellon
University[fn:: Como parte del /Proyecto Andrew/, denominado así por
el nombre de los fundadores de esta universidad: Andrew Carnegie y
Andrew Mellon] y publicado en 1989, plantea presentar un verdadero
/sistema de archivos distribuído/, en el cual los /recursos
compartidos/ no tengan que estar en un servidor en particular, sino
que un conjunto de equipos se repartan la carga (esto es,
/agnosticismo a la ubicación/). AFS busca también una /fácil
escalabilidad/, la capacidad de agregar tanto espacio de
almacenamiento como equipos con rol de servidor. AFS permite inclusive
migrar completamente un volumen mientras está siendo empleado, de
forma transparente.

Ante la complejidad e inestabilidad adicional que nos presentan con
tanta frecuencia las redes grandes[fn:: El uso típico de AFS se
planteaba para organizaciones grandes, del órden de decenas de miles
de estaciones] (y lo hacían mucho más hace 30 años): AFS debe operar
tan confiablemente como sea posible, /incluso sin la certeza de que la
red opera correctamente/.

AFS construye fuertemente sobre el modelo de /tickets/ y credenciales
de /Kerberos/, pero se aleja sensiblemente de la semántica de
operación de archivos que hasta ahora hemos manejado. Muchos eventos,
operaciones y estados van ligados al /momento en el tiempo/ en que se
presentan, a través de un /modelo de consistencia débil/ (/weak
consistency model/). Muy a grandes rasgos, esto significa que:

- Cuando se abre un archivo, éste se copia completo al cliente. Todas
  las lecturas /y escrituras/ (a diferencia de los esquemas
  tradicionales, en que éstas son enviadas al servidor /lo antes
  posible/ y de forma síncrona) se dirigen únicamente a la copia
  local.

- Al cerrar el archivo, éste se copia de vuelta al /servidor de
  origen/, el cual se /compromete/ a notificar a los clientes si un
  archivo abierto fue modificado (esto es, a /hacer una llamada/ o
  /callback/). Los clientes pueden entonces intentar incorporar los
  cambios a su versión de trabajo, o continuar con la copia ya
  obtenida — Es /esperable/ que si un segundo cliente realiza alguna
  modificación, incorpore los cambios hechos por el primero, pero esto
  se deja a la implementación del programa en cuestión.

Esto significa en pocas palabras que los cambios a un archivo abierto
por un usuario no son visibles a los demás de inmediato; sólo una vez
que se cierra un archivo, los cambios hechos a éste son puestos a
disposición de las sesiones abiertas actuales, y sólo son enviados
como /versión actual/ a las sesiones abiertas posteriormente.

Con este cambio semántico, debe quedar claro que AFS no busca ser un
sistema para todo uso ni un reemplazo universal de los sistemas de
archivos locales, en contraposición de los sistemas de archivos
centralizados. AFS no plantea en ningún momento una operación
/diskless/. Bajo el esquema aquí descrito, las lecturas y escrituras
resultan baratas, porque se realizan exclusivamente sobre el caché
local, pero abrir y cerrar un archivo puede ser muy caro, porque debe
transferirse el archivo completo.

Hay aplicaciones que verdaderamente sufrirían si
tuvieran que implementarse sobre un sistema de archivos distribuído —
Por ejemplo, si una base de datos se distribuyera sobre AFS, la
carencia de mecanismos de bloqueo sobre /secciones/ del archivo, y el
requisito de operar sobre /archivos completos/ harían impracticable
compartir un archivo de uso intensivo y aleatorio.



* Plasmando la estructura en el dispositivo
# <<estructura_en_dispositivo>>
Hasta ahora, hemos visto a los elementos del sistema de archivos tal
como son presentados al usuario final, sin entrar en detalles respecto
a cómo organiza toda esta información el sistema operativo en un
/dispositivo persistente/ — Mencionamos algunas estructuras base, pero
dejándolas explícitamente pendientes de definición. En esta sección
nos ocuparemos de detallar las principales estructuras y mecanismos
empleados para que un sistema de archivos sea, más allá de una
estructura formal ideal, una entidad guardada en un dispositivo.

A lo largo de la historia del cómputo, el almacenamiento no siempre
fue hecho en discos (dispositivos giratorios de acceso aleatorio). En
un principio, los medios principales de acceso estrictamente
secuencial (tarjetas perforadas, cintas de papel, cintas magnéticas),
y desde hace algunos años, estamos viendo una migración a
/almacenamiento de estado sólido/, a dispositivos sin partes móviles
que guardan la información en un tipo particular de memoria.

Los sistemas de archivo están en general desarrollados pensando en
/discos/, y a lo largo de esta sección, nos referiremos como /el
disco/ al medio de almacenamiento persistente en el cual esté
plasmado el sistema de archivos. Hacia el final de la sección
abordaremos algunos de los aspectos que debemos considerar al hablar
de sistemas de archivos respaldados en medios distintos a un
disco.

Mientras tanto, mantengamos una visión aún bastante idealizada y
abstracta: Asumamos que un /disco/ es visto por el sistema operativo
como un arreglo muy grande de /bloques/ de tamaño fijo, cada uno de
ellos /directamente direccionable/, y definamos los conceptos que nos
permitirán representar en dicho disco nuestro sistema operativo:

- Partición :: Una subdivisión de un disco, por medio de la cual el
               administrador/usuario del sistema puede definir la
               forma en que se emplea el espacio que éste ofrece. Un
               disco puede tener varias particiones, y cada una de
               ellas puede tener un sistema de archivos independiente.

- Volumen :: Colección de bloques /inicializados/ con un sistema de
             archivos que pueden presentarse al usuario como una
             unidad. Típicamente un volumen coincide con una
             partición (pero no siempre es el caso).

	     El volumen se /describe/ ante el sistema operativo en el
             /bloque de control de volumen/, también conocido como
             /superbloque/ en Unix, o /Tabla Maestra de Archivos/
             (/Master File Table/) en NTFS.

- Directorio raiz :: La estructura base con la relación entre nombres
     de archivo y números de /i-nodo/. Típicamente sólo almacena los
     archivos que están en el /primer nivel jerárquico/ del sistema, y
     los directorios derivados son únicamente referenciados desde
     éste.

     El directorio normalmente incluye sólo el nombre de cada uno de
     los archivos y el número de /i-nodo/ que lo describe, todos los
     /metadatos/ adicionales están en los respectivos /i-nodos/.

- Metadatos :: Recibe este nombre toda la información /acerca de/ un
               archivo que /no es/ el archivo mismo. Por ejemplo, el
               nombre, tamaño o tipo del archivo, su propietario, el
               control de acceso, sus fechas de creación, último
               acceso y modificación, ubicación en disco, etc.

- I-nodo :: Del inglés /i-node/, /information node/ (nodo de
            información); en los sistemas tipo Windows, normalmente se
            le denomina /bloque de control de archivo/ (/FCB/). Es la
            estructura en disco que guarda los /metadatos/ de cada
            archivo, proporcionando un vínculo entre la /entrada en el
            directorio/ y la información que referida.

	    La información almacenada incluye todos los metadatos
            relacionados con el archivo /a excepción del nombre/
            (mismo que radica únicamente en el /directorio/): Los
            permisos y propietarios del archivo, sus fechas de
            creación, última modificación y último acceso, y la
            /relación de bloques/ que ocupa en el disco. Veremos más
            adelante los esquemas más comunes para presentar esta
            relación de bloques.

- /Mapa de bits/ de espacio libre :: La función del bitmap es poder gestionar
     el espacio libre del disco. Recordemos que el disco se presenta
     asignado por /bloques/, típicamente de 4096 bytes — En el bitmap
     cada bloque se representa con un bit, con lo que aquí podemos
     encontrar de forma compacta el espacio ocupado y disponible, así
     como el lugar adecuado para crear un nuevo archivo.

     El bitmap para un disco de 100GB puede, de esta manera,
     representarse en 23MB ($100 \times 10^9 \over 4096$), cantidad
     que puede razonablemente mantener en memoria un sistema de
     escritorio promedio hoy en día.

     Veremos más adelante algunas estructuras avanzadas que permiten
     mayor eficiencia en este sentido.

** Diferentes sistemas de archivos

Un sistema operativo puede dar soporte a varios distintos sistemas de
archivos; muchas razones pueden influir para elegir qué sistema de
archivos emplearemos para nuestra información — Algunas razones para
elegir a uno u otro son que el rendimiento de cada uno puede estaar
afinado ante diferentes patrones de carga, necesidad de emplear un
dispositivo móvil para intercambiar datos con distintos sistemas, e
incluso restricciones de hardware.[fn:: Por ejemplo, los /cargadores
de arranque/ en algunas plataformas requieren poder leer el volumen
donde está alojada la imágen del sistema operativo — Lo cual obliga a
que esté en un sistema de archivos nativo a la plataforma.]

A lo largo de esta sección iremos comentando cómo los principales
conceptos que revisaremos se han implementado en distintos sistemas de
archivos; nos referiremos principalmente a una familia de sistema de
archivos simple de comprender, aunque muestra claramente su edad: La
familia FAT. Ilustraremos algunos ejemplos específicos empleando
también otros sistemas de archivos.

El sistema FAT fue creado hacia fines de los 1970, y muestra claras
evidencias de haber sido pensado para discos flexibles. Sin embargo,
a través de varias extensiones que se han presentado con el paso de
los años (algunas con compatibilidad hacia atrás, otras no), sigue
siendo uno de los sistemas más empleados al día de hoy, a pesar de
que ya no es recomendado como sistema primario por ningún sistema
operativo de escritorio.

Si bien FAT tuvo su mayor difusión con los sistemas operativos de la
familia MS-DOS, es un sistema de archivos nativo para una gran
cantidad de otros sistemas, lo cual se hace obvio al revisar el
soporte a atributos extendidos que maneja.

** El volumen

Lo primero que requiere saber el sistema operativo para poder montar
un volumen es su estructura general: En primer término, de qué /tipo/
de sistema de archivos se trata, y acto seguido, la descripción básica
del mismo: Su extensión, el tamaño de los /bloques lógicos/ que
maneja, si tiene alguna /etiqueta/ que describa su función ante el
usuario, etc. Esta información está contenida en el /bloque de control
de volumen/, también conocido como /superbloque/ o /tabla maestra de
archivos/.[fn:: Y aquí hay que aclarar: El superbloque /no contiene a
los archivos/, ni siquiera a las estructuras que apuntan hacia ellos,
sólo describe al volumen para que pueda ser montado]

Tras leer la información del superbloque, el sistema operativo
determina en primer término si puede proceder — Si no sabe cómo
trabajar con el sistema de archivos en cuestión, por ejemplo, no
puede presentar información útil alguna al usuario.

Habíamos mencionado ya que el tamaño de bloques (típicamente, 512
bytes) es establecido por el hardware. Es muy común que, tanto por
razones de eficiencia como para alcanzar a direccionar mayor espacio,
el sistema de archivos /agrupe/ a varios bloques físicos en un bloque
lógico. Veremos más acerca de en base a qué determina su tamaño de
bloques cada sistema de archivos en la siguiente sección, al hablar de
[[#el_directorio][el directorio]].

Dado que describir al volumen es la más fundamental de las
operaciones que podamos realizar, muchos sistemas de archivos
mantienen /copias adicionales/ del superbloque, a veces dispersas a
lo largo del sistema de archivos, para poder recuperarlo en caso de
que se corrompa.

En el caso de FAT, el volumen indica no sólo la /generación/ del
sistema de archivos que se está empleando (FAT12, FAT16 o FAT32, en
los tres casos denominados así por la cantidad de bits para
referenciar a cada uno de los bloques lógicos o /clusters/), sino el
tamaño de los clusters, que puede ir desde los 2 y hasta los 32 Kb.

*** Volúmenes /crudos/

Si bien una de los principales tareas de un sistema operativo es
la organización del espacio de almacenamiento en sistemas de
archivos y su gestión para compartirse entre diversos usuarios y
procesos, hay algunos casos en que un dispositivo orientado a bloques
puede ser puesto a disposición de un proceso en particular para que
éste lo gestione directamente. Este modo de uso se denomina el de
/dispositivos crudos/ o /dispositivos en crudo/ (/raw devices/).

Podemos encontrar dos casos de uso primarios hoy en día para
dispositivos orientados a bloques no administrados a través de la
abstracción de los sistemas de archivos:

- Espacio de intercambio :: Como vimos en la [[04_administracion_de_memoria.org#acomodo_de_paginas][unidad anterior]], la
     gestión de la porción de la memoria virtual que está en disco es
     mucho más eficiente cuando se hace sin cruzar por la abstracción
     del sistema operativo — Esto es, cuando se hace en un volumen en
     crudo. Y si bien el gestor de memoria virtual es parte innegable
     del sistema operativo, en un sistema /microkernel/ puede estar
     ejecutándose como proceso de usuario.

- Bases de datos :: Las bases de datos relacionales pueden incluir
                    volúmenes muy grandes de datos estrictamente
                    estructurados. Algunos gestores de bases de
                    datos, como Oracle, MaxDB o DB2, recomiendan a
                    sus usuarios el uso de volúmenes crudos, para
                    optimizar los accesos a disco sin tener que cruzar
                    por tantas capas del sistema operativo.

		    La mayor parte de los gestores de bases de datos
                    desde hace varios años no manejan esta modalidad,
                    sin embargo, por la complejidad adicional que
                    supone para el administrador del sistema y por lo
                    limitado de la ventaja en rendimiento que supone
                    hoy en día, aunque es indudablemente un tema que
                    se presta para discusión e investigación.

** El directorio y los i-nodos
# <<el_directorio>>

El directorio es la estructura que relaciona a los archivos como son
presentados al usuario –identificados por una ruta y un nombre– con
las estructuras que los describen ante el sistema operativo — Los
/i-nodos/.

A lo largo de la historia de los sistemas de archivos, se han
implementado muy distintos esquemas de organización.

*** El directorio raiz

Una vez que el sistema de archivos está montado, todas las referencias
a archivos dentro de éste deben pasar a través del directorio. El
directorio raiz está siempre en una ubicación /bien conocida/ dentro
del sistema de archivos — Típicamente vamos a encontrarlo al inicio
del volumen, aunque en los 1980, los diseñadores del sistema AmigaOS
decidieron ubicar al directorio en el sector /central/ de los
volúmenes. Un disco flexible tenía 80 /pistas/ (típicamente
denominadas /cilindros/ cuando hablamos de discos duros), con lo que,
al ubicar al directorio en la pista 40, el tiempo promedio de
movimiento de cabezas para llegar a él se reducía a la mitad. Si
todas las operaciones de abrir un archivo tienen que pasar por el
directorio, esto resultaba en una mejoría muy significativa.

El directorio es la estructura que determina el formato que debe
seguir el nombre de cada uno de los archivos y directorios: Es común
que en un sistema moderno, el nombre de un archivo pueda tener hasta
256 caracteres, incluyendo espacios, caracteres acentuados. Algunos
sistemas de archivos son /sensibles a mayúsculas/, como es el caso de
los sistemas nativos a Unix (el archivo =ejemplo.txt= es distinto de
=Ejemplo.TXT=), mientras que otros no lo son, como es el caso de NTFS
y VFAT (=ejemplo.txt= y =Ejemplo.TXT= son idénticos ante el sistema
operativo).

Todas las versiones de FAT siguen para los nombres de archivos un
esquema claramente antiguo: Los nombres de archivo pueden medir hasta
8 caracteres, con una extensión opcional de 3 caracteres más, dando un
total de 11. El sistema no sólo no es sensible a mayúsculas y
minúsculas, sino que todos los nombres deben guardarse completamente
en mayúsculas, y permite sólo ciertos caracteres no
alfanuméricos. Este sistema de archivos no implementa la separación
entre directorio e i-nodo, que hoy es la norma, por lo que cada una de
las entradas en el directorio mide exactamente 32 bytes. Como es de
esperarse en un formato que ha vivido tanto tiempo y ha pasado por
tantas generaciones como FAT, algunos de estos campos han cambiado
substancialmente sus significados:

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Formato de la entrada del directorio bajo FAT (Mohammed, 2007)
#+begin_src ditaa :file ltxpng/directorio_fat.png :cmdline -E
 |    8    |  3  | 1 | 1 |    5     |   2    |  2   |   4   |    2    |   4    |
 +---------+-----+---+---+----------+--------+------+-------+---------+--------+
 | ARCHIVO | EXT |   |   | Creacion | Acceso |      | Modif | Cluster | Tamaño |
 +---------+-----+-+-+-+-+----------+--------+--+---+-------+---------+--------+
                   ^   ^                        ^
                   |   |                        |
         Atributos-+   |  Cluster alto (FAT32)--+
         Reservado-----+
#+end_src
#+html: <p align="center">Formato de la entrada del directorio bajo FAT (Mohammed, 2007)</p></div>

La extensión VFAT fue agregada con el lanzamiento de Windows 95. Esta
extensión permitía que, si bien el nombre /real/ de un archivo
seguiría estando limitada al formato presentado, pudieran agregarse
entradas adicionales al directorio utilizando el atributo de /etiqueta
de volumen/ de maneras que un sistema MS-DOS debiera ignorar.

Esto presenta una complicación adicional al hablar del directorio
/raiz/ de una unidad: Si bien los directorios derivados no tienen este
límite, al estar el directorio raiz ubicado en una sección fija del
disco, tiene una longitud límite máxima: En un disco flexible (que
hasta el día de hoy, por su limitada capacidad, se formatea bajo
FAT12), desde el bloque 20 y hasta el 33, esto es, 14 bloques. Con un
tamaño de sector de 512 bytes, el directorio raiz mide $512 \times 14
= 7168$ bytes, esto es, $7168 \over 32 = 224$ entradas como máximo. Y
si bien esto no nos suena a muy limitado, [[https://en.wikipedia.org/wiki/File_Allocation_Table#VFAT_long_file_names][ocupar cuatro entradas por
archivo]] cuando tiene un nombre medianamente largo va reduciendo
fuertemente el panorama.

El problema no resulta tan severo como podría parecer: Para FAT32, el
directorio raiz ya no está ubicado en un espacio reservado, sino que
como parte del espacio de datos, por lo cual es extensible en caso de
requerirse.

#+caption: Entradas representando archivo con nombre largo bajo VFAT (Peter Clark)
#+attr_html: width="652" height="331"
#+attr_latex: width=\textwidth
[[./img/directorio_vfat.png]]

Los primeros sistemas de archivos estaban pensados para unidades de
muy baja capacidad; por mucho tiempo, las implementaciones del
directorio eran simplemente listas lineales con los archivos que
estaban alojados en el volumen. Como vimos, muchos de estos primeros
sistemas no contemplaban directorios jerárquicos, sino que presentaban
un único espacio /plano/ de nombres; cuando estos sistemas fueron
evolucionando para soportar directorios anidados, por compatibilidad
hacia atrás (y por consideraciones de rendimiento que veremos a
continuación) siguieron almacenando únicamente al directorio raiz en
esta posición privilegiada, y manejando a todos los directorios que
derivaran de éste como si fueran archivos, repartidos por el disco.

En un sistema que implementa los directorios como listas lineales,
entre más archivos haya, el tiempo que toma casi cualquier operación
se incrementa linealmente (dado que potencialmente tenemos que leer
al directorio completo para encontrar a un archivo). Y las listas
lineales presentan un segundo problema: Cómo reaccionar cuando se
/llena/ el espacio que tienen asignado.

Como ya mencionamos, FAT asigna un espacio fijo al directorio raiz,
pero los subdirectorios pueden crecer abritrariamente. Un
subdirectorio es básicamente un archivo con un tipo especial de
archivo — Si el cuarto bit del byte 12 de una entrada de directorio
está encendido, los datos correspondientes al archivo serán
interpretados como una tabla de directorios.

Queda claro que FAT es un sistema heredado, y que exhibe muchas
prácticas que ya no vemos en diseños modernos de sistemas de
archivos. Vimos que dentro de la entrada de directorio de cada archivo
está prácticamente su /i-nodo/ completo: La información de permisos,
atributos, fechas de creaación — Y muy particularmente, el apuntador
al cluster de inicio (bytes 26-28, mas los 20-22 para FAT32). Esto
exhibe una de las grandes debilidades de FAT: La tendencia a la
fragmentación.

La familia FAT obtiene su nombre de la Tabla de Asignación de Archivos
(/File Allocation Table/), que aparece antes del directorio, en los
primeros sectores del disco.[fn:: Tan importante es esta tabla que se
guarda /por duplicado/, e incluso por triplicado, dependiendo de la
versión de FAT.] Cada byte de la FAT representa a un cluster en el
área de datos; cada entrada en el directorio indica, en su campo
/cluster/, cuál es el primer cluster que conforma al archivo. Ahora
bien, conforme se usa un disco, y los archivos crecen y se eliminan,
y van llenando los espacios vacíos que van dejando, FAT va asignando
espacio /conforme encuentra nuevos clusters/, sin cuidar que sea
espacio continuo. Los apuntadores al /siguiente cluster/ se van
marcando en la tabla, cluster por cluster, y el último cluster de
cada archivo recibe el valor especial (dependiendo del tipo de FAT)
=0xFFF=, =0xFFFF= o =0xFFFFFFFF=.

Ahora bien, si los directorios son sencillamente archivos que reciben
un tratamiento especial, estos son también susceptibles a la
fragmentación. Dentro de un sistema Windows 95 o superior (empleando
VFAT), con directorios anidados a cuatro o cinco niveles como lo
establece su jerarquía estándar, el puro hecho de recorrerlos para
encontrar determinado archivo puede resultar muy penalizado por la
fragmentación.

*** La eliminación de entradas del directorio

Sólo unos pocos sistemas de archivos guardan sus directorios ordenados
— Si bien esto facilitaría las operaciones más frecuentes que se
realizan sobre de ellos (en particular, la búsqueda — Cada vez que un
directorio es recorrido hasta encontrar un archivo tiene que leerse
potencialmente completo), mantenerlo ordenado ante cualquier
modificación resultaría mucho más /caro/, dado que tendría que
reescribirse el directorio completo al crearse o eliminarse un archivo
dentro de éste, y lo que es más importante, más /peligroso/, dado que
aumentaría el tiempo que los datos del directorio están en un estado
inconsistente, aumentando la probabilidad de que ante una interrupción
repentina (fallo de sistema, corte eléctrico, desconexión del
dispositivo, etc.) se presentara corrupción de la información llevando
a pérdida de datos.

Ordenar las entradas del directorio teniendo sus contenidos ya en
memoria y, en general, diferir las modificaciones al directorio
resulta mucho más conveniente en el caso general. Esto vale también
para la eliminación de archivos — Presentamos, pues, la estrategia que
sigue FAT . Recordemos que el diseño de FAT fue aún cuando el medio
principal de almacenamiento era el disco flexible, decenas de veces
más lento que el disco duro, y con mucha menor confiabilidad.

Cuando se le solicita a un sistema de archivos FAT eliminar un
archivo, éste no se borra del directorio, ni su información se libera
de la tabla de asignación de archivos, sino que se /marca/ para ser
ignorado, reemplazando el primer caracter de su nombre por =0xE5=. Ni
la entrada de directorio, ni la /cadena/ de clusters correspondiente
en las tablas de asignación,[fn:: Abordaremos este tema en breve, al
hablar de [[#tablas_fat][las tablas de asignación de archivos]]] son eliminadas — Sólo son marcadas como
/disponibles/. El espacio de almacenamiento que el archivo eliminado
ocupa debe, entonces, ser /sumado/ al espacio libre que tiene el
volumen. Es apenas cuando se crea un nuevo archivo empleando esa misma
entrada que el sistema operativo marca /realmente/ como desocupados
los clusters en la tabla de asignación.[fn:: Pero, claro, estos
clusters podrían mantenerse como ocupados /por el nuevo archivo/,
ahorrando el trabajo de volver a asignarlos]

Es por esto que desde los primeros días de las PC existen tantas
herramientas de recuperación (o /des-borramiento/) de archivos:
Siempre que no haya sido creado un archivo nuevo que ocupe la entrada
de directorio en cuestión, recuperar un archivo es tan simple como
volver a ponerle el primer caracter a su nombre.

Este es un ejemplo de un /mecanismo flojo/ (en contraposición de los
/mecanismos ansiosos/, como los vistos en la sección de [[04_administracion_de_memoria.org#pag_sobre_demanda][paginación
sobre demanda]]). Eliminar un archivo toma un trabajo mínimo, mismo que
es /diferido/ al momento de reutilización de la entrada de directorio.

* Esquemas de asignación de espacio

Hasta ahora hemos mencionado que la /entrada de directorio/ apunta al
punto donde inicia el espacio empleado por el archivo, pero no hemos
detallado en cómo se implementa la asignación y administración de
dicho espacio. Haremos un breve repaso de los tres principales
mecanismos, después de lo cual detallaremos cómo es la implementación
de FAT, hablando un poco de sus virtudes y debilidades.

** Asignación contigua

Los primeros sistemas de archivos en disco empleaban un esquema de
/asignación contigua/. Para implementar un sistema de archivos de este
tipo, no haría falta el contar con una /tabla de asignación de
archivos/: Bastaría con la información que vimos que forma parte del
directorio de FAT — La extensión del archivo y la dirección de su
primer cluster.

#+html: <div class="figure">
#+attr_latex: width=0.7\textwidth
#+caption: Asignción contigua de archivos: Directorio con inicio y longitud
#+begin_src ditaa :file ltxpng/fs_asignacion_contigua.png :cmdline -E
+------------------------+   Directorio
| {s} cFFF               |   +----+
|  0    4    8    B    F |   |cRED+-->0x30 + 6
|  +------+----+-------+ |   +----+
| 3| cRED |cYEL|cGRE   | |   |cYEL+-->0x36 + 4
|  +------+----+ +-----+ |   +----+
| 4|             |cBLU | |   |cGRE+-->0x3A + 17
|  +-------+-----+--+--+ |   +----+
| 5|cBLU   | cFFF   |  | |   |cBLU+-->0x4B + 9
|  +-------+--------+  | |   +----+
| 6|       cPNK        | |   |cPNK+-->0x5C + 26
|  |    +--------------+ |   +----+
| 7|    |      cFFF    | |
|  +----+--------------+ |
+------------------------+
#+end_src
#+html: <p align="center">Asignción contigua de archivos: Directorio con inicio y longitud</p></div>

La principal ventaja de este mecanismo de asignación, claro está, es
la simplicidad de su implementación. Brinda además la mejor velocidad
de transferencia del archivo, dado que al estar cada uno de los
archivos en espacio contiguo en el disco, el movimiento de cabezas se
mantiene al mínimo. Sin embargo, este mecanismo se vuelve sumamente
inconveniente en medios que soporten lectura y escritura: Es muy
sensible a la /fragmentación externa/; si un archivo requiere crecer,
debe ser movido íntegramente a un bloque más grande (lo cual toma
demasiado tiempo), y el espacio que libera un archivo en caso de
reducirse su necesidad de espacio queda /atrapado/ entre bloques
asignados; podemos tener mucho más espacio disponible que el que
podamos asignar a un nuevo archivo.

Los esquemas de asignación contigua se emplean hoy en día
principalmente en sistemas de archivo de sólo lectura — Por ejemplo,
lo emplea el sistema principal que utilizan los CD-ROMs, el
/ISO-9660/, dado que está pensado para aprovechar al máximo un espacio
que, una vez grabado, sólo podrá abrirse en modo de sólo lectura.

** Asignación ligada

Un enfoque completamente distinto sería el de /asignación
ligada/. Este esquema brinda mucho mayor flexibilidad al usuario,
sacrificando la simplicidad y la velocidad: Cada entrada en el
directorio apunta a un primer /grupo/ de sectores (o /cluster/), y
éste contiene un apuntador que indica cuál es el siguiente.

Para hacer esto, hay dos mecanismos: El primero, reservar un espacio
al final de cada cluster para guardar el apuntador, y el segundo,
crear una tabla independiente, que guarde únicamente los apuntadores.

En el primer caso, si manejamos clusters de 2048 bytes, y reservamos
los 4 bytes (32 bits) finales de cada uno, nos encontraríamos con una
incomodidad al programador: Frecuentemente, los programadores buscan
alinear sus operaciones con las fronteras de las estructuras
subyacentes, para optimizar los accesos (por ejemplo, evitar que un
sólo registro de base de datos requiera ser leído de dos distintos
bloques en disco). El programador tendría que diseñar sus estructuras
para ajustarse a la poco ortodoxa cantidad de 2044 bytes.

Y más allá de esta inconveniencia, guardar los apuntadores al final de
cada cluster hace mucho más lento el manejo de nuestros archivos: Si
no tenemos en una sola ubicación la relación de clusters que conforman
a un archivo, para propósitos prácticos, todas las transferencias
tendrán que ser /secuenciales/: Si queremos llegar directamente a
determinado bloque del archivo, habrá que atravesar todos los bloques
previos para encontrar su ubicación.

Particularmente por este segundo punto es mucho más común el empleo de
una /tabla de asignación de archivos/ — Y precisamente así es como
opera FAT (de hecho, esta tabla es la que le da su nombre). La tabla
de asignación es un mapa de los clusters, representando a cada uno por
el espacio necesario para guardar un apuntador.

#+html: <div class="figure">
#+attr_latex: width=0.7\textwidth
#+caption: Asignción ligada de archivos: Directorio con apuntador sólo al primer cluster
#+begin_src ditaa :file ltxpng/fs_asignacion_ligada.png :cmdline -E
+---------------------+     Directorio
|     cFFF        {s} |     +----+
|  0       8        F |     |cRED+-->0x30
|  +-------+--------+ |     +----+
| 3|cRED 38|cRED 50 | |     |cBLU+-->0x40
|  +-------+--------+ |     +----+
| 4|cBLU 58|cYEL 60 | |     |cYEL+-->0x48
|  +-------+--------+ |     +----+
| 5|cRED FF|cBLU 78 | |     |cGRE+-->0x88
|  +-------+--------+ |     +----+
| 6|cYEL FF|cFFF 00 | |
|  +-------+--------+ |
| 7|cGRE FF|cBLU FF | |
|  +-------+--------+ |
| 8|cFFF 00|cGRE 70 | |
|  +-------+--------+ |
| 9|cFFF 00|cFFF 00 | |
|  +-------+--------+ |
+---------------------+
#+end_src
#+html: <p align="center">Asignción ligada de archivos: Directorio con apuntador sólo al primer cluster</p></div>

Empleando asignación ligada, tenemos muchas ventajas. En primer lugar,
desaparece la /fragmentación externa/.[fn:: El concepto que manejan los
usuarios en general como /fragmentación/ es muy distinto, y sí se
presenta bajo este esquema: Cada archivo se separa en pequeños
/fragmentos/ que pueden terminar esparcidos por todo el disco,
impactando fuertemente en el rendimiento del sistema]

Ahora, la /asignación ligada/ no sólo resulta más lenta que la
contigua, sino que presenta una mayor /sobrecarga administrativa/: El
espacio desperdiciado para almacenar los apuntadores típicamente es
cercano al 1% del disponible en el medio.

Este esquema también presenta /fragilidad de metadatos/: Si alguno de
los apuntadores se pierde o corrompe, lleva a que se pierda el archivo
/completo/ desde ese punto y hasta su final (y abre la puerta a la
corrupción de otro archivo, si el apuntador queda apuntando hacia un
bloque empleado por éste). Hay dos maneras de mitigar este problema:
El empleado por FAT es guardar una (o, bajo FAT12, dos) copias
adicionales de la tabla de asignación, mismas que el sistema
verificará que se mantengan consistentes. Por otro lado, podría
manejarse una estructura de /lista doblemente ligada/ (en vez de una
/lista ligada/ sencilla) en que cada elemento apunte tanto al
siguiente como al anterior. En ambos casos, sin embargo, la sobrecarga
administrativa se duplica.

** Asignación indexada

Por último, tenemos la /asignación indexada/, el mecanismo empleado
por casi todos los sistemas de archivos modernos. En este esquema, se
crea una estructura intermedia entre el directorio y los datos, única
para cada archivo: el /i-nodo/ (o /nodo de información/). Cada i-nodo
guarda los metadatos y la lista de bloques del archivo, reduciendo la
probabilidad de que se presente la /corrupción de apuntadores/ que
mencionamos al hablar de la asignación ligada.

La sobrecarga administrativa bajo este esquema potencialmente es mucho
mayor: Al asignar el i-nodo, éste se crea ocupando como mínimo un
cluster completo. Para un archivo que quepa en un sólo cluster, esto
es un desperdicio del 100% de espacio; para archivos más grandes, la
sobrecarga relativa disminuye, pero se mantiene siempre superior a la
de la asignación indexada.

#+html: <div class="figure">
#+attr_latex: width=0.9\textwidth
#+caption: Asignción indexada de archivos: Directorio con apuntador al i-nodo (llevado a un i-nodo de tamaño extremadamente ineficiente)
#+begin_src ditaa :file ltxpng/fs_asignacion_indexada.png :cmdline -E
+---------------------+    Directorio        Índices
|{s} cFFF             |    +----+            +--------------------+
|  0        8       F |    |cF00+-->30       |(30)cF66 38, 48, 60 |
|  +--------+-------+ |    +----+            +--------------------+
| 3|cF00    |cF66   | |    |c0F0+-->50
|  +--------+-------+ |    +----+            +--------------------+
| 4|cFFF    |cF66   | |    |c00F+-->88       |(50)c6F6 5B         |
|  +--------+-------+ |    +----+            +--------------------+
| 5|c0F0    |c6F6   | |
|  +--------+-------+ |                      +--------------------+
| 6|cF66    |cFFF   | |                      |(88)c66F 78, 80, 90 |
|  +--------+-------+ |                      +----------+---------+
| 7|cFFF    |c66F   | |                                 |
|  +--------+-------+ |                                 V
| 8|c66F    |c00F   | |                      +----------+---------+
|  +--------+-------+ |                      |(A0)c66F 98         |
| 9|c66F    |c66F   | |                      +--------------------+
|  +--------+-------+ |
| A|c00F    |cFFF   | |
|  +--------+-------+ |
| B|cFFF    |cFFF   | |
|  +--------+-------+ |
+---------------------+
#+end_src
#+html: <p align="center">Asignción indexada de archivos: Directorio con apuntador al i-nodo (llevado a un i-nodo de tamaño extremadamente ineficiente)</p></div>

Un esquema de asignación indexada nos da un mejor manejo de caché que
la asignación ligada: Si bien en dicho caso es común guardar copia de
la tabla de asignación en memoria para mayor agilidad, con la
asignación indexada bastará hacer caché /únicamente de la información
importante/, esto es, únicamente de los archivos que estamos empleando
actualmente. Al hacer caché únicamente de lo que es relevante al
sistema en un momento dado, se da mejor uso a un recurso más escaso
(y, por tanto, valioso): La memoria.

Ahora, ¿qué pasa cuando la lista de clusters de un archivo no cabe en
un i-nodo? Podemos ver este ejemplo en el archivo azul del esquema
ejemplo: En este caso, cada i-nodo puede guardar únicamente tres
apuntadores. Al tener un archivo con cuatro clusters, se hace
necesario extender el i-nodo con una lista adicional. La
implementación más común de este esquema es que, dependiendo del
tamaño del archivo, se empleen apuntadores con los niveles de
indirección que /vayan haciendo falta/.

#+caption: Estructura típica de un i-nodo en Unix (Silberschatz, p. 440)
#+attr_latex: width=0.7\textwidth
[[../img/fs_apuntadores_indirectos.png]]

¿Qué tan grande sería el archivo máximo direccionable bajo este
esquema y únicamente tres indirecciones? Supongamos cantidades
que podríamos encontrar frecuentemente hoy en día: Clusters de 4KB y
direcciones de 32 bits. Esto significa que en un cluster vacío caben
128 apuntadores ($4096 \over 32$). Supongamos también que en el i-nodo
los metadatos ocupan 224 bytes, dejando espacio para 100 apuntadores:

- Un archivo de hasta $(100-3) \times 4KB = 388KB$ puede ser
  representado directamente en el i-nodo, y requeriremos de un sólo
  acceso a disco para obtener su lista de clusters
- Un archivo de hasta $(100-3 + 128) \times 4KB = 900KB$ puede
  representarse con el bloque de indirección sencilla, y obtener su
  lista de clusters nos significa dos accesos a disco adicionales.
- Con el bloque de doble indirección, llegamos a $(100-3 + 128 + (128
  \times 128) ) \times 4KB = 66436KB$, pero aquí ya tendremos que
  hacer hasta 131 accesos a disco. A partir de este punto, el sistema
  operativo reducirá fuertemente el tiempo de acceso si puede lograr
  que todos los clusters que apunten a esta información estén cerca
  unos de otros.
- Empleando triple indirección, llegamos hasta $(100-3 + 128 + (128
  \times 128) + (128 \times 128 \times 128) ) \times 2KB = 8455044
  \approx 8GB$, más de lo que puede representarse en 32 bits. La
  cantidad de bloques que tendríamos que leer, sin embargo, para
  encontrar todos los clusters nos significarían hasta 16516 accesos a
  disco.

** Las tablas en FAT
# <<tablas_fat>>

Volvamos al caso que estamos tomando como ejemplo, el sistema de
archivos FAT. En este sistema, cada entrada del directorio apunta al
primer cluster que ocupa ada uno de los archivos, y se emplea un
esquema de asignación ligada. El directorio tiene también un campo
indicando la /longitud total/ del archivo, pero esto no es empleado
para leer la información, sino para poderla presentar más ágilmente al
usuario.

La estructura fundamental de este sistema de archivos es la tabla de
asignación de archivos (/File Allocation Table/) — Tanto que de ella
toma su nombre FAT. Esta estructura ocupa los primeros sectores del
disco, antes incluso del directorio, y por su importancia, se almacena
por duplicado (los discos flexibles son mucho menos confiables que los
discos duros, y el sistema de archivos fue introducido antes de que la
PC pudiera emplear un disco duro).

Cada entrada de la FAT mide lo que la longitud /correspondiente a su
versión (12, 16 o 32 bits), y puede tener uno de cuatro valores
posibles:

- Libre :: El valor =0x000=, =0x0000= o =0x00000000= (dependiendo de
           la versión de FAT) indica que el cluster está disponible, y
           puede ser asignado por el sistema de archivos cuando haga falta.
- Siguiente :: Cuando el valor es menor hasta =0xFF6=, =0xFFF6= o
               =0xFFFFFFF6=, indica la ubicación del /siguiente
               cluster/ del archivo.
- Dañado :: Si el valor de una entrada es =0xFF7=, =0xFFF7= o
            =0xFFFFFFF7=, indica que el cluster es un espacio del
            disco dañado, y no debe ser utilizado para almacenar datos.
- Fin :: Los valores =0xFFF=, =0xFFFF= o =0xFFFFFFFF= indican que se
         trata del último cluster de un archivo.

Una característica que puede llamar la atención de FAT es que
parecería permitir la fragmentación de archivos /por diseño/: Dado que
el descriptor de cada cluster /debe apuntar/ al siguiente, podemos
asumir que el /caso común/ es que los clusters no ocuparán contiguos
en el disco. Claro está, la tabla puede apuntar a varios clusters
adyacentes, pero el sistema de archivos mismo no hace nada para que
así sea.

#+caption: Ejemplo de entradas en la tabla de asignación de archivos ([[http://www.beginningtoseethelight.org/fat16/index.htm][Peter Clark]])
#+attr_latex: width=\textwidth
[[../img/tabla_fat.png]]

Cuando revisamos el formato del directorio de FAT omitimos un detalle
importante: Revisamos sólamente el directorio raiz, y no mencionamos
cómo es que se implementan los subdirectorios. Los subdirectorios en
FAT son archivos de un /tipo/ especial — Podemos verlos como una
suerte de [[#archivos_estructurados][archivos estructurados]], gestionados por el sistema
operativo. Lo único que distingue a un directorio de un archivo normal
es que, en la entrada que lo describe en su directorio padre, el byte
de /atributos/ (=0x0B=) tiene activado el quinto bit.

Un directorio es almacenado en disto /exactamente/ como cualquier otro
archivo. Si se le asigna únicamente un cluster, y el tamaño del
cluster es pequeño (2KB), podrá almacenar sólo 64 entradas, y cada
cluster adicional le dará 64 entradas más. Y como tal, está sujeto
también a la fragmentación: Conforme se agregan entradas al
directorio, éste crece. Llegado el momento, requiere clusters
adicionales. Y si un directorio termina disperso por todo el disco,
resultará –como cualquier otro archivo– más lento leerlo y trabajar
con él. Siempre que abramos un archivo dentro de un directorio grande,
o que lo recorramos para abrir algún archivo en algún subdirectorio
suyo, tendremos que buscar todos sus fragmentos a lo largo del disco.

Ante estos dos aspectos, no podemos perder de vista la edad que tiene
FAT. Otros sistemas de archivos más modernos han resuelto este
problema a través de los /grupos de asignación/: Los directorios del
sistema son /esparcidos/ a lo largo del volumen, y /se intenta/ ubicar
a los archivos cerca de los directorios desde donde son referidos[fn::
Claro está, en el caso de los archivos que están como /ligas duras/
desde varios directorios, pueden ubicarse sólo cerca de uno de
ellos]. Esto tiene por consecuencia que los archivos que presentan
/cercanía temática/ quedan ubicados cerca unos de otros — Y dado que
es probable que sean empleados aproximadamente al mismo tiempo, esto
reduce las distancias que recorrerán las cabezas. Además, al esparcir
los archivos, se distribuye también mejor el espacio libre, por lo
cual el impacto de los cambios de tamaño de un archivo en lo relativo
a la fragmentación se limita a los que forman parte del mismo bloque
de asignación.

Los sistemas de archivos que están estructurados siguiendo esta lógica
de grupos de asignación no evitan la fragmentación, pero sí la mayor
parte de sus consecuencias negativas. Para mantener este esquema
operando confiablemente, eso sí, requieren de mantener disponibilidad
de espacio — Al presentarse saturación, esta estrategia pierde
efectividad. Para evitar que esto ocurra, es muy frecuente en los
sistemas Unix que haya un cierto porcentaje (típicamente cercano al
5%) del disco que esté disponible únicamente para el administrador —
En caso de que el sistema de archivos pase del 95%, los usuarios no
podrán escribir ya a él, pero el administrador puede efectuar tareas
de mantenimiento para volver a un rango operacional.

# ** Herramientas de comunicación entre procesos

# Muy frecuentemente, dos procesos (relacionados o no en el árbol de
# procesos) tienen que intercambiar información a lo largo de su ciclo
# de vida. Si bien sería posible hacerlo a través de una interfaz de
# memoria compartida y envío de mensajes, muchas veces es más fácil
# emplear un archivo como si fuera un dispositivo de datos o una
# conexión en red. En Unix contamos con los siguientes tipos de archivo
# para este fin:

# - /Named pipes/ :: Se traduciría literalmente como /tuberías con
#                    nombre/. Representan un mecanismo de IPC
#                    (comunicación entre procesos) que permite que dos
#                    procesos no relacionados se comuniquen de forma
#                    unidireccional: Uno abre el archivo para escritura,
#                    el otro para lectura, y lo que el primero
#                    "deposite" en el archivo, el segundo lo recibirá
#                    como entrada.
# - Sockets :: (Unix domain sockets, sockets de dominio Unix). Mecanismo
#              de comunicación bidireccional similar al de los /named
#              pipes/, pero más completo, permitiendo comunicación
#              bidireccional de un modo muy similar al de la
#              comunicación entre dos procesos en red.


# El sistema de archivo que elijamos o implementemos debe tomar en
# cuenta por un lado las características físicas del medio que empleará,
# y por el otro las necesidades del sistema a crear. Por ejemplo:

# - Tiempo de acceso necesario para realizar una operación: Cinta $\gg$
#   Floppy $\gg$ Disco duro > Disco duro /inteligente/ $\approx$ Flash >
#   NVRAM $\gg$ RAM

# - Forma de acceso presentada al sistema: Secuencial (cinta), bloques
#   con referencia de direccionamiento física (floppy, disco duro),
#   bloques consecutivos (disco duro /inteligente/, Flash, NVRAM, RAM

# - Tipo de sistema: ¿Multiusuario? ¿Multiproceso? ¿Embebido? ¿Uso
#   genérico?

# - Uso esperado del medio: Fijo / transportable → Impacto no sólo en
#   estrategias de almacenamiento, sino que de compatibilidad con una
#   gama más amplia de equipos.

# Hay programas de ámbito especializado que no emplean sistemas de
# archivos para el almacenamiento de su información. Principalmente,
# estos son gestores de bases de datos que, dada la naturaleza altamente
# regular y predecible de la información que manejan, permiten trabajar
# con /dispositivos crudos/ (esto es, particiones gestionadas por ellos,
# e invisibles a los demás programas). Esto es partiendo de la lógica
# que hacerlo de esta manera evita tener que atravesar capas
# innecesarias de abstracción y busca un mejor rendimiento al trabajar
# tan cerca como sea posible del hardware subyacente. Esta técnica, sin
# embargo, cada vez es menos común por la forma menos transparente de
# operación que tienen los dispositivos (y que veremos posteriormente).


# *** Determinando el espacio libre
# https://en.wikipedia.org/wiki/File_Allocation_Table#FS_Information_Sector
# En FAT32, se agrega espacio para acelerar algunas tareas del
# sistema, como el cálculo del espacio disponible.


* Fallos y recuperación

El sistema de archivos en el cual estamos estamos basando nuestros
ejemplos, FAT, es /relativamente frágil/: No es difícil que se nos
presente una situación de /corrupción de metadatos/, y muy
particularmente, de la estructura de las tablas de asignación. Los
usuarios de sistemas basados en FAT en Windows sin duda conocen a los
programas =CHKDSK= y =SCANDISK= — Dos programas que implementan la
misma funcionalidad base, y difieren principalmente en su interfaz al
usuario: =CHKDSK= existe desde los primeros años de MS-DOS, y está
pensado para su uso interactivo en línea de comando; =SCANDISK= se
ejecuta desde el entorno gráfico, y presenta la particularidad de que
no requiere (aunque sí recomienda fuertemente) /acceso exclusivo/ al
sistema de archivos mientras se ejecuta. ¿En qué basan su operación
estos programas?

A lo largo de la vida de un sistema de archivos, conforme los archivos
se van asignando y liberando, van cambiando su tamaño, y conforme
montamos y des-montamos al sistema de archivos, pueden ir apareciendo
/inconsistencias/ en su estructura. En los sistemas tipo FAT, las
principales (que no las únicas) inconsistencias son:

- Archivos cruzados :: En inglés, /cross-linked file/. Recordemos que
     la entrada en el directorio de un archivo incluye un apuntador al
     primer /cluster/ de una /cadena/. Cada cadena debe ser única,
     esto es, ningún /cluster/ debe pertenecer a más de un
     archivo. Si dos archivos incluyen al mismo /cluster/, esto
     indica una inconsistencia, y la única forma de resolverla es
     /truncar/ a uno de los archivos en el punto inmediato anterior a
     este cruce.

- Cadenas perdidas o /huérfanas/ :: En inglés, /lost clusters/. Cuando
     hay espacio marcado como ocupado en la tabla de asignación, pero
     no hay ninguna entrada de directorio haciendo referencia a ella,
     el espacio está efectivamente bloqueado y, desde la perspectiva
     del usuario, inutilizado.

#+HTML: <div class="figure">
#+ATTR_LATEX: width=0.7\textwidth
#+CAPTION: Inconsistencias en un sistema de archivos tipo FAT
#+BEGIN_SRC dot :exports results :file ltxpng/inconsistencias_fat.png
digraph G
{
	node [style=filled, fillcolor=white];
	
	subgraph cluster_fat {
		node [shape = box, label = ""];
		label = "Tabla de asignación"
		
		{rank=same; 1 2 3 4} ->
		{rank=same; 5 6 7 8} ->
		{rank=same; 9 10 11 12} ->
		{rank=same; 13 14 15 16} [style=invis];
		
		2 -> 5 -> 1 -> 15;
		15 [label="FF"];
		
		3 -> 6 -> 9 -> 8 -> 4;
		4 [label="FF"];
		
		14 -> 7 -> 11;
		11 [label="FF"];
	}
	
	subgraph cluster_dir {
		label="directorio";
		a [label = "archivo1.txt", fillcolor="#ffffcc"];
		b [label = "a.out", fillcolor="#ccccff"];
		c [label = "proyecto.c", fillcolor="#ffccff"];
	}
	
	subgraph cluster_leyenda {
		style=invis;
		c -> caja_cross -> caja_huerf [style=invis];
		c -> txt_cross -> txt_huerf [style=invis];
		caja_cross [label="", shape=box, fillcolor="#ffaaaa"];
		caja_huerf [label="", shape=box, fillcolor="#ff3333"];
		txt_cross [label="Archivo cruzado", shape=plaintext];
		txt_huerf [label="Cadena perdida", shape=plaintext];
	}
	
	a -> 2;
	b -> 3;
	c -> 1;
	
	2 [fillcolor="#ffffcc"];
	5 [fillcolor="#ffffcc"];
	1 [fillcolor="#ffaaaa"];
	15 [fillcolor="#ffaaaa"];
	
	3 [fillcolor="#ccccff"];
	6 [fillcolor="#ccccff"];
	9 [fillcolor="#ccccff"];
	8 [fillcolor="#ccccff"];
	4 [fillcolor="#ccccff"];
	
	14 [fillcolor="#ff3333"];
	7 [fillcolor="#ff3333"];
	11 [fillcolor="#ff3333"];
}
#+END_SRC

#+RESULTS:
[[file:ltxpng/inconsistencias_fat.png]]
#+HTML: <p align="center">Inconsistencias en un sistema de archivos tipo FAT</p></div>

Cada sistema de archivos podrá presentar un distinto conjunto de
inconsistencias ante los fallos, dependiendo de sus estructuras
básicas y de la manera en que cada sistema operativo las maneja.

En la década de los 1980 comenzaron a entrar a mercado los
/controladores de disco inteligentes/, y en menos de diez años
dominaban ya el mercado. Estos controladores, con buses tan disímiles
como SCSI, IDE, o los más modernos, SAS y SATA, introdujeron muchos
cambios que fueron disociando cada vez más al sistema operativo de la
gestión física directa de los dispositivos; en la sección [[#medio_fisico][El medio
físico]] abordaremos más a profundidad lo que esto ha significado para
el desarrollo de sistemas de archivos y algoritmos relacionados. Sin
embargo, en este tema, los /controladores inteligentes/ resultan
relevantes porque, si bien antes el sistema operativo podía
determinar con toda certeza si una operación se había realizado o no,
hoy en día los controladores dan un /acuse de recibo/ a la
información en el momento en que la colocan en el caché incorporado
del dispositivo — En caso de un fallo de corriente, esta información
puede no haber sido escrita por completo al disco.

Recordemos que las operaciones con los metadatos que conforman al
sistema de archivos no son atómicas. Por poner un ejemplo, crear un
archivo en un volumen FAT requiere:

1. Encontrar una lista de clusters disponibles suficiente para
   almacenar la información que conformará al archivo
2. Encontrar el siguiente espacio disponible en el directorio
3. Crear en el espacio encontrado una entrada con el nombre que
   estamos dando al archivo, apuntando al primero de los clusters
4. Marcar en la tabla de asignación la secuencia por todos estos
   clusters
5. Guardar los datos del archivo en cuestión en los clusters
   correspondientes

Cualquier fallo que se presente después del tercer paso (cuando
hacemos la primer modificación) tendrá como consecuencia que el
archivo resulte corrupto, y muy probablemente que el sistema de
archivos todo /presente inconsistencias/ o /esté en un estado
inconsistente/.

** Datos y metadatos

Formalmente, en el ejemplo recién mencionado, el sistema de archivos
estará consistente siempre que se terminen los pasos 3 y 4 — La
consistencia del sistema de archivos es independiente de la validez de
los datos del archivo. Lo que busca el sistema de archivos, más que
asegurar la integridad de los /datos/ de uno de los archivos, es
asegurar la de los /metadatos/: Los datos que describen la
estructura. En caso de que un usuario desconecte una unidad a media
operación, es casi seguro que se presentará pérdida de información,
pero el sistema de archivos debe buscar no presentar ningún problema
que ponga en riesgo /operaciones posteriores/ o /archivos no
relacionados/.

** Verificación de la integridad

Cada sistema operativo incluye programas para realizar verificación
(y, en su caso, corrección) de la integridad de sus sistemas de
archivo. En el caso de MS-DOS y Windows, estos programas son =CHKDSK=
y =SCANDISK= (diferenciados principalmente en que el primero tiene una
interfaz de línea de comando, mientras que el segundo tiene intefaz
gráfica); en los sistemas Unix, el programa general se llama =fsck=,
y típicamente emplea a asistentes según el tipo de sistema a revisar
— =fsck.vfat=, =fsck.ext2=, etc.

Estos programas hacen un /barrido/ del sistema de archivos, buscando
evidencias de inconsistencia. Esto lo hacen, en líneas generales:

- Siguiendo todas las cadenas de clusters de archivos o tablas de
  i-nodos, y verificando que no haya archivos cruzados (compartiendo
  erróneamente bloques)
- Verificando que todas las cadenas de clusters, así como todos los
  directorios, sean alcanzables y sigan una estructura válida
- Recalculando la correspondencia entre las estructuras encontradas y
  los diferentes bitmaps y totales de espacio vacío

Estas operaciones son siempre procesos intensivos y complejos. Como
requieren una revisión profunda del volúmen entero, es frecuente que
duren entre decenas de minutos y horas. Además, para poder llevar a
cabo su tarea deben ejecutarse teniendo acceso exclusivo al volumen a
revisar, lo cual típicamente significa colocar al sistema completo en
modo de mantenimiento.

Dado el elevado costo que tiene verificar el volumen entero, en la
década de 1990 surgieron varios esquemas orientados a evitar la
necesidad de invocar a estos programas de verificación: Las
/actualizaciones suaves/, los /sistemas de archivos con bitácora/, y
los /sistemas de archivos estructurados en bitácora/.

** Actualizaciones suaves (/soft updates/)

Este esquema aparentemente es el más simple de los que presentaremos,
pero su implementación resultó mucho más compleja de lo inicialmente
estimado, y en buena medida por esta causa hoy en día no ha sido
empleado más ampliamente. La idea básica detrás de este esquema es
estructurar el sistema de archivos de una forma más simple y organizar
las escrituras al mismo de modo que el estado resultante /no pueda/
ser inconsistente, ni siquiera en caso de fallo, y de exigir que todas
las operaciones de actualización de metadatos se realicen de forma
/síncrona/.[fn:: Esto es, no se le reporta éxito en alguna operación
de archivos al usuario sino hasta que ésta es completada y grabada a
disco]

Ante la imposibilidad de tener un sistema /siempre consistente/, esta
exigencia se relajó para permitir inconsistencias /no destructivas/:
Pueden presentarse /cadenas perdidas/, dado que esto no pone en
riesgo a ningún archivo, sólo disminuye el espacio total disponible.

Esto, aunado a una reestructuración del programa de verificación
(=fsck=) como una tarea /ejecutable en el fondo/ y en una tarea de
/recolector de basura/, que no requiere intervención humana (dado que
no pueden presentarse inconsistencias destructivas), permite que un
sistema de archivos que no fue /limpiamente desmontado/ pueda ser
montado y utilizado de inmediato, sin peligro de pérdida de
información o de corrupción.

Al requerir que todas las operaciones sean síncronas, parecería que
el rendimiento global del sistema de archivos tendría que verse
afectado, pero por ciertos patrones de acceso muy frecuentes, resulta
incluso beneficioso. Al mantenerse un ordenamiento lógico de las
dependencias de todas las operaciones que están pendientes, el
sistema operativo puede /combinar/ a muchas de estas y reducir de
forma global las escrituras a disco — Por ejemplo, si varios archivos
son creados en el mismo directorio de forma consecutiva, cada uno de
ellos a través de una llamada =open()= independiente, el sistema
operativo combinará a todos estos accesos en uno sólo, reduciendo el
número de llamadas. Al crear un archivo de uso temporal, un patrón
frecuente en sistemas Unix es solicitar al sistema la creación de un
archivo, abrir el archivo recién creado, y ya teniendo al descriptor
de archivo, eliminarlo — En este caso, con estas tres operaciones
seguidas, /soft updates/ podría ahorrarse por completo la escritura a
disco.

Esta estrategia fue implementada hacia 2002 en el sistema operativo
FreeBSD, y fue adoptada por los principales sistemas de la
familia *BSD, aunque NetBSD lo retiró en 2012, prefiriendo el empleo
de sistemas con bitácora — Muy probablemente, la lógica destrás de
esta decisión sea la cantidad de sistemas que emplean esta segunda
estrategia que veremos a continuación, y lo complejo de mantener
dentro del núcleo dos estrategias tan distintas.

Además de esto, esta estrategia también se vio impactada por los
controladores inteligentes: Si un disco está sometido a carga
intensa, no hay garantía para el sistema operativo del órden que
seguirán /en verdad/ sus solicitudes, que se /forman/ en el caché
propio del disco. Dado que las actualizaciones suaves dependen tan
profundamente de confiar en el ordenamiento, esto introduce aún más
complejidad en el proceso.

** Sistemas de archivo con bitácora (/journaling file systems/)

Este esquema tiene su origen en el ámbito de las bases de datos
distribuídas. Consiste en separar un área del volumen y dedicarla a
llevar una bitácora con todas las /transacciones/ de metadatos.[fn::
Existen implementaciones que registran también los datos en la
bitácora, pero tanto por el tamaño que ésta requiere como por el
impacto en velocidad que significa, son poco utilizadas.] Una
/transacción/ es un conjunto de operaciones que deben aparecer como
atómicas.

La bitácora es generalmente implementada como una /lista ligada
circular/, con un apuntador que indica cuál fue la última operación
realizada exitosamente. Periódicamente, o cuando la carga de
transferencia de datos disminuye, el sistema verifica qué operaciones
quedan pendientes, y /avanza/ sobre la bitácora, marcando cada una de
las transacciones conforme las realiza.

En caso de tener que recuperarse de una condición de fallo, el
sistema operativo sólo tiene que leer la bitácora, encontrar cuál fue
la última operación comprometida, y aplicar las restantes.

Una restricción de este esquema es que las transacciones guardadas en
la bitácora deben ser /idempotentes/ — Esto es, si una de ellas es
efectuada dos veces, el efecto debe ser exactamente el mismo que si
hubiera sido efectuada una sóla vez. Por poner un ejemplo, no sería
válido que una transacción indicara "Agregar al directorio /x/ un
archivo llamado /y/", dado que si la falla se produce después de
procesar esta transacción pero antes de avanzar al apuntador de la
bitácora, el directorio /x/ quedaría con dos archivos /y/ — Una
situación inconsistente. En todo caso, tendríamos que indicar
"registrar al archivo /y/ en la posición /z/ del directorio /x/"; de
esta manera, incluso si el archivo ya había sido registrado, puede
volverse a registrar sin peligro.

#+HTML: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Sistema de archivos con bitácora
#+begin_src dot :exports results :file ltxpng/fs_journaling.png
digraph G
{
	rankdir=RL;
          subgraph cluster_jrnl {
                  label = "Bitácora"
                  color = lightblue;
                  style = "filled";
		  node [shape="box"];
                  1 [label = "Agrega\narch1.txt como\ndirectorio a\nentrada 17"];
                  2 [label = "Asigna los\nclusters\n12, 34, 26\na arch1.txt"];
                  3 [label = "Libera los\nclusters\n37, 38, 39\nde otroarch.c"];
                  4 [label = "Elimina a\notroarch.c\ndel directorio b\nentrada 6"];
                  5 [label = "Agrega el\ncluster 65 a\nunomas.txt"];
  
                  1 -> 2 [label = "72", penwidth=3];
                  2 -> 3 [label = "68", penwidth=3];
                  3 -> 4 [label = "69", penwidth=3];
                  4 -> 5 [label = "70", penwidth=3];
                  5 -> 1 [label = "71", penwidth=3];
		  {rank=same; 1 2}
		  {rank=same; 4 5}

}
  
          subgraph cluster_datos {
                  label = "Datos";
                  color = yellow;
                  style = "filled";
                  dira [label = "Directorio a", shape="box3d"];
                  dirb [label = "Directorio b", shape="box3d"];
                  dira -> 12 -> 34 -> 26 [style="dashed"];
                  dirb -> 37 -> 38 -> 39 [style="dashed"];
                  65;

		  {rank=same; 12 37 65}
		  {rank=same; 34 38}
		  {rank=same; 26 39}
}
          1 -> dira;
          2 -> 12;
          2 -> 34;
          2 -> 26;
          3 -> 37;
          3 -> 38;
          3 -> 39;
          4 -> dirb;
          5 -> 65;
  
          ultimaop [label = "Última operación\nefectuada", shape="box", color="pink", style="filled"];
          cabeza [label = "Siguiente entrada\na reemplazar", shape="box", color="green", style="filled"];
          ultimaop -> 5 [style="dotted",constraint=false];
          cabeza -> 3 [style="dotted",constraint=false];
	  cabeza -> ultimaop [style=invis];
  }
#+end_src

#+RESULTS:
[[file:ltxpng/fs_journaling.png]]
#+HTML: <p align="center">Sistema de archivos con bitácora</p></div>

Este esquema es el más implementado hoy en día, y está presente en
casi todos los sistemas de archivos modernos. Si bien con un sistema
con bitácora no hace falta verificar el sistema de archivos completo
tras una detención abrupta, esta no nos exime de que, de tiempo en
tiempo, el sistema de archivos sea verificado: Es altamente
recomendado hacer una verificación periódica en caso de presentarse
alguna corrupción, sea por algún bug en la implementación, fallos en
el medio físico, o factores similarmente poco frecuentes.

** Sistemas de archivos estructurados en bitácora (/log-structured file systems/)
# <<log_structured>>
Si llevamos el concepto del sistema de archivos con bitácora a su
límite, y designamos a /la totalidad/ del espacio en el volumen como
la bitácora, hablamos de un sistema de archivos /estructurado en
bitácora/. Obviamente, este tipo de sistemas de archivos presenta una
organización completa radicalmente diferente de los sistemas de
archivo tradicionales.

Las ideas básicas detrás de la primer implementación de un sistema de
archivos de esta naturaleza (Ousterhut y Rosenblum, 1992) apuntan al
empleo agresivo de caché de gran capacidad, y con un fuerte mecanismo
de /recolección de basura/, reacomodando la información que esté más
cerca de la /cola/ de la bitácora (y liberando toda aquella que
resulte redundante).

Este tipo de sistemas de archivos facilita las escrituras,
haciéndolas siempre secuenciales, y buscan –a través del empleo del
caché ya mencionado– evitar que las cabezas tengan que desplazarse
con demasiada frecuencia para recuperar fragmentos de archivos.

Una consecuencia directa de esto es que los sistemas de archivos
estructurados en bitácora fueron los primeros en ofrecer /fotografías/
(/snapshots/) del sistema de archivos: Es posible apuntar a un
momento en el tiempo, y –con el sistema de archivos aún en operación–
montar una copia de sólo lectura con la información del sistema de
archivos /completa/ (incluyendo los datos de los archivos).

Los sistemas de archivo estructurados en bitácora, sin embargo, no
están optimizados para cualquier carga de trabajo. Por ejemplo, una
base de datos relacional, en que cada uno de los registros es
típicamente actualizados de forma independiente de los demás, y ocupan
apenas fracciones de un bloque, resultaría tremendamente
ineficiente. La implementación referencia de Ousterhut y Rosenblum fue
parte de los sistemas *BSD, pero dada su tendencia a la /extrema
fragmentación/, fue eliminado de ellos.

Este tipo de sistemas de archivo ofrece características muy
interesantes, aunque es un campo que aún requiere de mucha
investigación e implementaciones ejemplo. Muchas de las
implementaciones en sistemas libres han llegado a niveles de
funcionalidad aceptables, pero por diversas causas han ido perdiendo
el interés o el empuje de sus desarrolladores, y su ritmo de
desarrollo ha decrecido. Sin embargo, varios conceptos muy
importantes han nacido bajo este tipo de sistemas de archivos,
algunos de los cuales (como el de las /fotografías/) se han ido
aplicando a sistemas de archivo estándar.

Por otro lado, dado el fuerte crecimiento que están registrando los
medios de almacenamiento de estado sólido (abordaremos [[#estado_solido][en breve]]
algunas de sus características), y dado que estos sistemas aprovechan
mejor varias de sus características, es probable que el interés en
estos sistemas de archivos resurja.

* El medio físico
# <<medio_fisico>>

Hasta este punto, y siguiendo las prácticas a que la realidad de los
últimos 40 años nos han acostumbrado, hemos empleado el término
genérico de /disco/ para nuestra discusión.

En esta sección, abordaremos en primer término las características
principales del medio aún prevalente, los discos duros magnéticos
rotativos, y presentaremos una introducción a las diferencias que
encontraremos en otros medios, como los discos ópticos y los de
estado sólido, y las implicaciones que éstos tienen sobre lo que
venimos discutiendo a lo largo de la unidad.

** Discos magnéticos rotativos

El principal medio de almacenamiento que hemos empleado en los
últimos 40 años es el /disco magnético/. Hay dos tipos diferentes de
disco, aunque la lógica de su funcionamiento es la misma: Los /discos
duros/ y los /discos flexibles/ (o /floppies/).

La principal diferencia entre estos es que los primeros son
típicamente almacenamiento /interno/ en los equipos de cómputo, y los
segundos están pensados para ser almacenamiento /transportable/. Los
discos duros tienen mucha mayor capacidad y son mucho más rápidos,
pero a cambio de ello, mucho más sensibles a la contaminación por
partículas de polvo y a daños mecánicos.

Un disco flexible es una hoja de material plástico, muy similar al
empleado en las cintas magnéticas, resguardado por un estuche
plástico. Al insertarse el disco en la unidad lectora, esta lo hace
girar sujetándolo por el centro, y las cabezas lectoras[fn:: en un
principio una sola; posteriormente aparecieron las unidades de doble
cara, con dos cabezas lectoras] se deslizan por una ventana que tiene
el estuche. La mayor parte de los discos flexibles presentaban
velocidades de rotación de entre 300 y 400 revoluciones por minuto.

A lo largo de más de 20 años se presentaron muy diferentes formatos
físicos siguiendo esta misma lógica, designándose principalmente por
su tamaño (en pulgadas). La capacidad de los discos, claro está, fue
creciendo con el paso de los años — Esto explica la aparente
contradicción de que los discos más chicos físicamente tenían más
capacidad que los más grandes.

#+caption: Principales formatos de disco flexible en el mercado
|-----------------------+-------------+---------------+--------------|
|                       |  8 pulgadas | 5.25 pulgadas | 3.5 pulgadas |
|-----------------------+-------------+---------------+--------------|
| Fecha de introducción |        1971 |          1976 |         1982 |
| Capacidad             | 150KB-1.2MB |   110KB-1.2MB | 264KB-2.88MB |
| Velocidad (kbit/s)    |          33 |       125-500 |     250-1000 |
| Pistas por pulgada    |          48 |         48-96 |          135 |
|-----------------------+-------------+---------------+--------------|

El nombre de /disco duro/ o /disco flexible/ se debe al medio empleado
para el almacenamiento de la información: Mientras que los discos
flexibles emplean, como mencionamos, una hoja plástica flexible, los
discos duros son metálicos. Los discos están /permanentemente/
montados sobre un eje, lo que permite que tengan una velocidad de giro
entre 20 y 50 veces más rápida que los discos flexibles — Entre 4,200 y
15,000 revoluciones por minuto (RPM), esto es, con una demora
rotacional de entre 2 y 7.14 milisegundos..

Además, a excepción de algunos modelos tempranos, los discos duros
constituyen un paquete cerrado que incluye las cabezas de lectura y
escritura, y toda la electrónica de control. Esto permite que los
discos duros tengan densidades de almacenamiento y velocidades de
transmisión muy superiores a la de los discos flexibles: Los primeros
discos duros que se comercializaron para computadoras personales eran
de 10MB (aproximadamente 70 discos flexibles de su época), y
actualmente hay ya discos de 4TB. La velocidad máxima de transferencia
sostenida hoy en día es superior a los 100MB por segundo, 100 veces
más rápido que la última generación de discos flexibles.

Para medir la eficiencia de un disco duro, el otro dato importante es
el tiempo que toma la cabeza en moverse a través de la superficie del
disco. Hoy en día, las velocidades más comunes son de 20ms para un
/recorrido completo/ (desde el primer hasta el último sector), y entre
0.2ms y 0.8ms para ir de un cilindro al inmediato siguiente. Como
punto de comparación, el recorrido completo en una unidad de disco
flexible toma aproximadamente 100ms, y el tiempo de un cilindro al
siguiente va entre 3 y 8ms.

*** Notación C-H-S

Independientemente de la tecnología, la manera en que el sistema
operativo hace referencia a la ubicación de un bloque de información
en el disco es conocido como la /notación C-H-S/ — Indicando el
cilindro, cabeza y sector (/Cylinder, Head, Sector/) de la
información. Esto permite mapear el espacio de almacenamiento de un
disco a un espacio tridimensional, con cual resulta trivial ubicar a
alguna estructura en una región contigua.

#+attr_html: height="451" width="625"
#+attr_latex: width=0.8\textwidth
#+caption: Coordenadas de un disco duro, presentando cada uno de sus sectores en C-H-S (Silberschatz, p.458)
[[./img/disco_duro.png]]

La /cabeza/ indica a cuál de las superficies del disco nos referimos;
en un disco flexible, tenemos sólo dos cabezas, pero en un disco duro
es común tener varios /platos/ paralelos. Todas las cabezas van fijas
a un mismo motor, y no pueden moverse de forma independiente.

El /cilindro/ indica la distancia del centro a la orilla del disco.

Un /sector/ es un segmento de arco de uno de los cilindros.

Es frecuente ver referencias a una /pista/ (/track/), esto es, a un
cilindro en una de las superficies del disco — Un archivo almacenado
secuencialmente ocupa /sectores adyacentes/ a lo largo de una misma
pista.

*** Algoritmos de planificación de acceso a disco

Como hemos visto, las transferencias a disco son uno de los procesos
más lentos de los que gestiona el sistema operativo. Cuando éste
tiene varias solicitudes de transferencia pendientes, resulta
importante encontrar un mecanismo óptimo para realizar la
transferencia, minimizando el tiempo de demora. Presentaremos a
grandes rasgos tres de los algoritmos de planificación de acceso a
disco — Pero abordaremos también el por qué estos hoy en día casi no
son empleados.

Como con los demás escenarios que hemos abordado analizando
algoritmos, para analizar su rendimiento tenemos que presentar una
/cadena de referencia/. En este caso, trabajaremos con un disco
hipotético de 200 cilindros, la cadena de solicitudes /98, 183, 37,
122, 14, 124, 65, 67/, y teniendo la cabeza al inicio de la operación
en el cilindro 53.

Al igual que cuando hablamos de algoritmos de asignación de procesador
y de reemplazo de páginas, el primero y más sencillo de implementar es
el /FIFO/ — /Primero en llegar, primero en servirse/. Este algoritmo puede
verse como muy /justo/, aunque sea muy poco eficiente: El movimiento
total de cabezas para el caso planteado es de 640 cilindros,
equivalente a poco más que recorrer de extremo a extremo el disco
completo tres veces. Esto es, despreciando la demora rotacional y el
tiempo que le toma al brazo detenerse por completo antes de volver a
moverse, esta lectura tomaría un mínimo de 60ms, siendo el recorrido
completo del disco 20ms.

Podemos encontrar al causante de buena parte de esta demora en la
quinta posición de la cadena de referencia: Entre solicitudes para el
cilindro 122 y 124, tenemos una solicitud al 14, que significa un
desplazamiento de $(122-14) + (124-14) = 218$ sectores.

#+attr_latex: width=0.6\textwidth
#+attr_html: width=429 height=285
#+caption: Planificación de disco FIFO (Silberschatz, p. 464)
[[./img/algoritmo_disco_fifo.png]]

Ahora bien, si el factor que impone la principal demora es el
movimiento de la cabeza, el segundo algoritmo busca reducir al mínimo
el movimiento de la cabeza: /SSTF/ (/Shortest Seek Time First/,
/Tiempo de búsqueda más corto a continuación/) es el equivalente en
este ámbito del /Shortest Job First/ que vimos en planificación de
procesos — con la ventaja de que no estamos prediciendo
comportamiento futuro, sino que tenemos ya la lista de solicitudes
pendientes. Empleando SSTF, el tiempo de desplazamiento para este
caso se reduce a tan sólo 236 cilindros — muy cerca del mínimo
absoluto posible.

Una desventaja de SSTF es que puede llevar a la inanición: Si hay una
gran densidad de solicitudes para cilindros en determinada zona del
disco, una solicitud para un cilindro alejado puede quedar a la espera
indefinidamente.

#+attr_html: width=617 height=430
#+attr_latex: width=0.6\textwidth
#+caption: Planificación de disco SSTF (Tiempo más corto a continuación) (Silberschatz, p. 465)
[[./img/algoritmo_disco_sstf.png]]

El tercer algoritmo es conocido coloquialmente como /el algoritmo del
elevador/ (/SCAN/). Este algoritmo busca evitar la inanición,
minimizando al mismo tiempo el movimiento de las cabezas. Su lógica es
que la cabeza debe recorrer el disco de extremo a extremo, atendiendo
a todas las solicitudes que haya pendientes en su camino. Si bien los
recorridos para ciertos patrones pueden resultar superiores a los que
daría SSTF, la garantía de que ningún proceso esperará
indefinidamente lo hace muy atractivo.

Una modificación a este algoritmo sería, cada vez que la cabeza se
detenga para satisfacer una solicitud, verificar si hay alguna otra
solicitud pendiente en la /dirección actual/, y de no ser así,
emprender el camino de regreso sin llegar a la orilla del disco. Esta
modificación es frecuentemente descrita como /LOOK/.

Atender la cadena de referencia con la que estamos trabajando bajo
SCAN, asumiendo un estado inicial /descendente/ (esto es, la cabeza
está en el cilindro 53 y va bajando) da un recorrido total de 236
cilindros; empleando LOOK, se reduce a 208 cilindros.

#+attr_html: width="514" height="344"
#+attr_latex: width=0.6\textwidth
#+caption: Planificación de disco SCAN (elevador)  (Silberschatz, p. 466)
[[./img/algoritmo_disco_scan.png]]

*** Limitaciones de los algoritmos presentados

Ahora, mencionamos que estos algoritmos hoy en día ya casi no se
usan. Hay varias razones para ello. En primer término, todos ellos
están orientados a reducir el traslado /de la cabeza/, pero ignoran
la /demora rotacional/. Como vimos, en los discos duros actuales, la
demora rotacional va entre $1 \over 10$ y $1 \over 3$ del tiempo
total de recorrido de la cabeza. Y si bien el sistema podría
considerar esta demora como un factor adicional al planificar el
siguiente movimiento de forma que se redujera el tiempo de espera,
los algoritmos descritos obviamente requieren ser replanteados por
completo.

Por otro lado, el sistema operativo muchas veces requiere dar
distintas prioridades a los diferentes tipos de solicitud. Por
ejemplo, sería esperable dar preferencia a los accesos a memoria
virtual por encima de las solicitudes de abrir un nuevo archivo. Estos
algoritmos tampoco permiten expresar esta necesidad.

Pero el tercer punto es mucho más importante aún: Del mismo modo en
que los procesadores se van haciendo más rápidos y que la memoria
es cada vez de mayor capacidad, los controladores de discos también
son cada vez más /inteligentes/, y /esconden/ cada vez más
información del sistema operativo, por lo cual éste cada vez más
carece de la información necesaria acerca del acomodo /real/ de la
información como para planificar correctamente sus accesos.

Uno de los cambios más importantes en este sentido fue la transición
del empleo de la notación C-H-S al esquema de /direccionamiento lógico
de bloques/ (/Logical Block Addressing/, /LBA/) a principios de
los 1990. Hasta ese momento, el sistema operativo tenía información de
la ubicación /física/ de todos los bloques en el disco.

Una de las desventajas, sin embargo, de este esquema es que el mismo
BIOS tenía que conocer la /geometría/ de los discos — Y el BIOS
presentaba límites duros en este sentido: Principalmente, no le era
posible referenciar más allá de 64 cilindros. Al aparecer la interfaz
de discos IDE (/Electrónica integrada al dispositivo/) e ir
reemplazando a la ST-506, se introdujo LBA, que en un primer término
de la dirección C-H-S a una dirección /lineal/, presentando el disco
al sistema operativo ya no como un espacio /tridimensional/, sino que
como un gran arreglo de bloques. En este primer momento, la
equivalencia de una dirección C-H-S a una LBA era:

#+BEGIN_QUOTE
$LBA = ((C \times HPC) + H) \times SPT + S - 1$
#+END_QUOTE

Donde $HPC$ es el número de cabezas por cilindro, $SPT$ es el número
de sectores por pista.

LBA significó mucho más que una nueva notación — Marcó el inicio de
la transferencia de inteligencia y control del CPU al controlador de
disco. Podemos ver el impacto de esto directamente en dos factores:

- Sectores variables por cilindro :: En casi todos los discos previos
     a LBA[fn:: Como muy notorias excepciones tenemos a las unidades
     de disco /Commodore 1541/ y /Macintosh Superdrive/, que empleaban
     velocidad variable por cilindro para aprovechar mejor el medio
     magnético; en ambos casos, sin embargo, terminaron desapareciendo
     por cuestiones de costos y de complejidad al sistema], el número
     de sectores por pista se mantenía constante, se tratara de las
     pistas más internas o más externas. Esto significa que, a igual
     calidad de la cobertura magnética del medio, los sectores
     ubicados en la parte exterior del disco desperdiciaban mucho
     espacio (ya que el /área por bit/ era mucho mayor).

     #+attr_html: width="402" height="402"
     #+attr_latex: width=0.4\textwidth
     #+caption: Disco formateado bajo /densidad de bits por zona/, con más sectores por pista en las pistas exteriores. (Imagen: Wikipedia)
     [[./img/zone_bit_recording.png]]

     Bajo LBA, los discos duros comenzaron a emplear un esquema de
     /densidad de bits por zona/ (/zone bit recording/), con la que en
     los cilindros más externos se aumenta.

- Reubicación de sectores :: Conforme avanza el uso de un disco, es
     posible que algunos sectores vayan resultando /difíciles/ de
     leer por daños microscópicos a la superficie. El controlador es
     capaz de detectar estos problemas, y de hecho, casi siempre
     puede rescatar la información de dichos sectores de forma
     imperceptible al usuario.

     Los discos duros ST-506 típicamente venían acompañados por una
     /lista de defectos/, una lista de coordenadas C-H-S que desde su
     fabricación habían presentado errores. El usuario debía ingresar
     estos defectos al formatear el disco /a bajo nivel/.

     Hoy en día, el controlador del disco detecta estos fallos y se
     los /brinca/, presentando un mapa LBA lineal y completo. Los
     discos duros típicamente vienen con cierto número de /sectores de
     reserva/ para que, conforme se van detectando potenciales daños,
     estos puedan reemplazarse de forma transparente.

Sumemos a esto que los controladores de disco tienen ya incluso caché
para las operaciones de lectura y escritura — El controlador del disco
es hoy en día capaz de implementar estos mismos algoritmos de forma
completamente autónoma del sistema operativo.

Resulta claro que, dados estos cambios en la manera en que hacemos
referencia a los bloques del disco, el sistema operativo no cuenta ya
con la información necesaria para emplear los algoritmos de
planificación de acceso a disco.


** Almacenamiento en estado sólido
# <<estado_solido>>

Desde hace cerca de una década va creciendo consistentemente el uso de
medios de almacenamiento de /estado sólido/ — Esto es, medios sin
partes móviles. Las características de estos medios de almacenamiento
son muy distintas de las de los discos. Si bien las estructuras que
emplean hoy en día prácticamente todos los sistemas de archivos en uso
mayoritario están pensadas y estructuradas siguiendo la lógica de los
medios magnéticos rotativos, la necesidad de emplear las estructuras
adecuadas es clara. Este es indudablemente un área bajo intensa
investigación y desarrollo, y que seguramente nos ofrecerá
importantes novedades en los próximos años.

Lo primero que llama la atención de estos medios de almacenamiento es
que, a pesar de ser fundamentalmente distintos a los discos
magnéticos, se presentan ante el sistema operativo como si fueran lo
mismo: En lo que podría entenderse como un esfuerzo para ser
utilizados pronto y sin cambios, se conectan a través de la misma
interfaz y empleando la misma semántica que un disco rotativo. Esto no
sólo evita que se aprovechen sus características únicas, adoptando
restricciones y criterios de diseño que ahora resultan indudablemente
artificiales, sino que incluso se exponen a mayor stress por no
emplearse de la forma que les resultaría natural. Antes de ver por
qué, veamos un poco los tipos de discos de estado solido que hay; esto
nos dará pie a entender las características a las que en este párrafo
hacemos referencia.

Al hablar de la tecnología sobre la cual se implementa este tipo de
almacenamiento, encontraremos dos medios principales:

- NVRAM :: Unidades /RAM No Volátil/. Almacenan la información en
           memoria RAM estándar, con un respaldo de batería para
           mantener la información cuando se desconecta la corriente
           externa. Las primeras unidades de estado sólido eran de
           este estilo; hoy en día son poco comunes en el mercado,
           pero siguen existiendo.

	   Su principal ventaja es la velocidad y durabilidad: El
           tiempo de acceso o escritura de datos es el mismo que el
           que esperaríamos de la memoria principal del sistema, y al
           no haber demoras mecánicas, este tiempo es el mismo
           independientemente de la dirección que se solicite.

	   Su principal desventaja es el precio: En líneas generales,
           la memoria RAM es, por volumen de almacenamiento, cientos
           de veces más cara que el medio magnético. Y si bien el
           medio no se degrada con el uso, la batería sí, lo que
           podría poner en peligro a la supervivencia de la
           información.

	   Estas unidades típicamente se instalan internamente como
           una tarjeta de expansión.

	   #+caption: Unidad de estado sólido basado en RAM: DDRdrive X1 ([[https://en.wikipedia.org/wiki/Solid-state\_drive][Imagen: Wikipedia]])
	   #+attr_latex: width=0.5\textwidth
	   #+attr_html: height="200" width="300"
	   [[./img/estado_solido_ddr_drivex1.jpg]]

- Memoria /flash/ :: Derivada de los /EEPROM/ (/Electrically Erasable
     Programmable Read-Only Memory/, /Memoria de Sólo Lectura
     Programable y Borrable Eléctricamente/). Los EEPROM tienen la
     característica de que, además de lectura y escritura, hay un
     tercer tipo de operación que deben implementar: El /borrado/. Un
     EEPROM ya utilizado debe borrarse antes de volverse a escribir a
     él. La principal característica que distingue a las memorias
     /flash/ de los EEPROMs tradicionales es que el espacio de
     almacenamiento está dividido en /páginas/ o /bloques/, y el
     controlador puede leer, borrar o escribir a cada uno de ellos por
     separado.

     El uso de dispositivos /flash/ para almacenamiento de información
     inició hacia 1995 como respuesta a las necesidades de las
     industrias aeroespacial y militar, dada la frecuencia de los
     daños a la información que presentaban los medios magnéticos por
     la vibración. Hoy en día hay dispositivos /flash/ de muy bajo
     costo y capacidad, aunque presentan una gran variabilidad tanto
     en su tiempo de acceso como en su durabilidad. En este sentido,
     podemos hablar de dos tipos principales de dispositivos /flash/:

  - Almacenamiento primario (SSD) :: Las llamadas formalmente
       /unidad de estado sólido/ (/Solid State Drive/)[fn:: Un
       error muy común es confundir la /D/ con /Disk/, que
       denotaría que llevan un /disco/, un /medio rotativo/] son
       unidades Flash de alta velocidad y capacidad, y típicamente
       presentan una interfaz similar a la que tienen los discos
       duros (hoy en día, la más común es SATA).

       #+caption: Unidad de estado sólido basado en Flash con interfaz SATA ([[https://en.wikipedia.org/wiki/Solid-state\_drive][Imagen: Wikipedia]])
       #+attr_html: height="262" width="400"
       #+attr_latex: width=0.5\textwidth
       [[./img/estado_solido_sata.jpg]]

       Su velocidad de lectura es muy superior y su velocidad de
       escritura (incluyendo el borrado) es comparable a la de los
       discos magnéticos. Su precio por el mismo volumen de
       almacenamento es entre 5 y 10 veces el de los discos
       magnéticos.

       Podemos encontrar este tipo de unidades tanto como unidades
       independientes en servidores, equipos de alto desempeño e
       incluso algunas subportátiles (/netbooks/) o como un
       componente de la tarjeta madre en dispositivos móviles como
       teléfonos y tabletas.

  - Transporte de archivos :: Esta tecnología también está presente en
       las diversas unidades extraíbles o móviles, como las unidades
       USB, SD, Memory Stick, Compact Flash, etc. La principal
       diferencia entre estas son los diferentes conectores que
       emplean; todas estas tecnologías presentan dispositivos que
       varían fuertemente en capacidad, velocidad y durabilidad.

       #+caption: Unidad de estado sólido basado en Flash con interfaz USB ([[https://en.wikipedia.org/wiki/Solid-state\_drive][Imagen: Wikipedia]])
       #+attr_html: height="300" width="335"
       #+attr_latex: width=0.5\textwidth
       [[./img/estado_solido_usb.jpg]]


Independientemente del tipo, las unidades de estado sólido presentan
ventajas ante los discos rotativos, como un muy bajo consumo
eléctrico, operación completamente silenciosa, y resistencia a la
vibración o a los golpes. Además, el medio es /verdaderamente/ de
acceso aleatorio: Al no ser ya un disco, desaparecen tanto la demora
de movimiento de cabezas como la rotacional.

*** Desgaste del medio

La memoria Flash presenta patrons de desgaste muy distintos de los que
podemos ver en otros medios. La memoria Flash tiene capacidad de
aguantar un cierto número de operaciones de borrado por página.[fn::
Dependiendo de la calidad, va entre las 3,000 y 100,000] Las
estructuras tradicionales de sistemas de archivos basados en disco
/concentran/ una gran cantidad de modificaciones en ciertas regiones
clave: Las tablas de asignación y directorios registran muchos más
cambios que la región de datos.

Casi todos los controladores de discos Flash cuentan con mecanismos de
/nivelamiento de escrituras/ (/write leveling/). Este mecanismo busca
reducir el desgaste focalizado modificando el mapeo de los sectores
que ve el sistema operativo respecto a los que son grabados /en
verdad/ en el medio: En vez de actualizar un bloque (por ejemplo, un
directorio) /en su lugar/, el controlador le asigna un nuevo bloque de
forma transparente, y marca el bloque original como libre.

Los mecanismos más simples de nivelamiento de escrituras lo hacen
únicamente intercambiando los bloques libres con los recién
reescritos; mecanismos más avanzados buscan nivelar el nivel de
reescritura en toda la unidad reubicando también a los bloques que
típicamente sólo se leen.

*** Emulación de discos

Hoy en día, la casi totalidad de medios de estado sóldo se presentan
ante el sistema con una interfaz que emula la de los discos, la /FTL/
(/Flash Translation Layer/, /Capa de Traducción de Flash/). La ventaja
de esta emulación es que no hizo falta desarrollar controladores
adicionales para comenzar a emplear estos medios. La desventaja, sin
embargo, es que al ocultarse el funcionamiento /real/ de las unidades
de estado sólido, el sistema operativo no puede aprovechar las
ventajas estructurales — Y más importante aún, no puede evitar las
debilidades inherentes al medio.

Uno de los ejemplos más claros de esta falta de control real del medio
la ilustra el [[https://lwn.net/Articles/353411/][artículo de Valerie Aurora (2009)]], que menciona que
tanto la poca información públicamente disponible acerca del
funcionamiento de los controladores como los patrones de velocidad y
desgaste de los mismos apuntan a que la estructura subyacente de casi
todos los medios de estado sólido es la de un /sistema de archivos
estructurado en bitácora/. Aurora indica que hay varias operaciones
que no pueden ser traducidas eficientemente a través de esta capa de
emulación, y que seguramente permitirían un mucho mejor
aprovechamiento del medio. Como mencionamos en la sección que describe
los [[#log_structured][sistemas de archivo estructurados en bitácora]], si bien varios de
estos sistemas de archivos han presentado implementaciones
completamente utilizables, la falta de interés ha llevado a que muchos
de estos proyectos sean abandonados.

En su [[http://lwn.net/Articles/528617/][artículo de 2012]], Neil Brown apunta a que Linux tiene una
interfaz apta para hablar directamente con dispositivos de estado
sólido, llamada =mtd= — /memory technology devices/, /dispositivos de
tecnología de memoria/.

Como lo mencionamos al inicio de esta sección, si bien los discos
duros se han empleado por ya 50 años y los sistemas de archivos están
claramente desarrollados para aprovechar sus detalles físicos y
lógicos, el uso de los dispositivos de estado sólido apenas está
despegando en la última década. Y si bien esta primer aproximación que
nos permite emplear esta tecnologíá transparentemente es
/suficientemente buena/ para muchos de los usos básicos, sin duda hay
espacio para mejorar. Este es un tema que seguramente brinda amplio
espacio para investigación y desarrollo para los próximos años.

* Manejo avanzado de volúmenes

En la sección /[[#estructura_en_dispositivo][Plasmando la estructura en el dispositivo]]/ presentamos
muy escuetamente al concepto de /volumen/. Mencionamos que un volumen
/típicamente/ coincide con una partición, aunque no siempre es el
caso — Y no profundizamos más al respecto. En esta sección
describiremos uno de los mecanismos en que podemos combinar
diferentes /dispositivos físicos/ en un sólo volumen, y cómo –bajo
las diferentes modalidades que presentaremos– lleva a ganar en
confiabilidad, rendimiento y espacio disponible.

Abordaremos un esquema llamado /RAID/, /Arreglo Redundante de Discos
Baratos/ (/Redundant Array of Inexpensive Disks/)[fn:: Ocasionalmente
se presenta a RAID como acrónimo de /Arreglo Redundante de Discos
Independientes/ (/Redundant Array of Independent Disks/)], propuesto
en 1988 por David Patterson, Garth Gibson y Randy Katz ante el
diferencial que se presentaba (y se sigue presentando) entre el
avance en velocidad y confiabilidad del cómputo en relación al
almacenamiento magnético. Bajo los esquemas RAID queda sobreentendido
que los diferentes discos que forman parte de un volumen son del
mismo tamaño. Si se remplaza un disco de un arreglo por uno más
grande, la capacidad /en exceso/ que tenga éste sobre los demás
discos será desperdiciada.

Por muchos años, los arreglos RAID se hacían a través de controladores
dedicados, presentándose como un dispositivo único al sistema
operativo. Hoy en día, prácticamente todos los sistemas operativos
incluyen la capacidad de integrar varias unidades independientes en un
arreglo por software; esto conlleva un impacto en rendimiento, aunque
muy pequeño. Hay también, y abordaremos algunas de estas
implementaciones hacia el final de esta sección, varias
implementaciones derivadas de RAID que han incorporado conceptos de
capas superiores en algunos sistemas operativos modernos.

RAID no es un sólo esquema, sino que es un /conjunto de esquemas/,
cada uno de ellos diseñado para mejorar distintos aspectos del
almacenamiento en discos. Veamos las características de los
principales niveles en uso hoy en día.

** RAID 0: División en /franjas/

Este esquema nos brinda una mejoría tanto en espacio total, dado que
presenta a un volumen grande en vez de varios discos probablemente más
pequeños, simplificando la tarea del administrador, como de velocidad,
dado que las lecturas y escrituras al volumen ya no estarán sujetas al
movimiento de una sola cabeza, sino que habrá una cabeza independiente
por cada uno de los discos que tengamos en el volumen.

#+attr_latex: width=0.7\textwidth
#+caption: Cinco discos organizados en RAID 0
#+begin_src dot :exports results :file ltxpng/raid_0.png
  digraph G {
          rankdir=LR;
	  node [shape=circle];
          subgraph cluster0 {
                   label = "Volumen (5TB)";
                   1 [label = "Disco\n1: 1TB"];
                   2 [label = "Disco\n2: 1TB"];
                   3 [label = "Disco\n3: 1TB"];
                   4 [label = "Disco\n4: 1TB"];
                   5 [label = "Disco\n5: 1TB"];
                   1 -> 2 [label = "+"];
                   2 -> 3 [label = "+"];
                   3 -> 4 [label = "+"];
                   4 -> 5 [label = "+"];
          }
  }
#+end_src

Los discos que participan en un volumen RAID 0 no son sencillamente
/concatenados/, sino que los datos son /divididos en franjas/ (en
inglés, el proceso se conoce como /striping/, de la palabra /stripe/,
franja; algunas traducciones al español se refieren a este proceso
como /bandeado/). Esto hace que la carga sea repartida de forma
uniforme entre todos los discos, y asegura que todas las
transferencias mayores al tamaño de una franja provengan de más de un
disco independiente.

#+attr_latex: width=0.6\textwidth
#+caption: División de datos en /franjas/
#+begin_src ditaa :file ltxpng/franjas_raid_0.png :cmdline -E
          +---------+ +---------+ +---------+
          |{s}      | |{s}      | |{s}      |
+-----+   |  +---+  | |  +---+  | |  +---+  |
|  A  +-->+  |A1 |  | |  |A2 |  | |  |A3 |  |
+-----+   |  +---+  | |  +---+  | |  +---+  |
|  B  +-->|  |B1 |  | |  |B2 |  | |  |B3 |  |
+-----+   |  +---+  | |  +---+  | |  +---+  |
|  C  +-->|  |C1 |  | |  |C2 |  | |  |C3 |  |
+-----+   |  +---+  | |  +---+  | |  +---+  |
|  D  +-->|  |D1 |  | |  |D2 |  | |  |D3 |  |
+-----+   |  +---+  | |  +---+  | |  +---+  |
          | Disco 1 | | Disco 2 | | Disco 3 |
          +---------+ +---------+ +---------+
#+end_src

La confiabilidad del volumen, sin embargo, disminuye
respecto a si cada uno de los discos se manejara por separado: Basta
con que uno de los discos presente daños para que la información
contenida en el volumen se pierda.

Puede construirse un arreglo bajo RAID nivel 0 con un mínimo de dos
discos.

** RAID 1: Espejo

Este nivel está principalmente orientado a aumentar la confiabilidad
de la información: Los datos son grabados de forma /simultánea e
idéntica/ en todos los discos que formen parte del volumen. El costo
de mantener los datos en espejo, claro está, es el del espacio
empleado: En su configuración habitual, de dos discos por volumen, el
50% del espacio de almacenamiento se pierde por fungir como respaldo
del otro 50%.

La velocidad de acceso a los datos bajo RAID 1 es mayor a la que
tendríamos con un disco tradicional: Basta con que obtengamos la
respuesta de uno de los discos; el controlador RAID (sea el sistema
operativo o una implementación en hardware) puede incluso programar
las solicitudes de lectura para que se vayan repartiendo entre ambas
unidades. La velocidad de escritura se ve levemente reducida, dado
que hay que esperar a que ambos discos escriban la información.

#+caption: Dos discos organizados en RAID 1
#+attr_latex: width=0.3\textwidth
#+begin_src dot :exports results :file ltxpng/raid_1.png
  digraph G {
          rankdir=LR;
	  node [shape=circle];
          subgraph cluster0 {
                   label = "Volumen (1TB)";
                   1 [label = "Disco\n1: 1TB"];
                   2 [label = "Disco\n2: 1TB"];
                   1 -> 2 [label = "=", dir = both];
          }
  }
#+end_src

Un arreglo RAID nivel 1 se construye típicamente con dos discos.

** Los niveles 2, 3 y 4 de RAID

Los siguientes tres niveles de RAID combinan propiedades de los
primeros junto con un algoritmo de verificación de integridad y
corrección de errores. Estos han caído casi por completo en el desuso
dado que los otros niveles, y muy en particular el nivel 5, ofrecen
las mismas características, pero con mayor confiabilidad

** RAID 5: Paridad dividida por bloques

El nivel 5 de RAID proporciona un muy buen equilibrio respecto a las
características que venimos mencionando: nos brinda el espacio total
de almacenamiento de todos los discos que formen parte del volumen
/menos uno/. Para cada una de las /franjas/, RAID5 calcula un bloque
de /paridad/. Ahora, este bloque de paridad no siempre va al mismo
disco, sino que se va repartiendo entre todos los discos del volumen,
/desplazándose/ a cada franja, de modo que /cualquiera de los discos
puede fallar/, y el arreglo continuará operando sin pérdida de
información. Esta falla se notifica al administrador del sistema,
quien debe reemplazar el disco lo más pronto posible (dado que, de no
hacerlo, la falla en un segundo disco resultará en la pérdida de toda
la información).

#+attr_latex: width=0.7\textwidth
#+caption: División de datos en /franjas/, con paridad, para RAID 5
#+begin_src ditaa :file ltxpng/franjas_raid_5.png :cmdline -E
+-------------+ +-------------+ +-------------+ +-------------+ +-------------+
|{s} cFFF     | |{s} cFFF     | |{s} cFFF     | |{s} cFFF     | |{s} cFFF     |
| +---------+ | | +---------+ | | +---------+ | | +---------+ | | +---------+ |
| |cFFFA1   | | | |cFFFA2   | | | |cFFFA3   | | | |cFFFA4   | | | |cDDDpA   | |
| +---------+ | | +---------+ | | +---------+ | | +---------+ | | +---------+ |
| |cFFFB1   | | | |cFFFB2   | | | |cFFFB3   | | | |cDDDpB   | | | |cFFFB4   | |
| +---------+ | | +---------+ | | +---------+ | | +---------+ | | +---------+ |
| |cFFFC1   | | | |cFFFC2   | | | |cDDDpC   | | | |cFFFC3   | | | |cFFFC4   | |
| +---------+ | | +---------+ | | +---------+ | | +---------+ | | +---------+ |
| |cFFFD1   | | | |cDDDpD   | | | |cFFFD2   | | | |cFFFD3   | | | |cFFFD4   | |
| +---------+ | | +---------+ | | +---------+ | | +---------+ | | +---------+ |
| |cDDDpE   | | | |cFFFE1   | | | |cFFFE2   | | | |cFFFE3   | | | |cFFFE4   | |
| +---------+ | | +---------+ | | +---------+ | | +---------+ | | +---------+ |
|cFFFDisco 1  | |   Disco 2   | |   Disco 3   | |   Disco 4   | |   Disco 5   |
+-------------+ +-------------+ +-------------+ +-------------+ +-------------+
#+end_src

Dependiendo de la configuración, la velocidad de acceso de este nivel
puede ser es ligeramente menor que la que obtendríamos de los discos
sin RAID, o ligeramente menor a la que obtendríamos con RAID
nivel 0. Dado que la electrónica en los discos actuales nos
notificará explícitamente en caso de fallo de lectura, al leer
información podemos leer únicamente los discos que contengan la
información (e ignorar al de paridad); si nuestro RAID está
configurado para verificar la paridad en lecturas, claro está, todas
las lecturas tendrán que obtener la franja correspondiente de todos
los discos del arreglo para poder calcularla.

Las escrituras son invariablemente más lentas que lo que obtenemos
tanto en ausencia de RAID como en niveles 0 y 1, dado que siempre
tendrá que recalcularse la paridad; en el caso de una escritura
mínima, menor a una franja, tendrá que leerse la franja entera de
todos los discos participantes en el arreglo, recalcularse la
paridad, y grabarse en el disco correspondiente.

Cuando uno de los discos falla, el arreglo comienza a trabajar en el
/modo interino de recuperación de datos/ (/Interim data recovery
mode/), en el que todas las lecturas involucran a todos los discos, ya
que tienen que estar recalculando y /rellenando/ la información que
provendría del disco dañado.

#+attr_latex: width=0.7\textwidth
#+caption: Cinco discos organizados en RAID 5
#+begin_src dot :exports results :file ltxpng/raid_5.png
  digraph G {
          rankdir=LR;
	  node [shape=circle];
          subgraph cluster0 {
                   label = "Volumen (4TB)";
                   1 [label = "Disco\n1: 1TB"];
                   2 [label = "Disco\n2: 1TB"];
                   3 [label = "Disco\n3: 1TB"];
                   4 [label = "Disco\n4: 1TB"];
                   5 [label = "Disco\n5: 1TB", color="blue"];
                   1 -> 2 [label = "+"];
                   2 -> 3 [label = "+"];
                   3 -> 4 [label = "+"];
                   1 -> 5 [color="blue", label = "PAR"];
                   2 -> 5 [color="blue", label = "PAR"];
                   3 -> 5 [color="blue", label = "PAR"];
                   4 -> 5 [color="blue", label = "PAR"];
          }
  }
#+end_src

Para implementar RAID nivel 5 son necesarios por lo menos 3 discos,
aunque es común verlos más /anchos/, pues de este modo se desperdicia
menos espacio en paridad. Si bien teóricamente un arreglo nivel 5
puede ser arbitrariamente ancho, en la práctica es muy raro ver
arreglos con más de 5 discos: Tener un arreglo más ancho aumentaría la
probabilidad de falla. Si un arreglo que está ya operando en el modo
interino de recuperación de datos se encuentra con una falla en
cualquiera de sus discos, tendrá que reportar un fallo irrecuperable.

** RAID 6: Paridad por redundancia P+Q

Se trata nuevamente de un nivel de RAID muy poco utilizado. Se basa en
el mismo principio que el de RAID 5 pero, empleando dos distintos
algoritmos para calcular la paridad, permite la pérdida de hasta dos
de los discos del arreglo. La complejidad computacional es
sensiblemente mayor a la de RAID 5, no sólo porque se trata de un
segundo cálculo de paridad, sino porque este cálculo debe hacerse
empleando un algoritmo distinto y más robusto — Si bien para obtener
la paridad $P$ basta con hacer una operación /XOR/ sobre todos los
segmentos de una /franja/, la segunda paridad $Q$ típicamente emplea
al /algoritmo Reed-Solomon/, /paridad diagonal/ o /paridad dual
ortogonal/. Esto conlleva a una mayor carga al sistema, en caso de que
sea RAID por software, o a que el controlador sea de mayor costo por
implementar mayor complejidad, en caso de ser hardware dedicado.

#+attr_latex: width=0.7\textwidth
#+caption: Cinco discos organizados en RAID 6
#+begin_src dot :exports results :file ltxpng/raid_6.png
  digraph G {
          rankdir=LR;
	  node [shape=circle];
          subgraph cluster0 {
                   label = "Volumen (3TB)";
                   1 [label = "Disco\n1: 1TB"];
                   2 [label = "Disco\n2: 1TB"];
                   3 [label = "Disco\n3: 1TB"];
                   4 [label = "Disco\n4: 1TB", color="green"];
                   5 [label = "Disco\n5: 1TB", color="blue"];
                   1 -> 2 [label = "+"];
                   2 -> 3 [label = "+"];
                   1 -> 4 [color="green", label = "PAR P"];
                   2 -> 4 [color="green", label = "PAR P"];
                   3 -> 4 [color="green", label = "PAR P"];
                   1 -> 5 [color="blue", label = "PAR Q"];
                   2 -> 5 [color="blue", label = "PAR Q"];
                   3 -> 5 [color="blue", label = "PAR Q"];
          }
  }
#+end_src

El nivel 6 de RAID puede implementarse con 4 o más unidades, y si
bien el espacio dedicado a la redundancia se incrementa a dos discos,
la redundancia adicional que ofrece este esquema permite crear
volúmenes con un mayor número de discos.

** Niveles combinados de RAID

Viendo desde el punto de vista de la abstracción presentada, RAID
toma una serie de dispositivos de bloques y los /combina/ en otro
dispositivo de bloques. Esto significa que puede tomarse una serie de
volúmenes RAID y combinarlos en uno solo, aprovechando las
características de los diferentes niveles.

Si bien pueden combinarse arreglos de todo tipo, hay combinaciones más
frecuentes que otras. Con mucho, la más popular es la de los niveles
1 + 0 — Esta combinación, frecuentemente llamada sencillamente /RAID
10/, ofrece un máximo de redundancia y rendimiento, sin sacrificar
demasiado espacio.

#+attr_latex: width=0.7\textwidth
#+caption: Seis discos organizados en RAID 1+0
#+begin_src dot :exports results :file ltxpng/raid_10.png
  digraph G {
          rankdir=LR;
	  node [shape=circle];
	  
          subgraph cluster_resulta {
                  label = "Volumen RAID1\nresultante (3TB)";
		  subgraph cluster_vol1 {
			  label = "Subvolumen\nRAID0 1 (1TB)";
			  1 -> 2 [label = "=", dir = both, color="blue"];
		  }
		  subgraph cluster_vol2 {
			  label = "Subvolumen\nRAID0 2 (1TB)";
			  3 -> 4 [label = "=", dir = both, color="blue"];
		  }
		  subgraph cluster_vol3 {
			  label = "Subvolumen\nRAID0 3 (1TB)";
			  5 -> 6 [label = "=", dir = both, color="blue"];
		  }
		  1 -> 3 [label = "+"];
		  3 -> 5 [label = "+"];
                  2 -> 4 [label = "+", style="dotted"];
                  4 -> 6 [label = "+", style="dotted"];
          }
          1 [label = "Disco\n1: 1TB"];
          2 [label = "Disco\n2: 1TB"];
          3 [label = "Disco\n3: 1TB"];
          4 [label = "Disco\n4: 1TB"];
          5 [label = "Disco\n5: 1TB"];
          6 [label = "Disco\n6: 1TB"];
  }
#+end_src

Con RAID nivel 10 creamos volúmenes que suman por franjas unidades en
espejo (un volumen RAID 0 compuesto de varios volúmenes RAID 1). En
caso de fallar cualquiera de las unidades del arreglo, ésta puede ser
reemplazada fácilmente, y su reemplazo no significará un trabajo tan
intensivo para el arreglo entero, sólo para su disco espejo.

Bajo este esquema, en el peor de los casos, en un volumen con $n$
discos físicos tendríamos $n \over 2$ volúmenes nivel 1, y por tanto
podríamos soportar la pérdida de hasta $n \over 2$ discos — Siempre
que estos no formen parte de un mismo volumen nivel 1.

Ahora bien, esta combinación nos ilustra cómo el órden de los
factores /sí altera/ el producto: Si en vez de la concatenación de
varias unidades espejeadas (un volumen nivel 0 compuesto de varios
volúmenes nivel 1) armáramos nuestro arreglo en órden inverso, esto
es, como el espejeo de varias unidades concatenadas por franjas,
parecería que obtenemos los mismos beneficios — Pero analizando lo
que ocurre en caso de falla, resulta claro que el nivel de
redundancia resulta mucho menor.

#+attr_latex: width=0.65\textwidth
#+caption: Seis discos organizados en RAID 0+1
#+begin_src dot :exports results :file ltxpng/raid_01.png
  digraph G {
	  node [shape=circle];
          rankdir=LR;

          subgraph cluster_resulta {
                  label = "Volumen RAID0\nresultante (3TB)";
		  subgraph cluster_vol1 {
			  label = "Subvolumen RAID1\n 1 (3TB)";
			  1 -> 2 [label = "+"];
			  2 -> 3 [label = "+"];
		  }
		  subgraph cluster_vol2 {
			  label = "Subvolumen RAID1\n2 (3TB)";
			  4 -> 5 [label = "+", style = dotted];
			  5 -> 6 [label = "+", style = dotted];
		  }
		  1 -> 4 [label = "=", dir = both, color = blue];
		  2 -> 5 [label = "=", dir = both, color = blue];
		  3 -> 6 [label = "=", dir = both, color = blue];
          }
          1 [label = "Disco\n1: 1TB"];
          2 [label = "Disco\n2: 1TB"];
          3 [label = "Disco\n3: 1TB"];
          4 [label = "Disco\n4: 1TB"];
          5 [label = "Disco\n5: 1TB"];
          6 [label = "Disco\n6: 1TB"];
  }
#+end_src

En este caso, nuestro arreglo soportará también el fallo de hasta $n
\over 2$ de sus discos, pero únicamente si ocurren en el mismo volumen
del espejo. Si se perdieran al mismo tiempo el disco 1 (del
subvolumen 1) y el disco 5 (del subvolumen 2), tendríamos pérdida de
datos.

** Más allá de RAID

Los esquemas RAID vienen, sin embargo, de fines de la década de 1980,
y en los más de 20 años desde que fueron planteados, si bien han
cambiado el panorama del almacenamiento, han sido ya superados. En
nuestro caso, profundizamos en estos esquemas y no los desarrollos
posteriores dada la limpieza conceptual que presentan, y dado que
otros esquemas incluso hacen referencia al nivel de RAID que
/estarían reemplazando/ en su documentación.

Varios sistemas operativos ofrecen hoy el concepto de un /gestor de
volúmenes lógicos/: Una interfaz que permite, como dos pasos
independientes, agregar diferentes /volúmenes físicos/ a un 

* Otros recursos
- Practical File System Design (Dominic Giampaolo, 1999): El autor fue
  parte del equipo que implementó el sistema operativo BeOS, un
  sistema de alto rendimiento pensado para correr en estaciones de
  alto rendimiento, particularmente enfocado al video. El proyecto
  fracasó a la larga, y BeOS (así como BeFS, el sistema que describe)
  ya no se utilizan. Este libro tiene una muy buena descripción de
  varios sistemas de archivos, y aborda a profundidad técnicas que
  hace 15 años eran verdaderamente novedosas, y hoy forman parte de
  casi todos los sistemas de archivos con uso amplio, e incluso
  algunas que no se han logrado implementar y que BeFS sí ofrecía.

- [[http://www.codeguru.com/cpp/cpp/cpp_mfc/files/article.php/c13831/FAT-Root-Directory-Structure-on-Floppy-Disk-and-File-Information.htm][FAT Root Directory Structure on Floppy Disk and File Information]]
  (Mufti Mohammed, Codeguru, 2007)

- [[http://www.beginningtoseethelight.org/fat16/index.htm][File Allocation Table - 16bit]] (Peter Clark)

- [[http://www.cs.berkeley.edu/~brewer/cs262/FFS.pdf][A Fast File System for UNIX]] (Marshall Kirk Mckusick, William N. Joy,
  Samuel J. Lefler, Robert S. Fabry, 1984)

- [[http://www.cs.berkeley.edu/~brewer/cs262/LFS.pdf][The Design and Implementation of a Log-Structured File System]]
  (Mendel Rosenblum, J. K. Ousterhout, 1992)

- [[http://www.nongnu.org/ext2-doc/][The Second Extended File System: Internal Layout]] (Dave Poirier,
  2001-2011)

- [[http://www.cyanezfdz.me/nilfs2-en-linux.html][NILFS2 en Linux]] (César Yáñez)

- [[http://www.cyanezfdz.me/los-discos-desde-la-perspectiva-de-un-sistema-de-archivos.html][Los discos desde la perspectiva de un sistema de archivos]] (César
  Yáñez)

- [[http://lwn.net/Articles/529077/][A hash-based DoS attack on Btrfs]] (LWN)

- [[http://linux.slashdot.org/story/12/12/15/0055217/denial-of-service-attack-found-in-btrfs-file-system][Denial-of-Service Attack Found In Btrfs File-System]] (Slashdot)

- [[http://bugs.debian.org/cgi-bin/bugreport.cgi?archive=no&bug=682840][Default /etc/apache2/mods-available/disk_cache.conf is incompatible
  with ext3]] (bug de Debian ilustrando los límites en números de
  archivos para Ext3)

- [[http://delivery.acm.org/10.1145/150000/146943/p26-rosenblum.pdf][The Design and Implementation of a Log-Structured File System]] (John
  K. Ousterhout, Mendel Rosenblum, 1992)

- [[http://www.informatik.uni-osnabrueck.de/papers_pdf/2005_07.pdf][LogFS — Finally a scalable flash file system]] (Jörn Engel, Robert
  Mertens, 2005)

- [[https://lwn.net/Articles/353411/][Log-structured file systems: There's one in every SSD]] (Valerie
  Aurora, 2009)

- [[http://lwn.net/Articles/528617/][JFFS2, UBIFS, and the growth of flash storage]] (Neil Brown, 2012)

- [[http://www.cs.cmu.edu/%7Egarth/RAIDpaper/Patterson88.pdf][A case for Redundant Arrays of Inexpensive Disks]] (Patterson,
  Gibson, Katz 1988)

- [[http://insecurityit.blogspot.mx/2013/06/unidades-de-estado-solido-el-reto-de-la.html][Unidades de estado sólido. El reto de la computación forense en el
  mundo de los semiconductores]] (Cano Martinez, 2013)

- [[http://dx.doi.org/10.1038/ncomms2990][Non-volatile memory based on the ferroelectric photovoltaic effect]]
  (Guo, You, Zhow et. al., 2013)
