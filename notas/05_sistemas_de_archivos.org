#+SETUPFILE: ../setup_notas.org
#+TITLE: Sistemas Operativos — Sistemas de archivos

* Concepto de archivo

De los roles que cumple el sistema operativo, probablemente el que más
consciente tengan en general sus usuarios es el de la gestión del
espacio de almacenamiento, esto es, el sistema de archivos. Al día de
hoy, todos los usuarios de equipo de cómputo dan por sentado y
comprenden a grandes rasgos la organización del espacio de
almacenamiento en un /directorio jerárquico/, con unidades de
almacenamiento llamadas /archivos/, de diferentes tipos según su
función. En la primer parte de esta unidad revisaremos algo más a
profundidad a este modelo, para posteriormente ver los detalles de la
gestión del espacio físico donde éstos están alojados.

La abstracción que hoy conocemos como /archivos/ es una de las que más
tiempo han vivido y se han mantenido a lo largo de la historia de la
computación, sobreviviendo a lo largo de prácticamente todas las
generaciones de sistemas operativos.

En primer término, un archivo es un /tipo de datos abstracto/ — Esto
es, en programación moderna podríamos verlo como una estructura que
exclusivamente permite que la manipulemos por medio de una interfaz
/orientada a objetos/: Los procesos en el sistema sólo pueden tener
acceso a los archivos por medio de la interfaz ofrecida por el sistema
operativo.[fn:: Veremos más adelante que esto no es /necesariamente/
cierto, sin embargo, el uso de los dispositivos /en crudo/ es tan bajo
que podemos ignorarlos para propósitos de esta discusión] Abordaremos
los detalles de esta interfaz [[#operaciones_con_archivos][en breve]].

Para el usuario, los archivos son la /unidad lógica mínima/ al hablar
habla de almacenamiento: Todo el almacenamiento /persistente/ (que
sobrevive en el tiempo, sea a reinicios del sistema, a pérdida de
corriente o a otras circunstancias en el transcurso normal de
ejecución) en el sistema al que tiene acceso, se efectúa dentro de
archivos; el espacio libre en los diferentes dispositivos no tiene
mayor existencia fuera de saber que está /potencialmente/ disponible.

Dentro de cada /volúmen/ (cada medio de almacenamiento), los archivos
disponibles conforman a un /directorio/, y son típicamente
identificados por un /nombre/ o una /ruta/. Hablaremos más adelante
acerca de las diferentes construcciones semánticas que pueden
conformar a los directorios.

** Operaciones con archivos
#<<operaciones_con_archivos>>

Cada sistema operativo definirá la interfaz de archivos acorde con su
semántica, pero en líneas generales, las operaciones que siempre
estarán disponibles con un archivo son:

- Crear :: Asigna espacio en el dispositivo y en su directorio para
           alojar a un nuevo archivo.

- Borrar :: Elimina al archivo del directorio y, de ser procedente,
            libera el espacio del dispositivo

- Abrir :: Solicita al sistema operativo verificar si tenemos el
           acceso para el /modo de acceso/ al archivo que indiquemos y
           si el medio lo soporta (por ejemplo, a pesar de contar con
           los permisos, no podemos abrir para escritura un archivo en
           un disco de sólo lectura), y asigna un /descriptor de
           archivos/ que identifica la relación entre el proceso y el
           archivo en cuestión. Abrir un archivo es necesario para
           todas las siguientes operaciones.

- Cerrar :: Indica al sistema que /el proceso en cuestión/ terminó de
            trabajar con el archivo; el sistema entonces debe vaciar
            los buffers a disco y eliminar la entrada que representa a
            esta combinación archivo-proceso de las tablas activas,
            invalidando al /descriptor de archivo/. Si un proceso
            cierra un archivo y quiere volver a emplearlo, tendrá que
            abrirlo explícitamente.

- Leer :: Cuando indicamos al sistema que queremos leer de un archivo
          hacia determinado buffer, éste copia el siguiente /pedazo/
          de información a éste. Este /pedazo/ podría ser una línea o
          un bloque de longitud definida, dependiendo del modo en que
          se solicite la lectura. El sistema mantiene un apuntador a
          la última posición leída, para poder /continuar/ con la
          lectura.

- Escribir :: Teniendo un archivo ya existente, guarda información en
              él. Puede ser que escriba desde su primer posición
              (/truncando/ al archivo, esto es, borrando toda la
              información que pudiera ya tener), o /agregando/ al
              archivo, esto es, iniciando con el apuntador de
              escritura al final del mismo.

- Reposicionar :: (/seek/) Tanto la lectura como la escritura se hacen
                  siguiendo a un /apuntador/, que indica cuál fue la
                  última posición del archivo a la que accesó el
                  proceso actual. Al reposicionar el apuntador,
                  podemos /brincar/ a otro punto del archivo.

Hay varias otras operaciones comunes que pueden implementarse con
llamadas compuestas a estas operaciones (por ejemplo, /copiar/ un
archivo puede implementarse como /crear/ un archivo nuevo en modo de
escritura, abrir en modo de lectura al fuente, e ir /leyendo/ de éste
y /escribiendo/ al nuevo hasta llegar al fin de archivo).

Las operaciones que presentamos recién no son /todas/ las operaciones
existentes; dependiendo del sistema operativo, habrá algunas
adicionales; estas las presentamos como la base general sobre la cual
trabajaremos.

Vale la pena mencionar que esta semántica para el manejo de archivos
presenta a cada archivo como si fuera una /unidad de cinta/,
permitiéndonos avanzar o retroceder la cabeza lectora/escritora dentro
de ella.

** Tablas de archivos abiertos

Tanto el sistema operativo como cada uno de los procesos mantienen
normalmente /tablas de archivos abiertos/. Estas mantienen información
acerca de todos los archivos actualmente abiertos, presentándolos
hacia el proceso por medio de un /descriptor de archivo/; una vez que
un archivo fue abierto, las operaciones que se realizan dentro de éste
no son empleando su nombre, sino que su descriptor de archivos.

En un sistema operativo multitareas, más de un proceso podría abrir el
mismo archivo a la vez; lo que cada uno de ellos pueda hacer, y cómo
esto impacte a lo que vean los demás procesos, depende de la semántica
que implemente el sistema.

Ahora, ¿por qué mencionamos que estas tablas son mantenidas tanto por
el sistema operativo como por cada uno de los procesos? ¿No nos lleva
esto a una situación en que mantenemos información redundante?

La respuesta es que la información que cada uno debe manejar es
distinta. El sistema operativo necesita:

- Conteo de usuarios del archivo :: Cuando se solicita, por ejemplo,
     /desmontar/ una partición (por ejemplo, para expulsar una unidad
     removible) o eliminar un archivo, el sistema debe poder
     determinar cuándo es momento de declarar la solicitud como
     /efectuada/. Si algún proceso tiene abierto a un archivo, y
     particularmente si tiene cambios pendientes de guardar, el
     sistema no debe permitir que el archivo /desaparezca/ de su
     visión.
- Modos de acceso :: Aunque un usuario tenga permisos de acceso a
     determinado recurso, el sistema puede determinar negarlo si
     llevaría a una inconsistencia. Por ejemplo, si dos procesos abren
     un mismo archivo para escritura, es probable que los cambios que
     realice uno sobreescriban a los que haga el otro.
- Ubicación en disco :: Para evitar que cada proceso tenga que
     consultar las tablas en disco para encontrar al archivo, o sus
     fragmentos.
- Información de bloqueo :: En caso de que los modos de acceso del
     archivo requieran protección mutua, puede implementarse por
     medio de un bloqueo.

Por otro lado, el proceso necesita:

- Descriptor de archivo :: Relación entre el nombre del archivo
     abierto y el identificador numérico que maneja internamente el
     proceso. Un archivo abierto por varios procesos tendrá
     descriptores de archivo distintos en cada uno de ellos. El
     descriptor de archivo es un número entero.
- Permisos :: Los modos válidos de acceso para un archivo. Esto no
              necesariamente es igual a los permisos que tiene el
              archivo en cuestión en disco, sino que el /subconjunto/
              de dichos permisos bajo los cuales está operando para
              este proceso en particular — Si un archivo fue abierto
              en modo de sólo lectura, por ejemplo, este campo
              sólo permitirá la lectura.

** Acceso concurrente: Bloqueo de archivos

Dado que los archivos pueden emplearse como mecanismo de comunicación
entre procesos que no guarden relación entre sí, incluso a lo largo
del tiempo, y para emplear un archivo basta indicar su nombre o ruta,
los sistemas operativos multitarea implementan mecanismos de bloqueo
para evitar que varios procesos intentando emplear de forma
concurrente a un archivo se corrompan mutuamente.

Algunos sistemas operativos permiten establecer bloqueos sobre
determinadas regiones de los archivos, aunque la semántica más común
es operar sobre el archivo como una sola unidad.

En general, la nomenclatura que se sigue para los bloqueos es:

- Compartido :: (/Shared lock/) Podría verse como equivalente a un
                bloqueo (o /candado/) para realizar lectura — Varios
                procesos pueden adquirir al mismo tiempo un bloqueo de
                lectura, e indica que todos los que posean dicho
                /candado/ tienen la expectativa de que el archivo no
                sufrirá modificaciones.
- Exclusivo :: (/Exclusive lock/) Un bloqueo o /candado/ exclusivo
               puede ser adquirido por un sólo proceso, e indica que
               realizará operaciones que modifiquen al archivo (o, si
               la semántica del sistema operativo permite expresarlo,
               a la /porción/ del archivo que indica).

Respecto al /mecanismo/ de bloqueo, hay también dos tipos,
dependiendo de qué tan explícito tiene que ser su manejo:

- Mandatorio u obligatorio :: (/Mandatory locking/) Una vez que un
     proceso adquiere un candado obligatorio, el sistema operativo se
     encargará de imponer las restricciones corresponidentes de acceso
     a todos los demás procesos, independientemente de si éstos fueron
     programados para considerar la existencia de dicho bloqueo o no.
- Consultivo o asesor :: (/Advisory locking/) Este tipo de bloqueos
     es manejado exclusivamente entre los procesos involucrados, y
     depende del programador de /cada uno/ de los programas en
     cuestión el solicitar y respetar dicho bloqueo.

Haciendo un paralelo con los mecanismos presentados en la [[./02_administracion_de_procesos.org][unidad de
administración de procesos]], los mecanismos que emplean mutexes,
semáforos o variables de condición serían /consultivos/, y únicamente
los que emplean monitores (en que la única manera de llegar a la
información es a través del mecanismo que la protege) serían
/mandatorios/.

De esta matriz de $2\times2$ tipos de bloqueo, no todos los sistemas
operativos implementan las cuatro posibilidaddes. Como regla general,
en los sistemas Windows se maneja un esquema de bloqueo obligatorio, y
en sistemas Unix es de bloqueo consultivo.[fn:: Esto explica por qué
en Windows es tan común que el sistema mismo nos rechace hacer
determinada operación porque /el archivo está abierto por otro
programa/ (bloqueo mandatorio compartido), mientras que en Unix esta
responsabilidad recae en cada uno de los programas de aplicación]

Cabe mencionar que el manejo de bloqueos con archivos requiere del
mismo cuidado que el de bloqueo por recursos que el que vimos en
/administración de procesos/: Dos procesos intentando adquirir un
candado exclusivo sobre dos archivos pueden caer en un bloqueo mutuo
tal como ocurre con cualquier otro recurso externo.

** Tipos de archivo

Si los archivos son, como dijimos, la /unidad lógica mínima/ con la
que se puede guardar información en almacenamiento secundario,
naturalmente sigue que existen archivos de diferentes tipos — Un
archivo puede ser un documento de texto, un binario ejecutable, un
archivo de audio o video, y un larguísimo etcetera, e intentar emplear
a un archivo como uno de un tipo distinto puede resultar desde una
frustración al usuario porque el programa no responde como éste
quiere, hasta en pérdidas económicas.[fn:: Por ejemplo, imprimir un
archivo binario resulta en una gran cantidad de hojas inútiles,
particularmente tomando en cuenta que hay caracteres de control como
el ASCII 12 (avance de forma, /form feed/), que llevan a las
impresoras que operan en modo texto a iniciar una nueva página; llevar
a un usuario a correr un archivo ejecutable /disfrazado/ de un
documento inocuo, como veremos a continuación, fue un importante
vector de infección de muchos virus.]

Hay tres estrategias principales para que el sistema operativo
reconozca al tipo de un archivo:

- Extensión :: En los sistemas CP/M de los 1970, el nombre de cada
               archivo se dividía en dos porciones, empleando como
               separador al punto: El nombre del archivo y su
               extensión. El sistema mantenía una lista de extensiones
               conocidas, para las cuales sabría cómo actuar, y este
               diseño se extendería a las aplicaciones, que sólo
               abrirían a aquellos archivos cuyas extensiones
               supieran manejar.

	       Esta estrategia fue heredada por VMS y MS-DOS, de
               donde la adoptó Windows; ya en el contexto de un
               entorno gráfico, Windows agrega, más allá de las
               extensiones directamente ejecutables, la relación de
               extensiones con los programas capaces de trabajar con
               ellas, permitiendo invocar a un programa con sólo dar
               ``doble click'' en un documento.

	       Como nota, este esquema de asociación de tipo de
               archivo permite ocultar las extensiones toda vez que ya
               no requieren ser del conocimiento del usuario, sino que
               son gestionadas por el sistema operativo, abre una vía
               de ataque automatizado que se popularizó en su momento:
               El envío de correos con extensiones engañosas
               duplicadas — Esto es, el programa maligno (un /programa
               troyano/) se envía a todos los contactos del usuario
               infectado, presentándose por ejemplo como una imágen,
               con el nombre =inocente.png.exe=. Por el esquema de
               ocultamiento mencionado, éste se presenta al usuario
               como =inocente.png=, pero al abrirlo, el sistema
               operativo lo reconoce como un ejecutable, y lo ejecuta
               en vez de abrirlo en un visor de imágenes.

- Números mágicos :: La alternativa que emplean los sistemas Unix es,
     como siempre, simple y /elegante/, aunque indudablemente presenta
     eventuales lagunas: El sistema mantiene una lista compilada de
     las /huellas digitales/ de los principales formatos que debe
     manejar,[fn:: Una de las ventajas de este esquema es que cada
     administrador de sistema puede ampliar la lista con las huellas
     digitales que requiera localmente] para reconocer el contenido
     de un archivo basado en sus primeros bytes.

     Casi todos los formatos de archivo incluyen lo necesario para que
     se lleve a cabo este reconocimiento, y cuando no es posible
     hacerlo, se intenta por medio de ciertas reglas /heurísticas/.
     Por ejemplo, todos los archivos de imágen en /formato de
     intercambio gráfico/ (GIF) inician con la cadena =GIF87a= o
     =GIF89a=, dependiendo de la versión; los archivos del lenguaje de
     descripción de páginas PostScript inician con la cadena =%!=, el
     /Formato de Documentos Portátiles/ (PDF) con =%PDF=, etcétera. Un
     documento en formatos definidos alrededor de XML inicia con
     =<!DOCTYPE=.  Algunos de estos formatos no están /anclados/ al
     inicio, sino que en un punto específico del primer bloque.

     Un caso especial de números mágicos es el llamado /hashbang/
     (=#!=). Esto indica a un sistema Unix que el archivo en cuestión
     (típicamente un archivo de texto, incluyendo código fuente en
     algún lenguaje de /script/) debe tratarse como un ejecutable, y
     empleando como /intérprete/ al comando indicado inmediatamente
     después del /hashbang/. Es por esto que podemos ejecutar
     directamente, por ejemplo, los archivos que inician con
     =#!/usr/bin/bash=: El sistema operativo invoca al programa
     =/usr/bin/bash=, y le especifica como argumento al archivo en
     cuestión.

- Metadatos externos :: Los sistemas de archivos empleado por las
     Apple Macintosh desde 1984 separan en dos /divisiones/ (/forks/)
     la información de un archivo: Los datos que propiamente
     constituyen al archivo en cuestión son la /división de datos/
     (/data fork/), y la información /acerca del archivo/ se guardan
     en una estructura independiente llamada /división de recursos/
     (/resource fork/).

     Esta idea resultó fundamental para varias de las características
     /amigables al usuario/ que presentó Macintosh desde su
     introducción — Particularmente, para presentar un entorno gráfico
     que respondiera ágilmente, sin tener que buscar los datos base de
     una aplicación dentro de un archivo de mucho mayor tamaño. La
     /división de recursos/ cabe en pocos sectores de disco, y si
     tomamos en cuenta que las primeras Macintosh funcionaban
     únicamente con discos flexibles, el tiempo invertido en leer una
     lista de iconos podría ser demasiada.

     La división de recursos puede contener todo tipo de
     información; los programas ejecutables son los que le dan un
     mayor uso, dado que incluyen desde los aspectos gráficos (icono
     a mostrar para el archivo, ubicación de la ventana a ser
     abierta, etc.) hasta aspectos funcionales, como la traducción de
     sus cadenas al lenguaje particular del sistema en que está
     instalado. Esta división permite una gran flexibilidad, dado que
     no es necesario tener acceso al fuente del programa para crear
     traducciones y temas.

     En el tema particular que en esta sección nos concierne, la
     división de recursos incluye un campo /creador/, que indica qué
     programa fue el que creó al archivo, mismo que será llamado
     en caso de que el usuario invoque directamente al archivo.

     Las versiones actuales de MacOS ya no emplean esta técnica, sino
     que una llamada /appDirectory/, para propósitos de esta
     discusión, la técnica base es la misma.

** Estructura de los archivos y métodos de acceso

La razón principal de la existencia del sistema de archivos son /los
archivos/. Un archivo almacena información de /algún tipo/,
estructurado o no estructurado.

La mayor parte de los sistemas operativos maneja únicamente archivos
/sin estructura/ — Cada aplicación es responsable de preparar la
información de forma congruente, y la responsabilidad del sistema
operativo es únicamente entregarlo como un conjunto de bytes. Ha
habido sistemas de archivos históricos, como IBM CICS (1968), IBM MVS
(1974) o DEC VMS (1977), que administraban ciertos tipos de datos en
un formato básico de /base de datos/.

El que el sistema operativo no imponga estructura a un archivo no
significa, claro está, que la aplicación que lo genera no lo haga. La
razón por la que los sistemas creados en los últimos 30 años no han
implementado este esquema de base de datos es que le /resta/
flexibilidad al sistema: El que una aplicación tuviera que ceñirse a
los tipos de datos y alineación de campos del sistema operativo
impedía su adecuación, y el que la funcionalidad de un archivo tipo
base de datos dependiera de la versión del sistema operativo creaba
un /acoplamiento/ demasiado rígido entre el sistema operativo y las
aplicaciones: Hoy en día es mucho más común ver que los programas que
requieren gestores de base de datos interactúen con uno, implementado
independientemente en espacio de usuario, o incluso que /liguen/ con
un gestor implementado como biblioteca, como es el caso de /SQLite/
(que es empleado por herramientas de adquisición de datos tan de bajo
nivel como /systemtap/, y por herramientas tan de escritorio como el
gestor de fotografías /shotwell/ o el navegador /Firefox/).

Podemos ver aún un remanente de los archivos estructurados en los
sistemas derivados de MS-DOS: En estos sistemas, un archivo puede ser
/de texto/ o /binario/. Un archivo de texto está compuesto por una
serie de caracteres que forman /líneas/, y la separación entre una
línea y otra constituye de un /retorno de carro/ (=CR=, caracter
ASCII 13) seguido de un /salto de línea/ (=LF=, caracter ASCII
10).[fn:: Esta lógica es herencia de las máquinas de escribir
manuales, en que el /salto de línea/ (avanzar el rodillo a la línea
siguiente) era una operación distinta a la del /retorno de carro/
(devolver la cabeza de escritura al inicio de la línea). En la época
de los teletipos, como medida para evitar que se perdieran caracteres
mientras la cabeza volvía hasta la izquierda, se decidió separar el
inicio de nueva línea en los dos pasos que tienen las máquinas de
escribir, para inducir una demora que evitara la pérdida de
información.]

El acceso a los archivos puede realizarse de diferentes maneras:

- Acceso secuencial :: Mantiene la semántica por medio de la cual
     pudiéramos leer de nuestros archivos fuera la equivalente a
     unidad de cinta que mencionamos en la sección [[#operaciones_con_archivos][Operaciones con
     archivos]]: El mecanismo principal para leer o escribir es ir
     avanzando consecutivamente por los bloques que conforman al
     archivo hasta llegar a su final.

     Típicamente emplearemos este mecanismo de lectura para leer a
     memoria código (programas o bibliotecas) o documentos, sea
     enteros o fracciones de los mismos. Para un contenido
     estructurado, como una base de datos, resultaría absolutamente
     ineficiente, dado que no conocemos el punto de inicio o
     finalización de cada uno de los registros, y probablemente
     tendríamos que hacer /barridos secuenciales/ del archivo completo
     para cada una de las búsquedas.

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Archivo de acceso secuencial
#+begin_src ditaa :file ltxpng/acceso_secuencial.png :cmdline -E
          Lectura -=->
             |
             V
-=-+--------------------------------------------------------------------------+-=-
   |...Nombre##Gonzalo;Apellido##Oliva;Nombre##Raquel;Apellido##Domínguez;E...|
-=-+--------------------------------------------------------------------------+-=-
#+end_src
#+html: <p align="center">Archivo de acceso secuencial</p></div>

- Acceso aleatorio :: El empleo de gestores como /SQLite/ u otros
     muchos motores de base de datos más robustos no nos exime de
     pensar en nuestro archivo como una tabla estructurada. Si la
     única semántica por medio de la cual pudiéramos leer de nuestros
     archivos fuera la equivalente a una unidad de cinta, implementar
     el acceso a un punto determinado del archivo podría resultar
     demasiado gravoso.

     Afortunadamente, el que el sistema operativo no imponga registros
     de longitud fija no impide que /el programa gestor/ lo haga. Si
     en el archivo al cual apunta el descriptor de archivos =FD=
     tenemos 2000 registros de 75 bytes cada uno y necesitamos
     recuperar el registro número 65 hacia el buffer =registro=,
     /reposicionamos/ el apuntador de lectura al byte $65 \times 75 =
     4875$ (=seek(FD, 4875)=) y leemos los siguientes 75 bytes en
     =registro= (=read(FD, *registro, 75)=).

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Archivo de acceso aleatorio
#+begin_src ditaa :file ltxpng/acceso_aleatorio.png :cmdline -E

       +--------+-----------+-----------+-------------------+--------------+-------------+
       | Nombre | Apellido  | Teléfono  | Correo            | ultimaSesion | usuarioDesde|
     0 +--------+-----------+-----------+-------------------+--------------+-------------+
       :        :           :           :                   :              :             :
       : ...    : ...       : ...       : ...               : ...          : ...         :
  4800 +--------+-----------+-----------+-------------------+--------------+-------------+
       | José   | Chávez    | 5154-4553 | chavez@aqui.no.es | 2013.04.05   | 2012.01.15  |
  4875 +--------+-----------+-----------+-------------------+--------------+-------------+
------>| Gonzalo| Oliva     |           |                   |              |             |
  4950 +--------+-----------+-----------+-------------------+--------------+-------------+
       | Raquel | Domínguez |           | rdomgz@aca.si.es  |              |             |
  5025 +--------+-----------+-----------+-------------------+--------------+-------------+
       :        :           :           :                   :              :             :
       : ...    : ...       : ...       : ...               : ...          : ...         :
150000 +--------+-----------+-----------+-------------------+--------------+-------------+
#+end_src
#+html: <p align="center">Archivo de acceso aleatorio</p></div>

- Acceso relativo a índice :: En los últimos años se han popularizado
     los gestores de base de datos /no estructurados/ u /orientados a
     texto/, llamados genéricamente /NoSQL/. Estos gestores pueden
     guardar registros de tamaño variable en disco, por lo que no
     podríamos encontrar la ubicación correcta por medio de los
     mecanismos de acceso aleatorio.

     Para implementar este acceso, se divide al conjunto de datos en
     dos secciones (incluso, posiblemente, en dos archivos
     independientes): La primer sección es una lista corta de
     identificadores, cada uno con el punto de inicio y término de
     los datos a los que apunta. Para leer un registro, se emplea
     acceso aleatorio sobre el índice, y el apuntador se avanza a la
     ubicación específica que se solicita.

     En el transcurso de un uso intensivo de esta estructura, dado que
     la porción de índice es muy frecuentemente consultada y
     relativamente muy pequeña, muy probablemente se mantenga completa
     en memoria, y el acceso a cada uno de los registros puede
     resolverse en tiempo muy bajo.

     La principal desventaja de este modelo de indexación sobre
     registros de longitud variable es que sólo resulta eficiente
     para contenido /mayormente de lectura/: Cada vez que se produce
     una escritura y cambia la longitud de los datos almacenados, se
     va generando fragmentación en el archivo, y para resolverla
     probablemente se hace necesario suspender un tiempo la ejecución
     de todos los procesos que estén empleando al archivo en cuestión
     (e invalidar, claro, todas las copias en caché de los
     índices). Ahora bien, mientras se mantenga como mayormente de
     lectura, este formato tendrá la ventaja de no desperdiciar
     espacio en los campos nulos o de valor irrelevante para algunos
     de los registros.

     Además de esto, la escritura en ambas partes de la base de datos
     debe mantenerse con garantías de atomicidad — Si se pierde la
     sincronía entre índice y datos, nos enfrentamos a una muy
     probable corrupción de datos.

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Acceso relativo a índice: Un índice apuntando al punto justo de un archivo sin estructura
#+begin_src ditaa :file ltxpng/acceso_relativo_a_indice.png :cmdline -E
+-----------+--------+--------+
| Apellido  | Inicio | Tamaño |
+-----------+--------+--------+
| Chávez    |     0  |    132 |
+-----------+--------+--------+
| Domínguez |   163  |    200 |        +--------------------+
+-----------+--------+--------+     63 |...fono##5154-4553;E|  82
| Godoy     |   428  |     62 |     83 |mail##chavez@aqui.no| 102
+-----------+--------+--------+    103 |.es;ultimaSesion##20| 122
| Oliva     |    132 |     31 +------->+13.04.05;Nombre##Gon| 142
+-----------+--------+--------+    143 |zalo;Apellido##Oliva| 162
| Vázquez   |   408  |     20 |    163 |;Nombre##Raquel;Apel| 182
+-----------+--------+--------+    183 |lido##Domínguez;E...| 202
| Zapata    |   363  |     45 |        +--------------------+
+-----------+--------+--------+
#+end_src
#+html: <p align="center">Acceso relativo a índice: Un índice apuntando al punto justo de un archivo sin estructura</p></div>

** Transferencias orientadas a bloques

Un sistema de archivos es la representación que se da a un conjunto
de archivos y directorios sobre un /dispositivo orientado a bloques/;
un /dispositivo orientado a bloques/ es uno que, para cualquier
transferencia que solicitemos desde o hacia él, nos responderá con un
bloque de tamaño predefinido.

Esto es, si bien el sistema operativo nos presenta una abstracción
por medio de la cual la lectura (=read()=) puede ser de un tamaño
arbitrario, todas las transferencias de datos desde cualquiera de los
discos serán de un múltiplo del tamaño de bloques (típicamente 512
bytes).

Cuando leemos, como en el ejemplo anterior, sólamente un registro
de 75 bytes, el sistema operativo lee el bloque completo y
probablemente lo mantiene en un caché en la memoria principal; si en
vez de una lectura, la operación que efectuamos fue una de escritura
(=write()=), y el sector que vamos a modificar no ha sido leído aún a
memoria (o fue leído hace mucho, y puede haber sido expirado del
caché), el sistema tendrá que leerlo nuevamente, modificarlo en
memoria, y volver a guardarlo a disco.


* Organización de archivos

Hasta ahora, nos hemos enfocado en qué es y cómo se maneja un
archivo. Sin embargo, no hablaríamos de /sistemas de archivos/ si no
tuviéramos una gran cantidad de archivos. Es común que en un sólo
medio de almacenamiento de un equipo de uso doméstico tengamos a
/decenas de miles/ de archivos, y en equipos dedicados, no está fuera
de lugar tener cientos o miles de veces tanto. Por tanto, tenemos que
ver también cómo se organiza una gran cantidad de archivos.

** Evolución del concepto de /directorio/

El concepto dominante en almacenaimiento hoy en día es el /directorio
jerárquico/. Demos un breve repaso acerca de su historia.

*** Convenciones de nomenclatura

Cada sistema de archivos puede determinar cuántos y qué caracteres
son válidos para designar a uno de sus elementos, y cuáles son
separadores válidos. El caracter que se emplea para separar los
elementos de un directorio no es un estándar a través de todos los
sistemas operativos — Los más comunes que encontraremos hoy en día
son la diagonal (=/=), empleada en sistemas tipo Unix y derivados
(incluyendo MacOS X y Android), y la diagonal invertida ($\backslash$),
empleada en CP/M y derivados, incluyendo MS-DOS y Windows.

Diversos sistemas han manejado otros caracteres (por ejemplo, el MacOS
histórico empleaba los dos puntos, =:=), y aunque muchas veces los
mantenían ocultos del usuario a través de una interfaz gráfica rica,
los programadores siempre tuvieron que poder especificarlos.

A lo largo del presente texto manejaremos la diagonal (=/=) como
separador de directorios.

*** Sistema de archivos /plano/

Los primeros sistemas de archivos limitaban el concepto de directorio
a una representación plana de los archivos que lo conformaban, sin
ningún concepto de /jerarquía de directorios/ como el que hoy nos es
natural. Esto se debía, en primer término, a lo limitado del espacio
de almacenamiento de las primeras computadoras en implementar esta
metáfora (los usuarios no dejaban sus archivos a largo plazo en el
disco, sino que los tenían ahí meramente cuando les eran útiles), y en
segundo término, a que no se había aún desarrollado un concepto de
separación, permisos y privilegios como el que poco después
aparecería.

En las computadoras personales los sistemas de archivos eran también
planos en un primer momento, pero por otra razón: En los sistemas
/profesionales/ ya se había desarrollado el concepto; al aparecer la
primer computadora personal en 1975, ya existían incluso las primeras
versiones de Unix diseñadas para trabajo en red. La prioridad en los
sistemas personales era mantener el código del sistema operativo
simple, mínimo. Con unidades de disco capaces de manejar entre 80 y
160KB, no tenía mucho sentido implementar directorios — Si un usuario
quisiera llevar a cabo una división temática de su trabajo, lo
colocaría en distintos /discos flexibles/. El sistema operativo CP/M
nunca soportó jerarquías de directorios, como tampoco lo hizo la
primer versión de MS-DOS[fn:: el soporte de jerarquías de directorios
fue introducido apenas en la versión 2, junto con el soporte a discos
duros de 10MB, con la IBM XT].

El sistema de archivos original de la Apple Macintosh, MFS, estaba
construido sobre un modelo plano, pero presentando la /ilusión/ de
directorios de una forma comparable a las etiquetas: Existían bajo
/ciertas/ vistas (pero notoriamente no en los diálogos de abrir y
grabar archivos), pero el nombre de cada uno de los archivos tenía que
ser único, dado que el direcorio al que pertenecía era básicamente
sólo un atributo del archivo.

Y contrario a lo que dicta la intuición, el modelo de directorio plano
no ha desaparecido: El sistema de /almacenamiento en la nube/ ofrecido
por el servicio /Amazon S3/ (/Simple Storage Service/, /Servicio
Simple de Almacenamiento/) maneja únicamente /objetos/ (comparable con
nuestra definición de archivos) y /cubetas/ (que reconoceríamos como
/unidades/ o /volúmenes/), y permite referirse a un objeto o un
conjunto de objetos en base a /filtros/ sobre el total que conforman a
una cubeta.

Probablemente a futuro nos encontremos con más ofertas como la de
Amazon S3, pero por ahora, continuemos sobre la línea histórica de los
directorios.

*** Directorios de profundidad fija

Las primeras implementaciones de directorios eran /de un sólo nivel/:
El total de archivos en un sistema podía estar dividido en
directorios, fuera por tipo de archivo (separando, por ejemplo,
programas de sistema, programas de usuario y textos del correo), por
usuario (facilitando una separación lógica de los archivos de un
usuario de pertenecientes a los demás usuarios del sistema)

El directorio /raiz/ (base) se llama en este esquema /MFD/ (/Master
File Directory/, /Directorio Maestro de Archivos/), y cada uno de los
directorios derivados es un /UFD/ (/User File Directory/, /Directorio
de Archivos de Usuario/).

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Directorio simple, limitado a un sólo nivel de profundidad
#+begin_src dot :exports results :file ltxpng/directorio_simple.png
  digraph G {
          subgraph cluster0 {
                  label = "MFD";
                  color=lightgray
                  style=filled;
                  sys;
                  mail;
                  usr1;
                  usr2;
          }
          subgraph cluster1 {
                  label="UFD: sys";
                  color=lightgray
                  style=filled;
                  list;
                  copy;
                  edit;
                  login;
          }
          subgraph cluster2 {
                  label="UFD: mail";
                  color=lightgray
                  style=filled;
                  m_usr1;
                  m_usr2;
          }
          subgraph cluster3 {
                  label="UFD: usr1";
                  color=lightgray
                  style=filled;
                  test_c1;
                  a_out;
          }
          subgraph cluster4 {
                  label="UFD: usr2";
                  color=lightgray
                  style=filled;
                  tarea_c;
                  instrucciones;
          }
          sys -> list;
          sys -> copy;
          sys -> edit;
          sys -> login;
  
          usr1 -> test_c1;
          usr1 -> a_out;
          usr2 -> tarea_c;
          usr2 -> instrucciones;
          mail -> m_usr1;
          mail -> m_usr2;
  
          sys [shape=box];
          mail [shape=box];
          usr1 [shape=box];
          usr2 [shape=box];
          test_c1 [label="test.c"];
          a_out [label="a.out"];
          tarea_c [label="tarea.c"];
          m_usr1 [label="usr1"];
          m_usr2 [label="usr2"];
  }
#+end_src

#+results:
[[file:ltxpng/directorio_simple.png]]
#+html: <p align="center">Directorio simple, limitado a un sólo nivel de profundidad</p></div>

Este esquema resuelve el problema principal del nombre global único:
Antes de los directorios, cada usuario tenía que cuidar que los
nombres de sus archivos fueran únicos en el sistema, y ya teniendo
cada uno su propio espacio, se volvió una tarea mucho más simple. La
desventaja es que, si el sistema restringe a cada usuario a escribir
en su UFD, se vuelve fundamentalmente imposible trabajar en algún
proyecto conjunto: No puede haber un directorio que esté tanto dentro
de =usr1= como de =usr2=, y los usuarios encontrarán más dificil
llevar un proyecto conjunto.

*** Directorios estructurados en árbol

El siguiente paso natural para este esquema es permitir una /jerarquía
ilimitada/: En vez de exigir que exista una capa de directorios, se le
puede /dar la vuelta/ al argumento, y permitir que cada directorio
pueda contener a otros archivos o directorios a niveles
arbitrarios. Esto permite que cada usuario (y que el administrador del
sistema) estructure su información siguiendo criterios lógicos y
piense en el espacio de almacenamiento como un espacio a largo plazo.

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Directorio estucturado en árbol
#+begin_src dot :exports results :file ltxpng/directorio_arbol.png
digraph G {
  root -> bin;
  root -> home;
  root -> lib;
  
  bin -> ls;
  bin -> cp;
  bin -> ed;
  bin -> login;

  lib -> libc;

  home -> usr1;
  home -> usr2;
  home -> usr3;

  usr1 -> test_c1;
  usr1 -> a_out;
  usr2 -> tarea_c2;
  usr2 -> instrucciones;
  usr3 -> tarea_c;
  usr3 -> a_out2;
  
  root [label="<raiz>", shape=box];
  bin [shape=box];
  home [shape=box];
  lib [shape=box];
  usr1 [shape=box];
  usr2 [shape=box];
  usr3 [shape=box];
  a_out [label="a.out"];
  test_c1 [label="test.c"];
  a_out2 [label="a.out"];
  tarea_c [label="tarea.c"];
  tarea_c2 [label="tarea.c"];
}
#+end_src

#+results:
[[file:ltxpng/directorio_arbol.png]]
#+html: <p align="center">Directorio estructurado en árbol</p></div>

Junto con esta estructura nacen las /rutas de búsqueda/ (/search
path/): Tanto los programas como las bibliotecas de sistema ahora
pueden estar en cualquier lugar del sistema de archivos. Al definirle
al sistema una /ruta de búsqueda/, el usuario operador puede
desentenderse del lugar exacto en el que está determinado programa —
El sistema se encargará de buscar en todos los directorios mencionados
los programas o bibliotecas que éste requiera.[fn:: La /ruta de
búsqueda/ refleja la organización del sistema de archivos en el
contexto de la instalación específica. Es común que la ruta de
búsqueda de un usuario estándar en Unix sea similar a
=/usr/local/bin:/usr/bin:/bin:~/bin= — Esto significa que cualquier
comando que sea presentado es buscado, en el órden indicado, en los
cuatro directorios presentados (separados por el caracter =:=, la
notación =~= indica el directorio personal del usuario activo). En
Windows, es común ver una ruta de búsqueda
=c:\WINDOWS\system32;c:\WINDOWS= ]

*** El directorio como un /grafo dirigido/

Si bien parecería que muchos de los sistemas de archivos que empleamos
hoy en día pueden modelarse suficientemente con un árbol, donde hay un
sólo nodo raiz, y donde cada uno de los nodos tiene un sólo nodo
padre, la semántica que ofrecen es en realidad un /superconjunto
estricto/ de esta: La de un grafo dirigido.

En un grafo dirigido, un mismo nodo puede tener varios directorios
/padre/, permitiendo por ejemplo que un directorio de trabajo común
sea parte del directorio personal de dos usuarios. Esto es, /el mismo
objeto/ está presente en más de un punto del árbol.

#+html: <div class="figure">
#+attr_latex: width=0.5\textwidth
#+caption: Directorio como un /grafo dirigido acíclico/: El directorio =proyecto= está tanto en el directorio =/home/usr1= como en el directorio =/home/usr2=
#+begin_src dot :exports results :file ltxpng/directorio_DAG.png
digraph G {
  root -> home;

  home -> usr1;
  home -> usr2;

  usr1 -> test_c1;
  usr1 -> a_out;
  usr1 -> proyecto;
  usr2 -> tarea_c2;
  usr2 -> proyecto;

  proyecto -> README;
  proyecto -> proy_c;

  root [label="<raiz>", shape=box];
  home [shape=box];
  usr1 [shape=box];
  usr2 [shape=box];
  proyecto [shape=box];
  a_out [label="a.out"];
  test_c1 [label="test.c"];
  tarea_c2 [label="tarea.c"];
  proy_c [label="proy.c"];
}
#+end_src

#+results:
[[file:ltxpng/directorio_DAG.png]]
#+html: <p align="center">Directorio como un /grafo dirigido acíclico/: El directorio <tt>proyecto</tt> está tanto en el directorio <tt>/home/usr1</tt> como en el directorio <tt>/home/usr2</tt></p></div>

Un sistema de archivos puede permitir la organización como un /grafo
dirigido/, aunque es común que la interfaz que presenta al usuario se
restrinja a un /grafo dirigido acíclico/: Las ligas múltiples son
permitidas, siempre y cuando no generen un ciclo.

La semántica de los sistemas Unix implementa directorios como grafos
dirigidos por medio de dos mecanismos:

- Liga dura :: La entrada de un archivo en un directorio Unix es la
               relación entre la ruta del archivo y el /número de
               i-nodo/ en el sistema de archivos.[fn:: Abordaremos a
               detalle el significado y la estructura de un i-nodo más
               adelante en esta misma unidad] Si tenemos un archivo
               existente y creamos una /liga dura/ a él, ésta es
               sencillamente otra entrada en el directorio apuntando
               al mismo /i-nodo/. Ambas entradas, pues, son el mismo
               archivo — No hay uno /maestro/ y uno /dependiente/.

	       En un sistema Unix, este mecanismo tiene sólo dos
               restricciones:
  1. Sólo se pueden hacer ligas duras dentro del mismo sistema de
     archivos

  2. No pueden hacerse ligas duras a directorios, sólo a archivos[fn::
     Formalmente, puede haberlas, pero sólo el administrador puede
     crearlas; detallaremos el por qué al hablar de [[#dir_traversal][recorrer los
     directorios]]]

- Liga simbólica :: Es un archivo /especial/, que meramente indica a
                    dónde apunta. El encargado de seguir este archivo
                    a su destino (esto es, de /resolver/ la liga
                    simbólica) es el sistema operativo mismo; un
                    proceso no tiene que hacer nada especial para
                    seguir la liga.

		    Una liga simbólica puede /apuntar/ a directorios,
                    incluso creando ciclos, o a archivos de otros
                    sistemas de archivos.

		    Cuando creamos una liga simbólica, la liga y el
                    archivo son dos entidades distintas. Si bien
                    cualquier proceso que abra al archivo destino
                    estará trabajando con la misma entidad, en caso de
                    que éste sea renombrado o eliminado, la liga
                    quedará /rota/, apuntando a una ubicación
                    inexistente.

Si bien estos dos tipos de liga existen también en los sistemas
Windows[fn:: Únicamente en aquellos que emplean el sistema de archivos
/NTFS/, no en los que están instalados sobre alguna de las variantes
de /FAT/ ], en dichos sistemas sigue siendo más común emplear los
/accesos directos/. Se denomina así a un archivo (identificado por su
extensión, =.lnk=), principalmente creado para poder /apuntar/ a los
archivos desde el escritorio y los menúes — Si un proceso solicita al
sistema abrir el /acceso directo/, no obtendrá al archivo destino,
sino que al acceso directo mismo.

Ahora, si bien tanto las ligas duras como las ligas simbólicas existen
también en Windows, su uso es muy poco frecuente. El API de Win32
ofrece las funciones necesarias, pero éstas no están reflejadas desde
la interfaz usuario del sistema — Y son sistemas donde el usuario
promedio no emplea una interfaz programador, sino que una interfaz
gráfica. Las ligas, podemos concluir, no son más empleadas por
/cuestión cultural/: En sus comunidades de usuarios, nunca fueron
frecuentes, por lo cual se mantienen como conceptos empleados sólo por
los /usuarios poderosos/.

Ya con el conocimiento de las ligas, podemos presentar la figura
anterior más apegada a la realidad: En los sistemas operativos (tanto
Unix como Windows), todo directorio tiene dos entradas especiales:
Los directorios =.= y =..=

#+html: <div class="figure">
#+attr_latex: width=0.5\textwidth
#+caption: Directorio como un /grafo dirigido/, mostrando los /enlaces ocultos/ =.= y =..=
#+begin_src dot :exports results :file ltxpng/directorio_DAG_completo.png
digraph G {
  root -> root [label="."];
  root -> root [label=".."];

  root -> home;
  home -> home [label="."];
  home -> root [label=".."];

  home -> usr1;
  usr1 -> home [label=".."];
  usr1 -> usr1 [label="."];
  home -> usr2;
  usr2 -> home [label=".."];
  usr2 -> usr2 [label="."];

  usr1 -> test_c1;
  usr1 -> a_out;
  usr1 -> proyecto [style="dotted"];
  proyecto -> proyecto [label="."];
  proyecto -> usr2 [label=".."];
  usr2 -> tarea_c2;
  usr2 -> proyecto;

  proyecto -> README;
  proyecto -> proy_c;

  root [label="<raiz>", shape=box];
  home [shape=box];
  usr1 [shape=box];
  usr2 [shape=box];
  proyecto [shape=box];
  a_out [label="a.out"];
  test_c1 [label="test.c"];
  tarea_c2 [label="tarea.c"];
  proy_c [label="proy.c"];
}
#+end_src

#+results:
[[file:ltxpng/directorio_DAG_completo.png]]
#+html: <p align="center">Directorio como un /grafo dirigido/: El directorio <tt>proyecto</tt> está tanto en el directorio <tt>/home/usr1</tt> como en el directorio <tt>/home/usr2</tt></p></div>

En todos los directorios, =.= es una liga dura al mismo directorio, y
=..= es una liga al directorio padre. Claro está, como sólo puede
haber una liga =..=, un directorio que está enlazado desde dos lugares
distintos del sistema de archivos sólo apunta hacia uno de ellos con
su enlace =..=; en este caso, el directorio común =proyecto= está
dentro del directorio =/home/usr2=, y representamos la /liga
simbólica/ desde =/home/usr1= como una línea punteada.

Notarán que hay una excepción: El directorio raiz. En este caso,
tanto =.= como =..= apuntan al mismo directorio.

Y esta es la razón que mencionamos hace algunas líneas por la cual no
podemos ver a un árbol de archivos, ni en Windows ni en Unix, como a
un /grafo dirigido acíclico/: Tanto las entradas =.= (al apuntar al
mismo directorio donde están contentidas) como las entradas =..= (al
apuntar al directorio padre) crean ciclos.

** Operaciones con directorios
# <<oper_dirs>>
Al igual que los archivos, los directorios tienen una semántica
básica de acceso. Los directorios resultan también tipos de datos
abstractos con algunas operaciones definidas — Y como veremos, muchas
de las operaciones que realizaremos con los directorios son análogas
a las empleadas para los archivos.[fn:: De hecho, en algunos sistemas
operativos, los directorios son meramente archivos de tipo especial,
que son presentados al usuario de forma distinta. Pero no adelantemos
vísperas, ese tema lo veremos más adelante.] Las operaciones básicas
a presentar son:

- Abrir y cerrar  :: Al igual que los archivos, los directorios deben
     ser /abiertos/ para trabajar con ellos, y /cerrados/ cuando ya no
     se les requiera. Para esto, en C, se emplean las funciones
     =opendir()= y =closedir()=. Estas funciones trabajan asociadas a
     un /flujo de directorio/ (/directory stream/), que funciona de
     forma análoga a un descriptor de archivo.

- Listado de archivos :: Para mostrar los archivos que conforman a un
     directorio, el directorio se /abre/ (tal como un archivo, pero en
     C, con la función =opendir()= en vez de =open()=), y va /leyendo/
     (con =readdir()=) sus entradas una a una. Cada uno de los
     resultados es una estrcutura =dirent= (/entrada de directorio/),
     cada una de las cuales contiene su nombre en =d_name=, el
     identificador de su /i-nodo/ en =d_ino=, y algunos datos
     adicionales del arcihvo en cuestión.

     Para presentar al usuario la lista de archivos que conforman un
     directorio, podría hacerse:

     #+BEGIN_SRC c
       #include <stdio.h>
       #include <dirent.h>
       #include <sys/types.h>
       
       int main(int argc, char *argv[]) {
         struct dirent *archivo;
         DIR *dir;
         if (argc != 2) {
           printf("Indique el directorio a mostrar\n");
           return 1;
         }
         dir = opendir(argv[1]);
         while ((archivo = readdir(dir)) != 0) {
           printf("%s\t", archivo->d_name);
         }
         printf("\n");
         closedir(dir);
       }
     #+END_SRC

     Al igual que en al hablar de archivos, podemos /rebobinar/ el
     listado del directorio al principio del listado con
     =rewinddir()=.

- Buscar un elemento :: La mayor parte de las veces, no nos interesa
     tanto ver el listado de archivos que existen, sino que abrir uno
     en particular — Esto es, buscar el archivo que cumpla con cierto
     criterio, con cierto nombre. Queda claro que esto podemos hacerlo
     discriminando, de entre los resultados que nos va arrojando
     =readdir=, y obtener la o las entradas que nos interesen.

- Crear, eliminar o renombrar un elemento :: Si bien estas tres
     operaciones se implementan por medio de una operación de
     escritura en el directorio, se implementan a través de las
     funciones de manejo de archivos.

*** Recorriendo los directorios
# <<#dir_traversal>>

Es frecuente requerir aplicar una operación a todos los archivos
dentro de cierto directorio — Por ejemplo, si queremos agrupar a un
directorio completo en un archivo comprimido, o si queremos copiar
todos sus contenidos a otro medio. Procesar todas las entradas de un
directorio, incluyendo las de sus subdirectorios, se denomina
/recorrer el directorio/ (en inglés, /directory traversal/).

Si estamos trabajando en un sistema de archivos plano, la operación de
recorrido completo puede realizarse con un programa tan simple como el
que presentamos en [[#oper_dirs][la sección anterior]].

Al hablar de un sistema de profundidad fija, e incluso de un
directorio estructurado en árbol, la lógica se complica levemente,
dado que para recorrer el directorio tenemos que revisar, a cada
entrada, si esta es a su vez un directorio (y en caso de que así sea,
entrar y procesar a cada uno de sus elementos). Hasta aquí, sin
embargo, podemos recorrer el directorio sin requerir de mantener
estructuras adicionales en memoria representando el estado.

Sin embargo, cuando consideramos a los grafos dirigidos, se vuelve
indispensable mantener en memoria la contabilidad de todos los nodos
que ya hemos tocado — en caso contrario, al caer en un ciclo (incluso
si este es creado por mecanismos como las /ligas simbólicas/),
caeríamos en un ciclo infinito.

Para esto, no bastaría tomar nota de las rutas de los archivos
conforme avanzamos por el grafo — Cada vez que los encontremos, su
ruta será distinta (por ejemplo, veríamos =/home/usr/proy/archivo=,
seguido de =/home/usr/proy/mios/archivo=, a continuación del cual
seguiría =/home/usr/proy/mios/mios/archivo=, después de éste, seguiría
con =/home/usr/proy/mios/mios/mios/archivo=, etc.), pero emplear un
indexado basado en el número de /i-nodo/[fn:: Que si bien no definimos
aún formalmente lo que significa, sabemos que es único por sistema de
archivos] identifica sin lugar a dudas a cada uno de los archivos.

*** Otros esquemas de organización

Por más que el uso de sistemas de archivos basados en directorios
jerárquicos nos parece universal y muy ampliamente aceptado, hay cada
vez más casos de uso que apuntan a que podemos estar por dar la
bienvenida a una nueva metáfora de organización de archivos.

Hay distintas propuestas, y claro está, es imposible aún saber cuál
dirección obtendrá el favor del mercado — O, dado que no
necesariamente sigamos teniendo un modelo apto para todos los usos, de
/qué/ segmento del mercado.


** /Montaje/ de directorios

Para trabajar con el contenido de un sistema de archivos, el sistema
operativo tiene que /montarlo/: Ubicarlo en un punto del árbol de
archivos visible al sistema.

Es muy común, especialmente en los entornos derivados de Unix, que un
sistema operativo trabaje con distintos sistemas de archivos al mismo
tiempo. Esto puede obedecer a varias causas, entre las cuales tenemos:

- Distintos medios físicos :: Si la computadora tiene más de una
     unidad de almacenamiento, el espacio dentro de cada uno de los
     discos se maneje como un sistema de archivos indepentiente. Esto
     es especialmente cierto en la presencia de unidades removibles
     (diskettes, CDs, unidades USB, discos duros externos, etc.)

- Diferentes usos esperados :: Como veremos más adelante, distintos
     /esquemas de organización/ (esto es, distintos sistemas de
     archivos) presentan ventajas para distintas formas de uso. Por
     ejemplo, tiene sentido que una base de datos resida sobre una
     organización distinta a la de los comandos (binarios) del
     sistema.

- Abstracciones de sistemas no-físicos :: El sistema operativo puede
     presentar diversas estructuras /con una estructura/ de sistema de
     archivos. El ejemplo más claro de esto es el sistema de archivos
     virtual =/proc=, existente en los sistemas Unix, que permite ver
     diversos aspectos de los procesos en ejecución (y, en Linux, del
     sistema en general). Los archivos bajo =/proc= no existen en
     ningún disco, pero se presentna como si fueran archivos estándar.

- Razones administrativas :: El administrador del sistema puede
     emplear sistemas de archivos distintos para aislar espacios de
     usuarios entre sí: Por ejemplo, para evitar que un exceso de
     mensajes enviados en la bitácora (típicamente bajo =/var/log=)
     saturen al sistema de archivos principal, o para determinar
     patrones de uso máximo por grupos de usuarios.

En los sistemas tipo Unix, el mecanismo para montar los archivos es el
de un árbol con /puntos de montaje/. Esto es, /todos los archivos y
directorios/ del sistema operativo están estructurados en torno a /un
sólo árbol/. Cuando se solicita al sistema operativo /montar/ un
sistema de archivos en determinado lugar, éste se integra al árbol,
ocultando todo lo que el directorio en cuestión previamente
tuviera.[fn:: Hay implementaciones que exigen que el montaje se realice
exclusivamente en directorios vacíos; existen otras, como UnionFS, que
buscan seguir presentando una interfaz /de lectura/ a los objetos que
existían en el directorio previo al montaje, pero realizan las
escrituras únicamente en el sistema ya montado; estas complican
fuertemente algunos aspectos semánticos, por lo cual resultan poco
comunes.]

#+html: <div class="figure">
#+attr_latex: width=\textwidth
#+caption: Árbol formado del montaje de =sda1= en la raiz, =sda2= como =/usr=, =sdb1= como =/home=, y el directorio virtual =proc=
#+begin_src dot :exports results :file ltxpng/puntos_de_montaje.png
  digraph G {
          rankdir = TB;
          subgraph cluster0 {
                  label = "sda1";
                  color = lightgray;
                  style = filled;
                  root -> var;
                  root -> bin;
                  root -> sbin;
          }
          subgraph cluster1 {
                  label = "sda2";
                  color = lightblue;
                  style = filled;
                  usr -> usrbin;
                  usr -> usrlib;
                  usrbin -> bash;
                  usrbin -> perl;
          }
          subgraph cluster2 {
                  label="proc"
                  color=yellow;
                  style=filled;
                  proc -> 1;
                  proc -> 2;
                  proc -> 3;
          }
          subgraph cluster3 {
                  label = "sdb1";
                  color = pink;
                  style = filled;
                  home -> juan;
                  home -> pedro;
                  home -> irene;
                  juan -> tarea_c;
                  pedro -> proyecto_pl [style=dotted];
                  irene -> proyecto_pl;
          }
          
          root -> proc;
          root -> home;
          root -> usr;
          
          root [shape=box, label="/"];
          bin [shape=box];
          sbin [shape=box];
          usr [shape=box];
          proc [shape=box];
          var [shape=box];
          home [shape=box];
          usrbin [shape=box, label="bin"];
          usrlib [shape=box, label="lib"];
          juan [shape=box];
          pedro [shape=box];
          irene [shape=box];
  }
  
#+end_src

#+results:
[[file:ltxpng/puntos_de_montaje.png]]
#+html: <p align="center">Árbol formado del montaje de <tt>sda1</tt> en la raiz, <tt>sda2</tt> como <tt>/usr</tt>, <tt>sdb1</tt> como <tt>/home</tt>, y el directorio virtual <tt>proc</tt></p></div>

La manera en que esto se presenta en sistemas Windows es muy
distinta. Ahí, cada uno de los sistemas de archivos /detectados/
recibe un /identificador de volumen/, y es montado automáticamente en
un sistema de directorio estructurado como árbol de un sólo nivel
representando a los dispositivos del sistema.[fn:: En realidad, este
árbol no sólo incluye a los volúmenes de almacenamiento, sino que a
los demás dispositivos del sistema, como los distintos puertos, pero
los /oculta/ de la interfaz gráfica.] Este árbol es presentado a
través de la interfaz gráfica (aunque este nombre no significa nada
para el API del sistema) como /Mi PC/.

Entrando con el identificador de volumen, encontramos al contenido de
cada uno. De este modo, la especificación absoluta de un archivo es
una cadena como =VOL:\Dir1\Dir2\Archivo.ext= — El caracter =:= separa
al volumen del árbol del sistema de archivos, y el caracter
$\backslash$ separa uno de otro a los directorios.

Los identificadores de volumen están preasignados, muchos de ellos
siguiendo a un esquema heredado desde la época de las primeras PC: Los
volúmenes =A= y =B= están reservados para las unidades de disco
flexible; =C= se refiere al disco duro de arranque, y las unidades
posteriores que va detectando el sistema son =D=, =E=, =F=, etc.

Es posible modificar esta nomenclatura y configurar a los discos para
estar en otra ubicación, pero muchas aplicaciones dependen ya de este
comportamiento y configuración específicos.

#+html: <div class="figure">
#+attr_latex: width=0.7\textwidth
#+caption: Vista de un sistema de archivos Windows
#+begin_src dot :exports results :file ltxpng/montaje_windows.png
digraph G {
	rankdir=LR;
	subgraph cluster0 {
		label = "C:"
		color = lightblue;
		style="filled"
		raiz_c [shape=box, label="\\"];
		windows [shape=box, label="Windows"];
		archprog [shape=box, label="Archivos de programa"]
		docset [shape=box, label="Documents and Settings"]
		usr1 [shape=box, label="Usuario 1"]
		desktop [shape=box, label="Escritorio"]
		menu [shape=box, label="Menú Inicio"]
		misdoc [shape=box, label="Mis documentos"]
		system32 [shape=box];
		prog1 [label="prog1.exe"];
		prog2 [label="prog2.exe"];
		prog3 [label="prog3.exe"];

		raiz_c -> windows;
		windows -> system32;
		system32 -> prog1;
		system32 -> prog2;
		system32 -> prog3;
		raiz_c -> archprog;
		raiz_c -> docset;
		docset -> usr1;
		usr1 -> desktop;
		usr1 -> menu;
		usr1 -> misdoc;
	}

	subgraph cluster1 {
		label = "D:"
		color = yellow;
		style="filled"
		raiz_d [shape=box, label="\\"];
		doc [shape=box, label="Documentos"]
		pres [shape=box, label="Presentaciones"]
		doc1 [label="Avance del proyecto.docx"]
		doc2 [label="Datos 2000-2004.doc"]
		pres1 [label="Presentación.ppt"]

		raiz_d -> doc;
		raiz_d -> pres;
		doc -> doc1;
		doc -> doc2;
		pres -> pres1;
	}

	raiz [shape=box, label="<Mi PC>"];
	raiz -> raiz_c
	raiz -> raiz_d
}
#+end_src

#+results:
[[file:ltxpng/montaje_windows.png]]
#+html: <p align="center">Vista de un sistema de archivos Windows</p></div>

** Sistemas de archivos remotos

Uno de los principales y primeros usos que se dio a la comunicación en
red fue el de compartir archivos entre computadoras independientes. En
un principio, esto se realizaba de forma /explícita/, con
transferencias manuales a través de programas dedicados a ello, como
sería hoy en día el FTP.

Por otro lado, desde mediados de los 1980, es posible realizar estas
transferencias de forma /implícita/ y /automática/, empleando
/sistemas de archivos sobre la red/ (o lo que es lo mismo, /sistemas
de archivos remotos/).  Estos se nos presentan como caso particular de
la /abstracción de sistemas no-físicos/ que mencionamos en la sección
anterior: Si bien el sistema operativo no tiene acceso /real/ a los
archivos y directorios que le solicitará el usuario, a través de los
módulos de red, sabe cómo obtenerlos y presentarlos /como si fueran
locales/.

*** Network File System (NFS)
*** Server Message Block (SMB)
*** Sistemas de archivos distribuídos: Andrew File System (AFS)


* El medio físico

* Generalidades

Un /sistema de archivos/ es la estructura por medio de la cual el
sistema operativo organiza y presenta las abstracciones necesarias
para la organización a largo plazo de la información (típicamente) en
un dispositivo /persistente/.

El sistema de archivo que elijamos o implementemos debe tomar en
cuenta por un lado las características físicas del medio que empleará,
y por el otro las necesidades del sistema a crear. Por ejemplo:

- Tiempo de acceso necesario para realizar una operación: Cinta ≫
  Floppy ≫ Disco duro > Disco duro /inteligente/ ≈ Flash > NVRAM ≫ RAM

- Forma de acceso presentada al sistema: Secuencial (cinta), bloques
  con referencia de direccionamiento física (floppy, disco duro),
  bloques consecutivos (disco duro /inteligente/, Flash, NVRAM, RAM

- Tipo de sistema: ¿Multiusuario? ¿Multiproceso? ¿Embebido? ¿Uso
  genérico?

- Uso esperado del medio: Fijo / transportable → Impacto no sólo en
  estrategias de almacenamiento, sino que de compatibilidad con una
  gama más amplia de equipos.

Hay programas de ámbito especializado que no emplean sistemas de
archivos para el almacenamiento de su información. Principalmente,
estos son gestores de bases de datos que, dada la naturaleza altamente
regular y predecible de la información que manejan, permiten trabajar
con /dispositivos crudos/ (esto es, particiones gestionadas por ellos,
e invisibles a los demás programas). Esto es partiendo de la lógica
que hacerlo de esta manera evita tener que atravesar capas
innecesarias de abstracción y busca un mejor rendimiento al trabajar
tan cerca como sea posible del hardware subyacente. Esta técnica, sin
embargo, cada vez es menos común por la forma menos transparente de
operación que tienen los dispositivos (y que veremos posteriormente).

** Conceptos básicos

- Disco :: Dispositivo en el que se almacena la información
           (independientemente del tipo de medio que sea). Define un
           /tamaño de bloque/, que es la unidad de información que
           puede almacenar con una sóla operación (típicamente 512
           bytes).

	   Si bien un sistema de archivos puede implementarse sobre
	   medios de muy distinta naturaleza, por la carga histórica
	   de ser el medio primario de almacenamiento permanente, a lo
	   largo de esta sección nos referiremos a /disco/ como el
	   medio genérico, incluso si hablamos de sistemas de archivos
	   virtuales o sobre memorias de /estado sólido/.
- Partición :: Una subdivisión de un disco, por medio de la cual el
               administrador/usuario del sistema puede definir la
               forma en que se emplea el espacio de un disco. Un disco
               puede tener varias particiones, y cada una de ellas
               puede tener un sistema de archivos independiente.
- Volumen :: Colección de bloques /inicializados/ con un sistema de
             archivos que pueden presentarse al usuario como una
             unidad. Típicamente un volumen coincide con una
             partición (pero no siempre es el caso).
- Superbloque :: El área del volumen que contiene la /información
                 crítica/ de éste: Su capacidad, tipo de sistema de
                 archivo, nombre/etiqueta, etc.
- Archivo :: La estructura primaria del sistema de archivos: Relaciona
             un /nombre de archivo/ con la información que éste
             representa.

	     Desde el punto de vista de los procesos, el sistema
	     /guarda/ o /recupera/ la información /en/ un archivo; el
	     archivo tiene un /nombre/ por medio del que se le identifica.
- Directorio :: Casi todos los sistemas de archivos en uso hoy en día
                implementan una /jerarquía maestra/ en la cual se
                ubican los archivos. Esta jerarquía se presenta
                típicamente como un árbol — Un /grafo acíclico/ que
                proporciona /rutas únicas/ para la ubicación lógica de
                cada uno de los archivos.
- Metadatos :: Información acerca de un archivo que no es el archivo
               mismo. Por ejemplo, el nombre, tamaño o tipo del
               archivo, su propietario, el control de acceso, sus
               fechas de creación, último acceso y modificación, etc.
- I-nodo o bloque de control de archivo (/FCB/) :: La estructura en
     disco que guarda los metadatos de cada archivo, proporcionando un
     vínculo entre la /entrada en el directorio/ y la información que
     referida.

* Concepto y tipos de archivos

Unix introdujo el concepto de que /todo es un archivo/: En el sistema
Unix original, todos los dispositivos podían ser controlados a través
de un /archivo especial/ que, en vez de almacenar información, apunta
a estructuras en el sistema que controlan a cada dispositivo. Este
concepto sobrevive en los sistemas derivados de Unix al día de hoy,
aunque varias clases de dispositivo rompen esta lógica. El sistema
operativo /Plan9/ de Bell Labs hace mantiene y amplía este concepto e
introduce los /espacios de nombres mutables/, que presenta con
interfaz de archivo archivos prácticamente cualquier objeto empleado
por el sistema.

** Archivos de dispositivo

Las principales estructuras relacionadas que encontraremos en un
sistema tipo Unix son:

- Dispositivos de caracteres :: Dispositivos con los cuales la
     información es leída o escrita un caracter a la vez y se
     presentan como /streams/ (flujos) de información, ya sea
     entrante, saliente o mixta. Algunos pueden permitir operaciones
     adicionales (por ejemplo, rebobinado), pero la manipulación de la
     información se efectúa de forma secuencial.

     Ejemplos: Impresora, unidad de cinta, modem
- Dispositivos de bloques :: Dispositivos que presentan una interfaz
     de /acceso aleatorio/ y entregan o reciben la información en
     /bloques/ de tamaño predeterminado.

     El ejemplo más claro de este tipo de dispositivos es una unidad
     de disco o una de sus particiones.

** Ligas

Las ligas son objetos que ocupan un espacio en el directorio, pero
/apuntan/ a un archivo distinto, cuya información está en otro lugar
del sistema de archivos o con otro nombre; la información que
almacenan es el nombre del archivo destino.

Las ligas simbólicas pueden ser /relativas/ (indicando la ruta a
partir de la ubicación en que está) o /absolutas/ (indicando la ruta a
partir de la raiz).

El archivo destino puede estar en otro sistema de archivos montado en
el sistema.

Diferentes sistemas operativos implementan esquemas semejantes
(p.ej. los /accesos directos/ en Windows), con diferentes grados de
transparencia ante las aplicaciones.

Es importante no confundir las /ligas simbólicas/ con las /ligas
duras/, que abordaremos más adelante.

** Herramientas de comunicación entre procesos

Muy frecuentemente, dos procesos (relacionados o no en el árbol de
procesos) tienen que intercambiar información a lo largo de su ciclo
de vida. Si bien sería posible hacerlo a través de una interfaz de
memoria compartida y envío de mensajes, muchas veces es más fácil
emplear un archivo como si fuera un dispositivo de datos o una
conexión en red. En Unix contamos con los siguientes tipos de archivo
para este fin:

- /Named pipes/ :: Se traduciría literalmente como /tuberías con
                   nombre/. Representan un mecanismo de IPC
                   (comunicación entre procesos) que permite que dos
                   procesos no relacionados se comuniquen de forma
                   unidireccional: Uno abre el archivo para escritura,
                   el otro para lectura, y lo que el primero
                   "deposite" en el archivo, el segundo lo recibirá
                   como entrada.
- Sockets :: (Unix domain sockets, sockets de dominio Unix). Mecanismo
             de comunicación bidireccional similar al de los /named
             pipes/, pero más completo, permitiendo comunicación
             bidireccional de un modo muy similar al de la
             comunicación entre dos procesos en red.


* Esquema general de un sistema de archivos

Hay una serie de estructuras básicas que se repiten prácticamente en
todos los sistemas operativos diseñados en las últimas décadas:

- Superbloque :: El descriptor primario del sistema de archivos;
                 incluye la /firma/ del sistema de archivos empleado
                 para permitir su identificación por parte del sistema
                 operativo, y otros datos básicos (como tamaño del
                 sistema de archivos, tamaño del bloque, etiqueta,
                 etc.)

- Directorio raiz :: La estructura base con el listado de nombres de
     archivo. Típicamente sólo almacena los archivos que están en el
     /primer nivel jerárquico/ del directorio, y los directorios
     derivados son únicamente referenciados desde éste.

     El directorio normalmente incluye sólo el nombre de cada uno de
     los archivos y el número de /I-nodo/ que lo describe.

- I-nodos :: La estructura que vincula a una entrada de directorio con
             la información propiamente almacenada en el archivo es el
             I-nodo (nomenclatura Unix: Nodo de información; conocido
             también como FCB, /File Control Block/).

	     La información almacenada incluye los permisos y
	     propietarios del archivo y la /relación de bloques/ que
	     ocupa en el disco. Veremos más adelante los esquemas más
	     comunes para presentar esta relación de bloques.

#+begin_center
[[./img/inode_addr.png]]

Practical File System Design, p.12
#+end_center

- Bitmap :: La función del bitmap es poder gestionar el espacio libre
            del disco. Recordemos que el disco se presenta asignado
            por /bloques/, típicamente de 4096 bytes — En el bitmap
            cada bloque se representa con un bit, con lo que aquí
            podemos encontrar de forma compacta el espacio ocupado y
            disponible, así como el lugar adecuado para crear un nuevo
            archivo.

	    El bitmap para un disco de 100GB puede, de esta manera,
            representarse en 23MB ($100 \times 10^9 \over 4096$),
            cantidad que puede razonablemente mantener en memoria un
            sistema de escritorio promedio hoy en día.

	    Veremos más adelante algunas estructuras avanzadas que
            permiten mayor eficiencia en este sentido.

* Direccionamiento directo e indirecto

Los límites de un sistema de archivos vienen de una serie de
decisiones de diseño, y hay varias estrategias que se han ido
desarrollando para lidiar con estos límites. Veremos aquí lo relativo
a la capacidad máxima de los sistemas de archivos.

Todo sistema de archivos tiene límites máximos en relación a la
cantidad de datos que pueden ser direccionados. Este límite es dado
por el producto del tamaño de bloque por la longitud de sus
direcciones.

** Ejemplo: FAT

Un ejemplo de un sistema de archivos sencillo, y de direccionamiento
estrictamente directo, con muy largo tiempo en uso y al mismo tiempo
una muy amplia base instalada son los basados en FAT (MS-DOS en
adelante).

#+begin_center
[[./img/fat.png]]

https://en.wikipedia.org/wiki/File_Allocation_Table#Layout
#+end_center

En su primer implementación, FAT12 (MS-DOS < 3.3) manejaba
direccionamiento de 12 bits y /clusters/ tamaño fijo, de 8 bloques de
512 bytes (4096 bytes). 12 bits permite direccionar hasta 4096
posiciones independientes, por lo que el tamaño máximo de partición
que podía manejar era de 16MB.

Al introducirse FAT16 en 1984, la principal ventaja fue /menor espacio
desperdiciado/ dado que para el mismo disco duro los clusters podían
ser de menor número de sectores.

El sistema de archivos FAT tuvo varias revisiones menores; la última
importante fue en 1996, FAT32, con espacio de direccionamiento de 28
bits y tamaño de cluster de entre 1 y 8 sectores (512 y 4096 bytes),
lo cual permite particiones de hasta 16TB.

** Ejemplo: FFS

Como segundo ejemplo podemos referirnos al /Sistema de Archivos Ágil
de Berkeley/ (Berkeley Fast File System, FFS).

* Organización y acceso a archivos
* Estructura de los directorios
* Estructura de los sistemas de archivos
* Métodos de asignación
* Administración del espacio libre

* Particularidades de medios: Cuando no es un disco

Ver: [[http://lwn.net/Articles/528617/][JFFS2, UBIFS, and the growth of flash storage]]
* Otros recursos
- Practical File System Design (Dominic Giampaolo, 1999): El autor fue
  parte del equipo que implementó el sistema operativo BeOS, un
  sistema de alto rendimiento pensado para correr en estaciones de
  alto rendimiento, particularmente enfocado al video. El proyecto
  fracasó a la larga, y BeOS (así como BeFS, el sistema que describe)
  ya no se utilizan. Este libro tiene una muy buena descripción de
  varios sistemas de archivos, y aborda a profundidad técnicas que
  hace 15 años eran verdaderamente novedosas, y hoy forman parte de
  casi todos los sistemas de archivos con uso amplio, e incluso
  algunas que no se han logrado implementar y que BeFS sí ofrecía.

- [[http://www.cs.berkeley.edu/~brewer/cs262/FFS.pdf][A Fast File System for UNIX]] (Marshall Kirk Mckusick, William N. Joy,
  Samuel J. Lefler, Robert S. Fabry, 1984)

- [[http://www.cs.berkeley.edu/~brewer/cs262/LFS.pdf][The Design and Implementation of a Log-Structured File System]]
  (Mendel Rosenblum, J. K. Ousterhout, 1992)

- [[http://www.nongnu.org/ext2-doc/][The Second Extended File System: Internal Layout]] (Dave Poirier,
  2001-2011)

- [[http://www.cyanezfdz.me/nilfs2-en-linux.html][NILFS2 en Linux]] (César Yáñez)

- [[http://www.cyanezfdz.me/los-discos-desde-la-perspectiva-de-un-sistema-de-archivos.html][Los discos desde la perspectiva de un sistema de archivos]] (César
  Yáñez)

- [[http://lwn.net/Articles/529077/][A hash-based DoS attack on Btrfs]] (LWN)

- [[http://linux.slashdot.org/story/12/12/15/0055217/denial-of-service-attack-found-in-btrfs-file-system][Denial-of-Service Attack Found In Btrfs File-System]] (Slashdot)

- [[http://bugs.debian.org/cgi-bin/bugreport.cgi?archive=no&bug=682840][Default /etc/apache2/mods-available/disk_cache.conf is incompatible
  with ext3]] (bug de Debian ilustrando los límites en números de
  archivos para Ext3)
