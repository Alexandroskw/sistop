#+TITLE: Sistemas Operativos
#+AUTHOR: Gunnar Wolf
#+EMAIL: gwolf@gwolf.org
#+LANGUAGE: es

* Generalidades del curso
** Calendario general
Esta materia se imparte los días /lunes, miércoles y viernes/ de
13:00 a 14:30 en *algún día sabré qué salón*.

Según el [[https://www.dgae.unam.mx/pdfs/semestral2013.pdf][calendario del plan semestral 2013]], la primer sesión es el
lunes 28 de enero, y la última el viernes 24 de mayo, lo cual nos
daría 16 semanas (ya descontando el asueto académico por Semana Santa)
— 48 clases, o las 72 horas que contempla el [[http://www.ingenieria.unam.mx/paginas/Carreras/planes2010/Computacion/05/sistemas_operativos.pdf][temario de la materia]].

Por feriados, /perderemos/ cinco sesiones: 4 de febrero, 18 de marzo,
y 1, 10 y 15 de mayo. Esto es, para el semestre 2013-2, en este curso
contaremos con 64.5 horas efectivas de clase.

** Punto de partida

Esta clase asume que tienen todo el conocimiento básico de los
[[http://www.ingenieria.unam.mx/paginas/Carreras/planes2010/ingComputo_Plan.htm][primeros cuatro semestres de la carrera de Ingeniería en
Computación]]. Esto es, aunque la única seriación formal es con la
materia /Estructura y programación de computadoras/, voy a dar por
hecho familiaridad con los demás conocimientos, en particular con
[[http://www.ingenieria.unam.mx/paginas/Carreras/planes2010/Computacion/02/computacion_para_ingenieros.pdf][Computación para ingenieros]], [[http://www.ingenieria.unam.mx/paginas/Carreras/planes2010/Computacion/03/programacion_avanzada_y_metodos_numericos.pdf][Programación avanzada y métodos
numéricos]], [[http://www.ingenieria.unam.mx/paginas/Carreras/planes2010/Computacion/04/algoritmos_y_estructuras_de_datos.pdf][Algoritmos y estructuras de datos]].

Asumo también que están familiarizados (o que se familiarizarán
prontamente al iniciar el curso) con algún lenguaje de programación
de alto nivel, y –al menos a nivel básico– con C — En ambos casos,
no sólo para desarrollar ejercicios, sino para entender código
ejemplo.

Resultará muy conveniente que tengan acceso a una computadora con
sistema operativo Linux

** Forma de evaluación


* Introducción a los sistemas operativos
- Objetivo :: El alumno describirá las funciones, características y
              estructura de los sistemas operativos

El /sistema operativo/ es el principal programa que corre en toda
computadora de propósito general.

Hay sistemas operativos de todo tipo, desde muy simples hasta
terriblemente complejos, y entre más casos de uso hay para el cómputo
en la vida diaria, más variedad habrá en ellos.

No nos referiremos al sistema operativo como lo ve el usuario final, o
como lo vende la mercadotecnia — El ambiente gráfico, los programas
que se ejecutan en éste, la diferencia en el uso son sólo –y si mucho–
/consecuencias/ del diseño de un sistema operativo. Más aún, con el
mismo sistema operativo –como pueden constatarlo comparando dos
distribuciones de Linux, o incluso la forma de trabajo de dos usuarios
en la misma computadora– es posible tener /entornos operativos/
completamente disímiles.

La importancia de este curso radica no sólo en comprender los
mecanismos que emplean los sistemas operativos para cumplir sus tareas
sino en que comprendan estos mecanismos para evitar los errores más
comunes al programar, que pueden resultar desde un rendimiento
deficiente hasta pérdida de información.

Como desarrolladores, comprender el funcionamiento básico de los
sistemas operativos y las principales alternativas que nos ofrecen en
muchos de puntos, o saber diseñar algoritmos y procesos que se ajusten
mejor al sistema operativo en que vayamos a correrlo, puede resultar
en una diferencia cualitativa decisiva en nuestros productos.

** Funciones y objetivos de los sistemas operativos

El sistema operativo es el único programa que interactúa directamente
con el hardware de la computadora. Sus funciones primarias son:

- Abstracción :: Los programas no deben tener que preocuparse de los
                 detalles del acceso a hardware, o de la configuración
                 particular de una computadora. Un sistema operativo
                 se encarga de proporcionar una serie de abstracciones
                 para que los programadores puedan enfocarse en
                 resolver las necesidades particulares de sus
                 usuarios. Un ejemplo de la abstracción sería el que
                 la información esté organizada en /archivos/ y
                 /directorios/ (en uno o muchos /dispositivos de
                 almacenamiento/).

- Manejo de recursos :: Una sistema de cómputo puede tener a su
     disposición una gran cantidad de /recursos/ (memoria, espacio de
     almacenamiento, tiempo de procesamiento, etc.), y los diferentes
     /procesos/ que corran en él /compiten/ por ellos. Al gestionar
     toda la asignación de recursos, el sistema operativo puede
     implementar políticas que los asignen de forma efectiva y acorde
     a las necesidades establecidas para dicho sistema.

- Aislamiento :: Cada proceso y cada usuario no tendrán que
                 preocuparse por otros que estén usando el mismo
                 sistema — Idealmente, su /experiencia/ será la misma
                 que si el sistema estuviera exclusivamente dedicado a
                 su atención (aunque fuera un sistema menos
                 poderoso).

		 Para implementar correctamente las funciones de
		 aislamiento hace falta que el sistema operativo
		 cuente con ayuda del hardware.

** Evolución de los sistemas operativos
** Estructuras de los sistemas operativos
*** Sistemas operativos /cohabitantes/

Los primeros sistemas operativos no contaban con la ayuda en hardware
de diversos componentes indispensables para presentar ciertas
características de abstracción, como la /unidad de administración de
memoria/ (MMU) o un esquema de /anillos/ o niveles de protección.

Esto significó que tenían que realizar su tarea con la cooperación
explícita de los autores de todos los programas — Y que un programa
/mal comportado/ podía corromper la operación completa del equipo.

En esta primer etapa sí había sistemas operativos multiprocesos
(incluso en las computadoras personales — Por ejemplo, AmigaOS, ATARI
TOS hacia mediados de los 1980s), sin embargo, su estabilidad da mucho
que desear.

*** Sistemas operativos monolíticos

*** Sistemas operativos /microkernel/

Discusión interesante y reciente (diciembre 2012): [[http://tech.slashdot.org/story/12/12/02/1526240/multi-server-microkernel-os-genode-1211-can-build-itself?utm_source=rss1.0mainlinkanon&utm_medium=feed][Multi-server
microkernel OS Genode 12.11 can build itself]]. Ver también: [[http://genode.org/documentation/general-overview/index][Genode –
General overview]]

*** Sistemas con concepciones híbridas

- Linux con drivers implementados en espacio de usuario (FUSE)
- Paravirtualización

* Administración de procesos
- Objetivo :: El alumno identificará los tipos de procesos y sus
	      estados. Describirá las diferentes técnicas de
	      comunicación y sincronización de procesos concurrentes.
** Procesos. Concepto y estados de un proceso
** Hilos y multihilos
** Concurrencia
*** Exclusión mutua y sincronización
*** Bloqueos mutuos
* Administración de memoria
- Objetivo :: El alumno explicará las diferentes técnicas de
              asignación de memoria contigua y no contigua.
** Funciones y operaciones del administrador de memoria
** Asignación de memoria contigua
*** Partición de la memoria
*** Paginación
*** Segmentación
** Memoria virtual
*** Concepto
*** Paginación
*** Segmentación
*** Paginación y segmentación combinadas
*** Reemplazo de páginas
*** Asignación de marcos e hiperpaginación
* Planificación de procesos
- Objetivo :: El alumno explicará las diferentes técnicas de
              asignación del procesador a los procesos.
** Tipos de planificación
** Algoritmos de planificación
** Planificación de multiprocesadores y en tiempo real
** Planificación de hilos
* Sistemas de archivos
- Objetivo :: El alumno describirá las diferentes formas de
	      organización y acceso a archivos, basándose en el modelo
	      de sistema de archivos.

Para este tema recomiendo fuertemente referirse al libro [[practical
file system design]] (sección /Bibliografía adicional/).

Un /sistema de archivos/ es la estructura por medio de la cual el
sistema operativo organiza y presenta las abstracciones necesarias
para la organización a largo plazo de la información (típicamente) en
un dispositivo /persistente/.

El sistema de archivo que elijamos o implementemos debe tomar en
cuenta por un lado las características físicas del medio que empleará,
y por el otro las necesidades del sistema a crear. Por ejemplo:

- Tiempo de acceso necesario para realizar una operación: Cinta ≫
  Floppy ≫ Disco duro > Disco duro /inteligente/ ≈ Flash > NVRAM ≫ RAM

- Forma de acceso presentada al sistema: Secuencial (cinta), bloques
  con referencia de direccionamiento física (floppy, disco duro),
  bloques consecutivos (disco duro /inteligente/, Flash, NVRAM, RAM

- Tipo de sistema: ¿Multiusuario? ¿Multiproceso? ¿Embebido? ¿Uso
  genérico?

- Uso esperado del medio: Fijo / transportable → Impacto no sólo en
  estrategias de almacenamiento, sino que de compatibilidad con una
  gama más amplia de equipos.

Hay programas de ámbito especializado que no emplean sistemas de
archivos para el almacenamiento de su información. Principalmente,
estos son gestores de bases de datos que, dada la naturaleza altamente
regular y predecible de la información que manejan, permiten trabajar
con /dispositivos crudos/ (esto es, particiones gestionadas por ellos,
e invisibles a los demás programas). Esto es partiendo de la lógica
que hacerlo de esta manera evita tener que atravesar capas
innecesarias de abstracción y busca un mejor rendimiento al trabajar
tan cerca como sea posible del hardware subyacente. Esta técnica, sin
embargo, cada vez es menos común por la forma menos transparente de
operación que tienen los dispositivos (y que veremos posteriormente).

** Conceptos básicos

- Disco :: Dispositivo en el que se almacena la información
           (independientemente del tipo de medio que sea). Define un
           /tamaño de bloque/, que es la unidad de información que
           puede almacenar con una sóla operación (típicamente 512
           bytes).
- Partición :: Una subdivisión de un disco, por medio de la cual el
               administrador/usuario del sistema puede definir la
               forma en que se emplea el espacio de un disco. Un disco
               puede tener varias particiones, y cada una de ellas
               puede tener un sistema de archivos independiente.
- Volumen :: Colección de bloques /inicializados/ con un sistema de
             archivos que pueden presentarse al usuario como una
             unidad. Típicamente un volumen coincide con una
             partición (pero no siempre es el caso).
- Superbloque :: El área del volumen que contiene la /información
                 crítica/ de éste: Su capacidad, tipo de sistema de
                 archivo, nombre/etiqueta, etc.
- Archivo :: La estructura primaria del sistema de archivos: Relaciona
             un /nombre de archivo/ con la información que éste
             representa.

	     Desde el punto de vista de los procesos, el sistema
	     /guarda/ o /recupera/ la información /en/ un archivo; el
	     archivo tiene un /nombre/ por medio del que se le identifica.
- Directorio :: Casi todos los sistemas de archivos en uso hoy en día
                implementan una /jerarquía maestra/ en la cual se
                ubican los archivos. Esta jerarquía se presenta
                típicamente como un árbol — Un /grafo acíclico/ que
                proporciona /rutas únicas/ para la ubicación lógica de
                cada uno de los archivos.
- Metadatos :: Información acerca de un archivo que no es el archivo
               mismo. Por ejemplo, el nombre, tamaño o tipo del
               archivo, su propietario, el control de acceso, sus
               fechas de creación, último acceso y modificación, etc.
- I-nodo o bloque de control de archivo (/FCB/) :: La estructura en
     disco que guarda los metadatos de cada archivo, proporcionando un
     vínculo entre la /entrada en el directorio/ y la información que
     referida.

** Concepto y tipos de archivos

La razón principal de la existencia del sistema de archivos son /los
archivos/. Un archivo almacena información de /algún tipo/,
estructurado o no estructurado.


*** Estructuras relacionadas

Unix introdujo el concepto de que /todo es un archivo/: En el sistema
Unix original, todos los dispositivos podían ser controlados a través
de un /archivo especial/ que, en vez de almacenar información, apunta
a estructuras en el sistema que controlan a cada dispositivo. Este
concepto sobrevive en los sistemas derivados de Unix al día de hoy,
aunque varias clases de dispositivo rompen esta lógica. El sistema
operativo /Plan9/ de Bell Labs hace mantiene y amplía este concepto e
introduce los /espacios de nombres mutables/.

Las principales estructuras relacionadas que encontraremos en un
sistema tipo Unix son:

- Dispositivos de caracteres :: Dispositivos con los cuales la
     información es leída o escrita un caracter a la vez y se
     presentan como /streams/ (flujos) de información, ya sea
     entrante, saliente o mixta. Algunos pueden permitir operaciones
     adicionales (por ejemplo, rebobinado), pero la manipulación de la
     información se efectúa de forma secuencial.

     Ejemplos: Impresora, unidad de cinta, modem
- Dispositivos de bloques :: Dispositivos que presentan una interfaz
     de /acceso aleatorio/ y entregan o reciben la información en
     /bloques/ de tamaño predeterminado.

     El ejemplo más claro de este tipo de dispositivos es una unidad
     de disco o una de sus particiones.
- Ligas simbólicas :: Ocupan un espacio en el directorio, pero
     /apuntan/ a un archivo cuya información está en otro lugar; la
     información que almacenan es el nombre del archivo destino.

     Las ligas simbólicas pueden ser /relativas/ (indicando la ruta a
     partir de la ubicación en que está) o /absolutas/ (indicando la
     ruta a partir de la raiz).

     El archivo destino puede estar en otro sistema de archivos
     montado en el sistema.
- /Named pipes/ :: Se traduciría literalmente como /tuberías con
                   nombre/. Representan un mecanismo de IPC
                   (comunicación entre procesos) que permite que dos
                   procesos no relacionados se comuniquen de forma
                   unidireccional: Uno abre el archivo para escritura,
                   el otro para lectura, y lo que el primero
                   "deposite" en el archivo, el segundo lo recibirá
                   como entrada.
- Sockets :: (Unix domain sockets, sockets de dominio Unix). Mecanismo
             de comunicación bidireccional similar al de los /named
             pipes/, pero más completo, permitiendo comunicación
             bidireccional de un modo muy similar al de la
             comunicación entre dos procesos en red.

** Organización y acceso a archivos
** Estructura de los directorios
** Estructura de los sistemas de archivos
** Métodos de asignación
** Administración del espacio libre
* Sistemas de entrada/salida
- Objetivo :: El alumno explicará las diversas funciones de
	      entrada/salida en la administración y control de
	      dispositivos periféricos. Además analizará, con un
	      enfoque práctico, las diferentes políticas y técnicas de
	      almacenamiento de archivos en disco.
** Dispositivos de entrada/salida
** Organización de las funciones de entrada/salida
** Almacenamiento intermedio de la entrada/salida
** Planificación de discos
* Sistemas distribuidos
- Objetivo :: El alumno explicará cómo se administran los procesos y
	      archivos que se encuentran en un sistema distribuido.
** Proceso cliente/servidor
** Paso distribuido de mensajes
** Llamadas a procedimiento remoto
** Agrupaciones
** Gestión distribuida de procesos
*** Migración de procesos
*** Estados globales distribuidos
*** Exclusión mutua distribuida
*** Bloqueo mutuo distribuido
** Sistema de archivos distribuidos
* Seguridad y medidas de desempeño
- Objetivo :: El alumno explicará cómo asegurar el adecuado
              funcionamiento del sistema operativo.
** Amenazas a la seguridad
** Protección
** Intrusos
** Software maligno
** Desempeño, coprocesadores, risc y flujo de datos
** Modelado analítico
* Bibliografía
** Del programa de la Facultad
- CARRETO DE MIGUEL, GARCÍA PÉREZ: /Sistemas Operativos. Una visión
  aplicada/ (España, Mc. Graw Hill/Interamericana de España, 2001)
- DEITEL, H. M.: /Introducción a los Sistemas Operativos/ 2a. edición
  (México Addison Wesley Iberoamericana, 2000)
- FLYNN, Ida y McIver A.: /Sistemas Operativos/ 3a. edición (México,
  Thomson Learning, 2001)
- SILBERSCHATZ, GALVIN, GAGNE: /Sistemas Operativos/ 6a. edición
  (México, Limusa - Wiley, 2002)
- STALLINGS, William: /Operating Systems/ 5th edition (USA, Prentice
  Hall, 2004)
- TANENBAUM, Andrew y WOODHULL, Albert: /Sistemas Operativos. Diseño e
  implementación/ 2a. edición (México, Prentice Hall, 1999)
- MÁRQUEZ GARCÍA, Francisco Manuel: /UNIX. Programación avanzada/
  3a. edición (México Alfa omega Grupo Editor, 2004)

** Adicional (restringidos)

En esta sección pondré a su disposición textos variados; por razones
de derechos de autor, no puedo ofrecerlos abiertamente, así que
estarán protegidos por una contraseña que les daré en clase.

Tampoco quiero con esto romper la ley con material actualmente en
venta — Estos textos pueden ser viejos (llamémosle "clásicos") y ya no
disponibles para su venta, o claramente no destinados a ello.

- [[http://sistop.gwolf.org/biblio/priv/An_operating_system_vade_mecum_-_Raphael_Finkel.pdf][An Operating Systems Vade Mecum (Raphael Finkel, 1988)]]. Si bien este
  libro es ya algo más que muy viejo, especialmente dada la velocidad
  de este campo, tiene muy buenas descripciones de varios de los temas
  que abordaremos.

# <<practical file system design>>
- [[http://sistop.gwolf.org/biblio/priv/Practical_file_system_design_with_the_Be_File_System_-_Dominic_Giampaolo.pdf][Practical file system design with the Be File System (Dominic
  Giampaolo, 1999)]]. Giampaolo fue parte del equipo que implementó el
  sistema operativo BeOS, un sistema de alto rendimiento pensado para
  correr en estaciones de alto rendimiento, particularmente enfocado
  al video. El proyecto fracasó a la larga, y BeOS (así como BeFS, el
  sistema que describe) ya no se utilizan. Este libro tiene una muy
  buena descripción de varios sistemas de archivos, y aborda a
  profundidad técnicas que hace 15 años eran verdaderamente novedosas,
  y hoy forman parte de casi todos los sistemas de archivos con uso
  amplio, e incluso algunas que no se han logrado implementar y que
  BeFS sí ofrecía.
